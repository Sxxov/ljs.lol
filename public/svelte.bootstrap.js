
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.1' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.24.1 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, remove it before we run the matching
    			if (prefix) {
    				if (typeof prefix == "string" && path.startsWith(prefix)) {
    					path = path.substr(prefix.length) || "/";
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Router", $$slots, []);

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		return this.$$.ctx[3];
    	}

    	set routes(routes) {
    		this.$set({ routes });
    		flush();
    	}

    	get prefix() {
    		return this.$$.ctx[4];
    	}

    	set prefix(prefix) {
    		this.$set({ prefix });
    		flush();
    	}

    	get restoreScrollState() {
    		return this.$$.ctx[5];
    	}

    	set restoreScrollState(restoreScrollState) {
    		this.$set({ restoreScrollState });
    		flush();
    	}
    }

    var router = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': Router,
        wrap: wrap$1,
        loc: loc,
        location: location,
        querystring: querystring,
        push: push,
        pop: pop,
        replace: replace,
        link: link
    });

    // copied from svelte's implementation
    class Store {
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        constructor(value) {
            this.subscribers = [];
            this.subscriberQueue = [];
            this.value = null;
            this.stop = null;
            this.value = value ?? null;
        }
        neq(a, b) {
            // eslint-disable-next-line no-self-compare, eqeqeq
            return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
        }
        set(newValue) {
            if (this.neq(this.value, newValue)) {
                this.value = newValue;
                if (this.stop) { // store is ready
                    const runQueue = !this.subscriberQueue.length;
                    for (let i = 0; i < this.subscribers.length; i += 1) {
                        const s = this.subscribers[i];
                        s[1]();
                        this.subscriberQueue.push(s, this.value);
                    }
                    if (runQueue) {
                        for (let i = 0; i < this.subscriberQueue.length; i += 2) {
                            this.subscriberQueue[i][0](this.subscriberQueue[i + 1]);
                        }
                        this.subscriberQueue.length = 0;
                    }
                }
            }
        }
        update(fn) {
            this.set(fn(this.value));
        }
        subscribe(run, invalidate = () => { }) {
            const subscriber = [run, invalidate];
            this.subscribers.push(subscriber);
            if (this.subscribers.length === 1) {
                this.stop = () => { };
            }
            run(this.value);
            return () => {
                this.unsubscribe(subscriber);
            };
        }
        unsubscribe(subscriber) {
            const index = this.subscribers.indexOf(subscriber);
            if (index !== -1) {
                this.subscribers.splice(index, 1);
            }
            if (this.subscribers.length === 0) {
                this.stop();
                this.stop = null;
            }
        }
    }

    const isSceneOutAnimationRunning = new Store(false);
    const isSceneInAnimationRunning = new Store(false);
    const isOutAnimationRunning = new Store(false);
    const isInAnimationRunning = new Store(false);
    const navigatorAppBarScrolledHeight = new Store(0);
    const navigatorAppBarBaseHeight = new Store(0);

    class ForUtility {
        static addToArrayPrototype() {
            // non-standard, used by this to keep track of the singleton
            if (Array.prototype.__forUtilitySingletonExecuted) {
                return;
            }
            const methods = {
                fastEach(callback, ctx = null) {
                    const workingArray = this;
                    if (ctx === null) {
                        for (let i = 0, l = workingArray.length; i < l; ++i) {
                            callback(workingArray[i], i);
                        }
                        return;
                    }
                    for (let i = 0, l = workingArray.length; i < l; ++i) {
                        callback.call(ctx || this, workingArray[i], i);
                    }
                },
                async forAwait(callback, ctx = null) {
                    const workingArray = this;
                    for (let i = 0, l = workingArray.length; i < l; ++i) {
                        await callback.call(ctx || this, workingArray[i], i);
                    }
                },
                getAll(callback, ctx = null) {
                    const workingArray = this;
                    const returnValues = [];
                    for (let i = 0, l = workingArray.length; i < l; ++i) {
                        if (callback.call(ctx || this, workingArray[i], i)) {
                            returnValues.push(workingArray[i]);
                        }
                    }
                    return returnValues;
                },
                getSome(callback, ctx = null) {
                    const workingArray = this;
                    for (let i = 0, l = workingArray.length; i < l; ++i) {
                        if (callback.call(ctx || this, workingArray[i], i)) {
                            return workingArray[i];
                        }
                    }
                    return null;
                },
            };
            Object.keys(methods).forEach((key) => {
                Array.prototype[key] = methods[key];
            });
            Array.prototype.__forUtilitySingletonExecuted = true;
        }
    }

    class LogUtility {
        static mixClass(ClassItem) {
            const ProcessedClassItem = class extends ClassItem {
            };
            ProcessedClassItem.prototype.debug = LogUtility.debug;
            ProcessedClassItem.prototype.log = LogUtility.log;
            ProcessedClassItem.prototype.warn = LogUtility.warn;
            ProcessedClassItem.prototype.error = LogUtility.error;
            return ProcessedClassItem;
        }
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        static addToContext(ctx) {
            globalThis.__logLevel = globalThis.__logLevel ?? 2;
            ctx.debug = LogUtility.debug;
            ctx.log = LogUtility.log;
            ctx.warn = LogUtility.warn;
            ctx.error = LogUtility.error;
        }
        static debug(message = '', ctx = this) {
            LogUtility.__boiler({
                message,
                logLevel: LogUtility.LOG_LEVEL.DEBUG,
                printFunction: console.log,
                ctx,
            });
        }
        static log(message = '', ctx = this) {
            LogUtility.__boiler({
                message,
                logLevel: LogUtility.LOG_LEVEL.INFO,
                printFunction: console.log,
                ctx,
            });
        }
        static error(message = '', ctx = this) {
            LogUtility.__boiler({
                message,
                logLevel: LogUtility.LOG_LEVEL.ERROR,
                printFunction: console.error,
                ctx,
            });
        }
        static warn(message = '', ctx = this) {
            LogUtility.__boiler({
                message,
                logLevel: LogUtility.LOG_LEVEL.WARN,
                printFunction: console.warn,
                ctx,
            });
        }
        static async __boiler({ message = '', logLevel = LogUtility.LOG_LEVEL.INFO, printFunction = console.log, ctx, }) {
            // eslint-disable-next-line no-nested-ternary
            const constructor = getTag(ctx);
            // get the log level name from 'logLevel' as value (eg. { ...VERBOSE: 4 } → 'VERBOSE')
            const [logLevelProperty] = Object.keys(this.LOG_LEVEL)
                .filter((key) => this.LOG_LEVEL[key] === logLevel);
            const currentTime = new Date().toLocaleString();
            const logMessage = `[${currentTime}] [${constructor}/${logLevelProperty}]: ${message}`;
            if (logLevel > globalThis.__logLevel) {
                return;
            }
            printFunction(logMessage);
            function getTag(context) {
                if (typeof context === 'string') {
                    return context;
                }
                if (!context?.constructor?.name
                    || context.constructor === LogUtility) {
                    return 'null';
                }
                return context.constructor.name;
            }
        }
    }
    LogUtility.LOG_LEVEL = {
        DEBUG: 4,
        INFO: 3,
        WARN: 2,
        ERROR: 1,
        NONE: 0,
    };

    class $Factory {
        create(objectToCreateFrom = {}) {
            ForUtility.addToArrayPrototype();
            const object = {
                evaluate(functionToEvaluate) {
                    return this.apply(functionToEvaluate(this));
                },
                addClass(classNames) {
                    switch (classNames.constructor) {
                        case String:
                            classNames.split(' ').fastEach((className) => {
                                this.classList.add(className);
                            });
                            break;
                        case Array:
                            classNames.fastEach((className) => {
                                this.addClass(className);
                            });
                            break;
                    }
                    return this;
                },
                removeClass(classNames) {
                    switch (classNames.constructor) {
                        case String:
                            classNames.split(' ').fastEach((className) => {
                                this.classList.remove(className);
                            });
                            break;
                        case Array:
                            classNames.fastEach((className) => {
                                this.removeClass(className);
                            });
                            break;
                    }
                    return this;
                },
                toggleClass(classNames) {
                    switch (classNames.constructor) {
                        case String:
                            classNames.split(' ').fastEach((className) => {
                                this.classList.toggle(className);
                            });
                            break;
                        case Array:
                            classNames.fastEach((className) => {
                                this.toggleClass(className);
                            });
                            break;
                    }
                    return this;
                },
                css(property, value, options = {}) {
                    // handle when the options are passed into the value argument
                    if (value
                        && value.constructor === Object) {
                        return this.css(property, undefined, value);
                    }
                    let processedValue = null;
                    let returnedValues = null;
                    let propertyHasParentheses = null;
                    let stackable = null;
                    const unitlessProperties = [
                        'opacity',
                        'gridRowStart',
                        'gridRowEnd',
                        'columns',
                        'columnCount',
                    ];
                    const stackableProperties = [{
                            name: 'transition',
                            hasParentheses: false,
                        }, {
                            name: 'transform',
                            hasParentheses: true,
                        }];
                    switch (property.constructor) {
                        case String:
                            // determine if the property is a stackable one
                            stackableProperties.fastEach(({ name, hasParentheses, }) => {
                                // return if the 'property' is not in 'stacakbleProperties'
                                if (name !== property) {
                                    return;
                                }
                                stackable = true;
                                propertyHasParentheses = hasParentheses;
                            });
                            if (value === undefined) {
                                // the value of the property should be returned instead of set
                                processedValue = this.style[property];
                                if (options.computed) {
                                    processedValue = getValueWithoutUnit(getComputedStyle(this)[property]);
                                }
                                if (stackable
                                    && options.returnAsObject) {
                                    processedValue = getAttributesFromValueString(processedValue, propertyHasParentheses);
                                }
                                return processedValue;
                            }
                            // the value of the property should be set instead of returned
                            processedValue = value;
                            // if the value string is missing a unit, add px
                            if (unitlessProperties.includes(property) === false) {
                                processedValue = getValueWithUnit(value);
                            }
                            if (stackable) {
                                // create attribute objects from the value strings
                                const oldAttributes = getAttributesFromValueString(this.style[property], propertyHasParentheses);
                                const newAttributes = getAttributesFromValueString(processedValue, propertyHasParentheses);
                                const processedAttributes = oldAttributes;
                                Object.assign(processedAttributes, newAttributes);
                                processedValue = getValueStringFromAttributes(processedAttributes, propertyHasParentheses);
                            }
                            this.style[property] = processedValue;
                            return this;
                        case Array:
                            if (value === undefined) {
                                returnedValues = {};
                                property.fastEach((item) => {
                                    returnedValues[item] = this.css(item);
                                });
                                return returnedValues;
                            }
                            property.fastEach((item, i) => {
                                this.css(item, value[i]);
                            });
                            return this;
                        case Object:
                            returnedValues = {};
                            Object.keys(property).fastEach((key) => {
                                const returnedValue = this.css(key, property[key]);
                                if (returnedValue === this) {
                                    return;
                                }
                                returnedValues[key] = returnedValue;
                            });
                            return returnedValues === {} ? this : returnedValues;
                        default:
                            return this.style;
                    }
                    function formatValueString(valueString) {
                        return valueString
                            .toLowerCase()
                            .replace(/\s/g, '');
                    }
                    function getValueWithoutUnit(valueWithUnit) {
                        if (valueWithUnit.includes('px') === false) {
                            return valueWithUnit;
                        }
                        return valueWithUnit.replace(/px/g, '');
                    }
                    function getValueWithUnit(valueWithoutUnit) {
                        if (!valueWithoutUnit) {
                            return valueWithoutUnit;
                        }
                        if (valueWithoutUnit.constructor === Number
                            || Number.isNaN(Number(valueWithoutUnit)) === false) {
                            return `${valueWithoutUnit}px`;
                        }
                        return valueWithoutUnit;
                    }
                    function getAttributesFromValueString(valueStringWithAttributes, hasParentheses) {
                        let valueArrayWithAttributes = null;
                        let attributeKeys = null;
                        let attributeValues = null;
                        if (hasParentheses) {
                            // split between ')' and remove ')' in the meantime
                            valueArrayWithAttributes = formatValueString(valueStringWithAttributes)
                                .split(')');
                            // remove everything inside parentheses
                            // regex is slower than native functions https://jsben.ch/8GY5K
                            attributeKeys = valueArrayWithAttributes
                                .map((attribute) => attribute
                                .substr(0, attribute.indexOf('('))
                                .trim());
                            // remove everything before and including '('
                            // ')' was removed when we split it in 'valueArrayWithAttributes'
                            attributeValues = valueArrayWithAttributes
                                .map((attribute) => attribute
                                .substr(attribute.indexOf('(') + 1));
                        }
                        else {
                            // split between and remove every ','
                            valueArrayWithAttributes = formatValueString(valueStringWithAttributes)
                                .split(',');
                            // get the substring before anything that isn't an alphabet
                            attributeKeys = valueArrayWithAttributes.map((attribute) => attribute
                                .substring(0, attribute.search(/[^a-zA-Z]/)));
                            // get the substring starting at the first character that isn't an alphabet
                            attributeValues = valueArrayWithAttributes.map((attribute) => attribute
                                .substr(attribute.search(/[^a-zA-Z]/)));
                        }
                        const attributeObject = {};
                        attributeKeys.fastEach((key, i) => {
                            if (!key) {
                                return;
                            }
                            attributeObject[key] = attributeValues[i];
                        });
                        return attributeObject;
                    }
                    function getValueStringFromAttributes(attributes, hasParentheses) {
                        let valueArray = null;
                        let valueString = null;
                        if (hasParentheses) {
                            valueArray = Object.keys(attributes).map((attributeKey) => `${attributeKey}(${attributes[attributeKey]})`);
                            valueString = valueArray.join('');
                        }
                        else {
                            valueArray = Object.keys(attributes).map((attributeKey) => `${attributeKey}${attributes[attributeKey]}`);
                            valueString = valueArray.join(',');
                        }
                        return valueString;
                    }
                },
                on(eventsStr, ...options) {
                    const events = eventsStr.split(' ');
                    let selector = null;
                    let handler = null;
                    let eventOptions = {};
                    options.fastEach((option) => {
                        switch (option.constructor) {
                            case String:
                                if (selector === null) {
                                    selector = option;
                                }
                                break;
                            case Function:
                                if (handler === null) {
                                    handler = option;
                                }
                                break;
                            case Object:
                                if (Object.keys(eventOptions).length === 0) {
                                    eventOptions = option;
                                }
                                break;
                        }
                    });
                    events.fastEach((eventStr) => {
                        this.addEventListener(eventStr, (event) => {
                            const processedEvent = event;
                            if (!event) {
                                return handler(undefined);
                            }
                            const { target } = processedEvent;
                            if (!target) {
                                return null;
                            }
                            if (selector !== null
                                && target.matches(selector) === false) {
                                return null;
                            }
                            return handler.call(target, processedEvent);
                        }, eventOptions);
                    });
                    return this;
                },
                off(eventsStr, ...options) {
                    const events = eventsStr.split(' ');
                    let selector = null;
                    let handler = null;
                    options.fastEach((option, i) => {
                        switch (option.constructor) {
                            case String:
                                if (selector !== null) {
                                    break;
                                }
                                selector = option;
                                break;
                            case Function:
                                if (i !== options.length - 1) {
                                    break;
                                }
                                handler = option;
                                break;
                        }
                    });
                    events.fastEach((eventStr) => {
                        this.removeEventListener(eventStr, (event) => {
                            const processedEvent = event;
                            if (!event) {
                                return handler(undefined);
                            }
                            const { target } = processedEvent;
                            if (!target) {
                                return null;
                            }
                            if (selector !== null
                                && target.matches(selector) === false) {
                                return null;
                            }
                            return handler.call(target, processedEvent);
                        });
                    });
                    return this;
                },
                async getJSON(url, callback) {
                    const response = await fetch(url);
                    return callback ? callback(await response.json()) : response.json();
                },
                $,
                $$,
                // workaround to keep the type
                ...{},
            };
            // ...spread doesn't work directly on dom objects apparently
            Object.assign(objectToCreateFrom, object);
            return objectToCreateFrom;
        }
    }

    class NotJQuery {
        // the object that is applied to can be just some random object
        $(objectToCreateFrom = {}) {
            const m$Factory = new $Factory();
            switch (true) {
                case this
                    && this.constructor === Object
                    && objectToCreateFrom.constructor === String:
                    return m$Factory.create(Object.values(this)
                        .find((node) => node.matches && node.matches(objectToCreateFrom)));
                case objectToCreateFrom === undefined:
                    return m$Factory.create({});
                case objectToCreateFrom === null:
                    throw new Error('Cannot create from null!');
                case objectToCreateFrom.constructor === String: {
                    const queryResult = document.querySelector(objectToCreateFrom);
                    return queryResult && m$Factory.create(queryResult);
                }
                default:
                    return m$Factory.create(objectToCreateFrom);
            }
        }
        $$(objectToCreateFrom = {}) {
            const m$Factory = new $Factory();
            switch (true) {
                case this
                    && this.constructor === Object
                    && objectToCreateFrom.constructor === String:
                    return Object.values(this)
                        .getAll((node) => node.matches && node.matches(objectToCreateFrom))
                        .map((elem) => m$Factory.create(elem));
                case objectToCreateFrom === undefined:
                    return [m$Factory.create({})];
                case objectToCreateFrom === null:
                    throw new Error('Cannot create from null!');
                case objectToCreateFrom.constructor === String:
                    return Array.from(document.querySelectorAll(objectToCreateFrom)).map((elem) => m$Factory.create(elem));
                default:
                    return [m$Factory.create(objectToCreateFrom)];
            }
        }
    }
    const { $, $$ } = new NotJQuery();

    class WindowUtility {
        static invalidateCache() {
            this.cache = {};
        }
        static refresh() {
            this.invalidateCache();
            this.cache = {
                inner: this.inner,
                viewport: this.viewport,
                client: this.client,
                isMobile: this.isMobile,
            };
            this.innerWritable.set(this.cache.inner);
            this.viewportWritable.set(this.cache.viewport);
            this.clientWritable.set(this.cache.client);
        }
        static vh(amount) {
            return (this.viewport.height / 100) * amount;
        }
        static vw(amount) {
            return (this.viewport.width / 100) * amount;
        }
        static px(amount) {
            return amount * window.devicePixelRatio;
        }
        static get client() {
            if (this.cache?.client?.height
                || this.cache?.client?.width) {
                return this.cache.client;
            }
            return {
                height: document.documentElement.clientHeight,
                width: document.documentElement.clientWidth,
            };
        }
        static get inner() {
            if (this.cache?.inner?.height
                || this.cache?.inner?.width) {
                return this.cache.inner;
            }
            return {
                height: window.innerHeight,
                width: window.innerWidth,
            };
        }
        static get viewport() {
            if (this.cache?.viewport?.height
                || this.cache?.viewport?.width) {
                return this.cache.viewport;
            }
            const viewportCalibrator = $(document.createElement('div'));
            viewportCalibrator.css({
                height: '1vh',
                width: '1vw',
                visibility: 'hidden',
            });
            document.body.appendChild(viewportCalibrator);
            const height = viewportCalibrator.offsetHeight * 100;
            const width = viewportCalibrator.offsetWidth * 100;
            document.body.removeChild(viewportCalibrator);
            return {
                height,
                width,
            };
        }
        static get isMobile() {
            if (this.cache?.isMobile) {
                return this.cache.isMobile;
            }
            const isMobile = window.matchMedia('(pointer: coarse)').matches
                || window.matchMedia('(pointer: cnone)').matches;
            this.cache.isMobile = isMobile;
            return isMobile;
        }
    }
    WindowUtility.cache = {};
    WindowUtility.innerWritable = new Store();
    WindowUtility.viewportWritable = new Store();
    WindowUtility.clientWritable = new Store();
    WindowUtility.refresh();
    $(window).on('resize', () => WindowUtility.refresh());

    class RandomUtility {
        static int() {
            return Math.floor(Math.min(Math.random()
                * (Number.MAX_SAFE_INTEGER / 2), Number.MAX_SAFE_INTEGER));
        }
    }

    var english = {
        common: {
            info: {
                YES: 'Yes',
                NO: 'No',
                OK: 'Ok',
                CONFIRM: 'Confirm',
                CONTINUE: 'Continue',
                CANCEL: 'Cancel',
                EXIT: 'Exit',
                EATEN_COOKIES: 'burp!',
                general: {
                    NAME: '',
                },
            },
            warn: {},
            errors: {
                NO_MESSAGE_PROVIDED: 'No message provided',
                INCORRECT_ARGUMENT: 'Incorrect argument(s) provided',
                INCORRECT_USAGE: 'Incorrect usage of item',
                IO: 'Something went wrong while trying to write or read a file',
                JSON_PARSE: 'Something went wrong while trying to parse JSON data',
                PUBLISH: 'Something went wrong while trying to publish to Instagram',
                NETWORK: 'Something went wrong while trying to make a network request',
                TIME: 'Time makes no sense',
                UNSUPPORTED_OPERATION: 'Unsupported operation',
                INCOMPATIBLE: 'Environment is incompatible',
            },
            ask: {},
            routes: {
                info: {
                    HOME: 'Home',
                    ABOUT: 'About',
                    CONTACT: 'Contact',
                    PORTFOLIO: 'Portfolio',
                },
                warn: {},
                error: {},
                ask: {},
            },
        },
        core: {
            common: {
                info: {},
                warn: {},
                error: {},
                ask: {},
            },
            renderottie: {
                info: {
                    FILE_PREFIX: 'The hard work of renderer #',
                },
                warn: {},
                error: {},
                ask: {},
            },
        },
        ui: {
            common: {
                info: {},
                warn: {
                    NO_CALLBACK: 'No callback prop provided',
                    GENERIC: 'This is awkward... If you see this, something very wrong has probably happened',
                },
                error: {},
                ask: {},
            },
            scenes: {
                common: {
                    info: {},
                    warn: {
                        EMPTY_SCENE: 'This is awkward... If you see this, something very wrong has probably happened',
                    },
                    error: {},
                    ask: {},
                },
            },
            components: {
                common: {
                    info: {},
                    warn: {},
                    error: {},
                    ask: {},
                },
                terminal: {
                    info: {
                        prefix: {
                            FETCH: 'FETCH',
                            LOAD: 'LOAD',
                            WARN: 'WARN',
                            ERROR: 'ERROR',
                        },
                    },
                    warn: {
                        COMMAND_NOT_RECOGNIZED: '%1 is not a valid thing.',
                    },
                    error: {
                        FAKE: 'UncaughtException, message bubbled from %1:\n\tSyntaxError: Invalid or unexpected token\n\tat wrapSafe (internal/modules/cjs/loader.js:1116:16)',
                    },
                    ask: {},
                },
            },
        },
        __boiler: {
            info: {},
            warn: {},
            error: {},
            ask: {},
        },
    };

    var strings = (() => {
        switch (globalThis?.navigator?.language?.substr(0, 2)) {
            case 'cn':
                return null;
            case 'en':
            default:
                return english;
        }
    })();

    class ClientError extends LogUtility.mixClass(Error) {
        constructor(options) {
            const message = options.message || strings.common.errors.NO_MESSAGE_PROVIDED;
            super(message);
            this.name = this.constructor.name;
            Error.captureStackTrace(this, this.constructor);
            LogUtility.error(message, this);
        }
    }

    class IncorrectUsageError extends ClientError {
        constructor(options) {
            const { message } = options;
            super({
                message: `${strings.common.errors.INCORRECT_USAGE}${message ? `: ${message}` : ''}`,
            });
        }
    }

    class CSSUtility {
        static parse(value) {
            switch (true) {
                case value == null:
                    return '0px';
                case value[0] === '-'
                    && value[1] === '-':
                    return `var(${value})`;
                case this.isNumber(value):
                    return `${value}px`;
                default:
                    return value;
            }
        }
        static unparse(value, ctx) {
            switch (true) {
                case value == null:
                    return 0;
                case this.isNumber(value):
                    return Number(value);
                case value[value.length - 1] === '%':
                    this.assertCtx(ctx);
                    return ctx.clientWidth * (Number.parseFloat(value) / 100);
                case this.isSingularValue(value, 'px'):
                    return Number.parseFloat(value);
                case this.isSingularValue(value, 'vh'):
                    return WindowUtility.viewport.height;
                case this.isSingularValue(value, 'vw'):
                    return WindowUtility.viewport.width;
                case this.isSingularValue(value, 'vmax'):
                    return Math.max(WindowUtility.viewport.height, WindowUtility.viewport.width);
                case this.isSingularValue(value, 'vmin'):
                    return Math.min(WindowUtility.viewport.height, WindowUtility.viewport.width);
                case value.indexOf('var(--') === 0:
                    return this.calc(value, document.documentElement);
                default:
                    this.assertCtx(ctx);
                    return this.calc(value, ctx);
            }
        }
        static isSingularValue(value, suffix) {
            const regex = new RegExp(`\\d*${suffix}`);
            const regexG = new RegExp(regex, 'g');
            const isSingular = value.match(regexG)?.length === 1;
            const isNumber = this.isNumber(value.replace(regex, ''));
            return isSingular && isNumber;
        }
        static calc(value, ctx) {
            // eslint-disable-next-line dot-notation
            ctx.style['x'] = value;
            // eslint-disable-next-line dot-notation
            const result = Number.parseFloat(getComputedStyle(ctx)['x']);
            // eslint-disable-next-line dot-notation
            ctx.style['x'] = null;
            if (Number.isNaN(result)) {
                throw new ClientError({
                    message: 'result === NaN',
                });
            }
            return result;
        }
        static assertCtx(ctx) {
            if (ctx != null) {
                return;
            }
            throw new IncorrectUsageError({
                message: `ctx === ${ctx}`,
            });
        }
        static isNumber(value) {
            return !Number.isNaN(Number(value));
        }
    }

    var Modes;
    (function (Modes) {
        Modes["START"] = "start";
        Modes["BISECT"] = "bisect";
        Modes["END"] = "end";
    })(Modes || (Modes = {}));

    var ResponsiveClasses;
    (function (ResponsiveClasses) {
        ResponsiveClasses["MOBILE"] = "mobile";
        ResponsiveClasses["TABLET"] = "tablet";
        ResponsiveClasses["POTATO"] = "potato";
        ResponsiveClasses["DESKTOP"] = "desktop";
    })(ResponsiveClasses || (ResponsiveClasses = {}));
    var ResponsiveBreakpoints;
    (function (ResponsiveBreakpoints) {
        ResponsiveBreakpoints[ResponsiveBreakpoints["MOBILE"] = 0] = "MOBILE";
        ResponsiveBreakpoints[ResponsiveBreakpoints["TABLET"] = 560] = "TABLET";
        ResponsiveBreakpoints[ResponsiveBreakpoints["POTATO"] = 1024] = "POTATO";
        ResponsiveBreakpoints[ResponsiveBreakpoints["DESKTOP"] = 1280] = "DESKTOP";
    })(ResponsiveBreakpoints || (ResponsiveBreakpoints = {}));
    var ResponsiveStagess;
    (function (ResponsiveStagess) {
        ResponsiveStagess[ResponsiveStagess["MOBILE"] = 0] = "MOBILE";
        ResponsiveStagess[ResponsiveStagess["TABLET"] = 1] = "TABLET";
        ResponsiveStagess[ResponsiveStagess["POTATO"] = 2] = "POTATO";
        ResponsiveStagess[ResponsiveStagess["DESKTOP"] = 3] = "DESKTOP";
    })(ResponsiveStagess || (ResponsiveStagess = {}));
    class ResponsiveUtility {
        static apply(node) {
            this.nodes.push(node);
            this.refresh(this.nodes.length - 1);
        }
        static refresh(index) {
            const nodesToRefresh = (() => {
                if (index) {
                    return [this.nodes[index]];
                }
                return this.nodes;
            })();
            nodesToRefresh.forEach((node) => {
                this.setCurrentBreakpointClass(node);
            });
        }
        static setCurrentBreakpointClass(node) {
            this.setClass(ResponsiveClasses[this.currentBreakpointKeyWritable.value], node);
        }
        static setClass(className, node) {
            node.classList.remove(...Object.values(ResponsiveClasses));
            node.classList.add(className);
        }
        static onResize() {
            let result = null;
            Object.keys(ResponsiveBreakpoints).forEach((responsiveBreakpointKey) => {
                if (window.innerWidth / devicePixelRatio > ResponsiveBreakpoints[responsiveBreakpointKey]) {
                    result = responsiveBreakpointKey;
                }
            });
            if (result === ResponsiveUtility.currentBreakpointKeyWritable.value) {
                return;
            }
            ResponsiveUtility.currentBreakpointKeyWritable.set(result);
            ResponsiveUtility.currentBreakpointWritable.set(ResponsiveBreakpoints[result]);
            ResponsiveUtility.refresh();
        }
    }
    ResponsiveUtility.nodes = [];
    ResponsiveUtility.isListenerActive = false;
    ResponsiveUtility.classes = Object.values(ResponsiveClasses).join(' ');
    ResponsiveUtility.Breakpoints = ResponsiveBreakpoints;
    ResponsiveUtility.Classes = ResponsiveClasses;
    ResponsiveUtility.Stages = ResponsiveStagess;
    ResponsiveUtility.currentBreakpointKeyWritable = new Store(null);
    ResponsiveUtility.currentBreakpointWritable = new Store(null);
    if (!ResponsiveUtility.isListenerActive) {
        ResponsiveUtility.onResize();
        window.addEventListener('resize', ResponsiveUtility.onResize);
        ResponsiveUtility.isListenerActive = true;
    }

    class ScrollUtility {
        static disable() {
            if (ScrollUtility.isDisabled) {
                return;
            }
            $(document.body).css({
                overflow: 'hidden',
                width: '100vw',
            });
            ScrollUtility.isDisabled = true;
        }
        static enable() {
            if (!ScrollUtility.isDisabled) {
                return;
            }
            $(document.body).css({
                overflow: 'unset',
                width: '100%',
            });
            ScrollUtility.isDisabled = false;
        }
    }
    ScrollUtility.isDisabled = false;
    ScrollUtility.target = document.body;

    class Shadow {
        static apply(depth, node) {
            const processedBoxShadow = this.get(depth);
            node
                .style
                .setProperty('--shadow', processedBoxShadow.active);
            node
                .style
                .setProperty('--shadow-inactive', processedBoxShadow.inactive);
        }
        static get(depth) {
            const isDrop = depth > 0;
            const boxShadowProperty = isDrop
                ? '--box-shadow-drop'
                : '--box-shadow-inner';
            const boxShadow = getComputedStyle(document.documentElement)
                .getPropertyValue(boxShadowProperty)
                .trim();
            const boxShadowParts = boxShadow.includes('rgba(')
                ? boxShadow
                    .replace(/\)\s*,/g, ')__delim__')
                    .split('__delim__')
                : boxShadow
                    .split(',');
            const blur = Math.abs(depth) * 20;
            const darkX = blur / 3;
            const darkY = darkX;
            const brightX = -darkX;
            const brightY = brightX;
            const rgba = boxShadowParts.map((boxShadowPart) => {
                const workingRgba = boxShadowPart
                    .trim()
                    .substr(boxShadowPart
                    .trim()
                    .indexOf('rgba('));
                const alpha = Number.parseFloat(workingRgba
                    .substring(workingRgba.lastIndexOf(',') + 1, workingRgba.lastIndexOf(')'))
                    .trim()) * (Math.abs(depth) / 3);
                return `${workingRgba.substr(0, workingRgba.lastIndexOf(',') + 1)} ${alpha})`;
            });
            const darkBoxShadowParts = this.getParts(darkX, darkY, blur, rgba[0]);
            const darkBoxShadowPartsInactive = this.getParts(0, 0, 0, rgba[0]);
            const brightBoxShadowParts = this.getParts(brightX, brightY, blur, rgba[1]);
            const brightBoxShadowPartsInactive = this.getParts(0, 0, 0, rgba[1]);
            const processedBoxShadow = {
                active: this.getProcessedBoxShadow(isDrop, darkBoxShadowParts, brightBoxShadowParts),
                inactive: this.getProcessedBoxShadow(isDrop, darkBoxShadowPartsInactive, brightBoxShadowPartsInactive),
            };
            return processedBoxShadow;
        }
        static getParts(x, y, blur, rgba) {
            return [
                `${x}px`,
                `${y}px`,
                `${blur}px`,
                rgba,
            ];
        }
        static getProcessedBoxShadow(isDrop, darkBoxShadowParts, brightBoxShadowParts) {
            return `${isDrop ? '' : 'inset'} ${darkBoxShadowParts.join(' ')}, ${isDrop ? '' : 'inset'} ${brightBoxShadowParts.join(' ')}`;
        }
    }

    function expoIn(t) {
        return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
    }
    function expoOut(t) {
        return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
    }
    function quintInOut(t) {
        if ((t *= 2) < 1)
            return 0.5 * t * t * t * t * t;
        return 0.5 * ((t -= 2) * t * t * t * t + 2);
    }
    function quintIn(t) {
        return t * t * t * t * t;
    }
    function quintOut(t) {
        return --t * t * t * t * t + 1;
    }

    function is_date(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    function get_interpolator(a, b) {
        if (a === b || a !== a)
            return () => a;
        const type = typeof a;
        if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
            throw new Error('Cannot interpolate values of different type');
        }
        if (Array.isArray(a)) {
            const arr = b.map((bi, i) => {
                return get_interpolator(a[i], bi);
            });
            return t => arr.map(fn => fn(t));
        }
        if (type === 'object') {
            if (!a || !b)
                throw new Error('Object cannot be null');
            if (is_date(a) && is_date(b)) {
                a = a.getTime();
                b = b.getTime();
                const delta = b - a;
                return t => new Date(a + t * delta);
            }
            const keys = Object.keys(b);
            const interpolators = {};
            keys.forEach(key => {
                interpolators[key] = get_interpolator(a[key], b[key]);
            });
            return t => {
                const result = {};
                keys.forEach(key => {
                    result[key] = interpolators[key](t);
                });
                return result;
            };
        }
        if (type === 'number') {
            const delta = b - a;
            return t => a + t * delta;
        }
        throw new Error(`Cannot interpolate ${type} values`);
    }
    function tweened(value, defaults = {}) {
        const store = writable(value);
        let task;
        let target_value = value;
        function set(new_value, opts) {
            if (value == null) {
                store.set(value = new_value);
                return Promise.resolve();
            }
            target_value = new_value;
            let previous_task = task;
            let started = false;
            let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
            if (duration === 0) {
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                store.set(value = target_value);
                return Promise.resolve();
            }
            const start = now() + delay;
            let fn;
            task = loop(now => {
                if (now < start)
                    return true;
                if (!started) {
                    fn = interpolate(value, new_value);
                    if (typeof duration === 'function')
                        duration = duration(value, new_value);
                    started = true;
                }
                if (previous_task) {
                    previous_task.abort();
                    previous_task = null;
                }
                const elapsed = now - start;
                if (elapsed > duration) {
                    store.set(value = new_value);
                    return false;
                }
                // @ts-ignore
                store.set(value = fn(easing(elapsed / duration)));
                return true;
            });
            return task.promise;
        }
        return {
            set,
            update: (fn, opts) => set(fn(target_value, value), opts),
            subscribe: store.subscribe
        };
    }

    /* src\ui\blocks\Ripple.svelte generated by Svelte v3.24.1 */
    const file = "src\\ui\\blocks\\Ripple.svelte";

    function create_fragment$1(ctx) {
    	let circle;

    	const block = {
    		c: function create() {
    			circle = svg_element("circle");
    			set_style(circle, "fill", /*fill*/ ctx[2]);
    			attr_dev(circle, "cx", /*x*/ ctx[0]);
    			attr_dev(circle, "cy", /*y*/ ctx[1]);
    			attr_dev(circle, "r", /*$rippleSize*/ ctx[3]);
    			attr_dev(circle, "opacity", /*$rippleOpacity*/ ctx[4]);
    			add_location(circle, file, 22, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, circle, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*fill*/ 4) {
    				set_style(circle, "fill", /*fill*/ ctx[2]);
    			}

    			if (dirty & /*x*/ 1) {
    				attr_dev(circle, "cx", /*x*/ ctx[0]);
    			}

    			if (dirty & /*y*/ 2) {
    				attr_dev(circle, "cy", /*y*/ ctx[1]);
    			}

    			if (dirty & /*$rippleSize*/ 8) {
    				attr_dev(circle, "r", /*$rippleSize*/ ctx[3]);
    			}

    			if (dirty & /*$rippleOpacity*/ 16) {
    				attr_dev(circle, "opacity", /*$rippleOpacity*/ ctx[4]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(circle);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $rippleSize;
    	let $rippleOpacity;
    	let { x } = $$props;
    	let { y } = $$props;
    	let { sizeIn } = $$props;
    	let { size } = $$props;
    	let { speed } = $$props;
    	let { opacityIn } = $$props;
    	let { fill } = $$props;
    	const rippleSize = tweened(sizeIn, { duration: speed });
    	validate_store(rippleSize, "rippleSize");
    	component_subscribe($$self, rippleSize, value => $$invalidate(3, $rippleSize = value));

    	const rippleOpacity = tweened(opacityIn, {
    		duration: speed + speed * 2.5,
    		easing: expoOut
    	});

    	validate_store(rippleOpacity, "rippleOpacity");
    	component_subscribe($$self, rippleOpacity, value => $$invalidate(4, $rippleOpacity = value));

    	onMount(() => {
    		rippleSize.set(size);
    		rippleOpacity.set(0);
    	});

    	const writable_props = ["x", "y", "sizeIn", "size", "speed", "opacityIn", "fill"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Ripple> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Ripple", $$slots, []);

    	$$self.$$set = $$props => {
    		if ("x" in $$props) $$invalidate(0, x = $$props.x);
    		if ("y" in $$props) $$invalidate(1, y = $$props.y);
    		if ("sizeIn" in $$props) $$invalidate(7, sizeIn = $$props.sizeIn);
    		if ("size" in $$props) $$invalidate(8, size = $$props.size);
    		if ("speed" in $$props) $$invalidate(9, speed = $$props.speed);
    		if ("opacityIn" in $$props) $$invalidate(10, opacityIn = $$props.opacityIn);
    		if ("fill" in $$props) $$invalidate(2, fill = $$props.fill);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tweened,
    		expoOut,
    		x,
    		y,
    		sizeIn,
    		size,
    		speed,
    		opacityIn,
    		fill,
    		rippleSize,
    		rippleOpacity,
    		$rippleSize,
    		$rippleOpacity
    	});

    	$$self.$inject_state = $$props => {
    		if ("x" in $$props) $$invalidate(0, x = $$props.x);
    		if ("y" in $$props) $$invalidate(1, y = $$props.y);
    		if ("sizeIn" in $$props) $$invalidate(7, sizeIn = $$props.sizeIn);
    		if ("size" in $$props) $$invalidate(8, size = $$props.size);
    		if ("speed" in $$props) $$invalidate(9, speed = $$props.speed);
    		if ("opacityIn" in $$props) $$invalidate(10, opacityIn = $$props.opacityIn);
    		if ("fill" in $$props) $$invalidate(2, fill = $$props.fill);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		x,
    		y,
    		fill,
    		$rippleSize,
    		$rippleOpacity,
    		rippleSize,
    		rippleOpacity,
    		sizeIn,
    		size,
    		speed,
    		opacityIn
    	];
    }

    class Ripple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			x: 0,
    			y: 1,
    			sizeIn: 7,
    			size: 8,
    			speed: 9,
    			opacityIn: 10,
    			fill: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ripple",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*x*/ ctx[0] === undefined && !("x" in props)) {
    			console.warn("<Ripple> was created without expected prop 'x'");
    		}

    		if (/*y*/ ctx[1] === undefined && !("y" in props)) {
    			console.warn("<Ripple> was created without expected prop 'y'");
    		}

    		if (/*sizeIn*/ ctx[7] === undefined && !("sizeIn" in props)) {
    			console.warn("<Ripple> was created without expected prop 'sizeIn'");
    		}

    		if (/*size*/ ctx[8] === undefined && !("size" in props)) {
    			console.warn("<Ripple> was created without expected prop 'size'");
    		}

    		if (/*speed*/ ctx[9] === undefined && !("speed" in props)) {
    			console.warn("<Ripple> was created without expected prop 'speed'");
    		}

    		if (/*opacityIn*/ ctx[10] === undefined && !("opacityIn" in props)) {
    			console.warn("<Ripple> was created without expected prop 'opacityIn'");
    		}

    		if (/*fill*/ ctx[2] === undefined && !("fill" in props)) {
    			console.warn("<Ripple> was created without expected prop 'fill'");
    		}
    	}

    	get x() {
    		return this.$$.ctx[0];
    	}

    	set x(x) {
    		this.$set({ x });
    		flush();
    	}

    	get y() {
    		return this.$$.ctx[1];
    	}

    	set y(y) {
    		this.$set({ y });
    		flush();
    	}

    	get sizeIn() {
    		return this.$$.ctx[7];
    	}

    	set sizeIn(sizeIn) {
    		this.$set({ sizeIn });
    		flush();
    	}

    	get size() {
    		return this.$$.ctx[8];
    	}

    	set size(size) {
    		this.$set({ size });
    		flush();
    	}

    	get speed() {
    		return this.$$.ctx[9];
    	}

    	set speed(speed) {
    		this.$set({ speed });
    		flush();
    	}

    	get opacityIn() {
    		return this.$$.ctx[10];
    	}

    	set opacityIn(opacityIn) {
    		this.$set({ opacityIn });
    		flush();
    	}

    	get fill() {
    		return this.$$.ctx[2];
    	}

    	set fill(fill) {
    		this.$set({ fill });
    		flush();
    	}
    }

    /* src\ui\blocks\Button.svelte generated by Svelte v3.24.1 */
    const file$1 = "src\\ui\\blocks\\Button.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	return child_ctx;
    }

    // (166:3) {:else}
    function create_else_block$1(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(166:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (159:3) {#if isText}
    function create_if_block$1(ctx) {
    	let icon_1;
    	let t0;
    	let t1;
    	let string;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);

    	const block = {
    		c: function create() {
    			icon_1 = element("icon");
    			t0 = text(/*icon*/ ctx[4]);
    			t1 = space();
    			string = element("string");
    			if (default_slot) default_slot.c();
    			attr_dev(icon_1, "class", "svelte-i08qyj");
    			add_location(icon_1, file$1, 159, 4, 4099);
    			attr_dev(string, "class", "svelte-i08qyj");
    			add_location(string, file$1, 162, 4, 4137);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon_1, anchor);
    			append_dev(icon_1, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, string, anchor);

    			if (default_slot) {
    				default_slot.m(string, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*icon*/ 16) set_data_dev(t0, /*icon*/ ctx[4]);

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon_1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(string);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(159:3) {#if isText}",
    		ctx
    	});

    	return block;
    }

    // (171:3) {#each $ripples as ripple}
    function create_each_block(ctx) {
    	let ripple;
    	let current;

    	ripple = new Ripple({
    			props: {
    				x: /*ripple*/ ctx[36].x,
    				y: /*ripple*/ ctx[36].y,
    				size: /*ripple*/ ctx[36].size,
    				speed,
    				sizeIn,
    				opacityIn,
    				fill: /*rippleColour*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ripple.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ripple, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const ripple_changes = {};
    			if (dirty[0] & /*$ripples*/ 16384) ripple_changes.x = /*ripple*/ ctx[36].x;
    			if (dirty[0] & /*$ripples*/ 16384) ripple_changes.y = /*ripple*/ ctx[36].y;
    			if (dirty[0] & /*$ripples*/ 16384) ripple_changes.size = /*ripple*/ ctx[36].size;
    			if (dirty[0] & /*rippleColour*/ 4) ripple_changes.fill = /*rippleColour*/ ctx[2];
    			ripple.$set(ripple_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ripple, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(171:3) {#each $ripples as ripple}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let component;
    	let button;
    	let span;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let svg;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isText*/ ctx[9]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*$ripples*/ ctx[14];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			component = element("component");
    			button = element("button");
    			span = element("span");
    			if_block.c();
    			t = space();
    			svg = svg_element("svg");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "class", "content svelte-i08qyj");
    			add_location(span, file$1, 157, 2, 4054);
    			attr_dev(svg, "class", "svelte-i08qyj");
    			add_location(svg, file$1, 169, 2, 4237);
    			set_style(button, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[0]));
    			set_style(button, "--colour-hover", CSSUtility.parse(/*hoverColour*/ ctx[1]));
    			set_style(button, "--colour-ripple", CSSUtility.parse(/*rippleColour*/ ctx[2]));
    			set_style(button, "--colour-text", CSSUtility.parse(/*textColour*/ ctx[3]));
    			set_style(button, "--button-padding", CSSUtility.parse(/*padding*/ ctx[11]));
    			set_style(button, "--icon-size", CSSUtility.parse(/*iconSize*/ ctx[5]));
    			set_style(button, "--text-align", /*textAlign*/ ctx[10]);
    			attr_dev(button, "class", "svelte-i08qyj");
    			add_location(button, file$1, 138, 1, 3196);
    			attr_dev(component, "class", "unpressed svelte-i08qyj");
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[6]));
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[8]));
    			set_style(component, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[7]));
    			add_location(component, file$1, 129, 0, 2981);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, button);
    			append_dev(button, span);
    			if_blocks[current_block_type_index].m(span, null);
    			append_dev(button, t);
    			append_dev(button, svg);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svg, null);
    			}

    			/*button_binding*/ ctx[21](button);
    			/*component_binding*/ ctx[27](component);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[22], false, false, false),
    					listen_dev(button, "focus", focus_handler, false, false, false),
    					listen_dev(button, "blur", blur_handler, false, false, false),
    					listen_dev(button, "touchstart", /*touchstart_handler*/ ctx[23], { passive: true }, false, false),
    					listen_dev(button, "mousedown", /*mousedown_handler*/ ctx[24], false, false, false),
    					listen_dev(button, "touchend", /*touchend_handler*/ ctx[25], { passive: true }, false, false),
    					listen_dev(button, "mouseup", /*mouseup_handler*/ ctx[26], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(span, null);
    			}

    			if (dirty[0] & /*$ripples, rippleColour*/ 16388) {
    				each_value = /*$ripples*/ ctx[14];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(svg, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*backgroundColour*/ 1) {
    				set_style(button, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[0]));
    			}

    			if (!current || dirty[0] & /*hoverColour*/ 2) {
    				set_style(button, "--colour-hover", CSSUtility.parse(/*hoverColour*/ ctx[1]));
    			}

    			if (!current || dirty[0] & /*rippleColour*/ 4) {
    				set_style(button, "--colour-ripple", CSSUtility.parse(/*rippleColour*/ ctx[2]));
    			}

    			if (!current || dirty[0] & /*textColour*/ 8) {
    				set_style(button, "--colour-text", CSSUtility.parse(/*textColour*/ ctx[3]));
    			}

    			if (!current || dirty[0] & /*padding*/ 2048) {
    				set_style(button, "--button-padding", CSSUtility.parse(/*padding*/ ctx[11]));
    			}

    			if (!current || dirty[0] & /*iconSize*/ 32) {
    				set_style(button, "--icon-size", CSSUtility.parse(/*iconSize*/ ctx[5]));
    			}

    			if (!current || dirty[0] & /*textAlign*/ 1024) {
    				set_style(button, "--text-align", /*textAlign*/ ctx[10]);
    			}

    			if (!current || dirty[0] & /*width*/ 64) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[6]));
    			}

    			if (!current || dirty[0] & /*height*/ 256) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[8]));
    			}

    			if (!current || dirty[0] & /*roundness*/ 128) {
    				set_style(component, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[7]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if_blocks[current_block_type_index].d();
    			destroy_each(each_blocks, detaching);
    			/*button_binding*/ ctx[21](null);
    			/*component_binding*/ ctx[27](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const speed = 1000;
    const sizeIn = 20;
    const opacityIn = 0.2;

    function onMouseUp(event) {
    	if (!event.currentTarget) {
    		return;
    	}

    	event.currentTarget.parentElement.classList.add("unpressed");
    }

    const focus_handler = event => event.currentTarget.parentElement.classList.remove("unpressed");
    const blur_handler = event => event.currentTarget.parentElement.classList.add("unpressed");

    function instance$2($$self, $$props, $$invalidate) {
    	let $ripples;
    	let { backgroundColour = "--colour-accent-primary" } = $$props;
    	let { hoverColour = "--colour-accent-secondary" } = $$props;
    	let { rippleColour = "white" } = $$props;
    	let { textColour = "--colour-text-primary" } = $$props;
    	let { icon = "done" } = $$props;
    	let { iconSize = "1rem" } = $$props;
    	let { width = "max-content" } = $$props;
    	let { roundness = "--roundness" } = $$props;
    	let { height = "max(calc(var(--border-radius) * 2), 56px)" } = $$props;
    	let { depth = 1 } = $$props;
    	let { isText = true } = $$props;
    	let { textAlign = "center" } = $$props;
    	let { padding = "16px max(var(--border-radius), 24px)" } = $$props;
    	const dispatch = createEventDispatcher();

    	const ripples = (() => {
    		const arrayWritable = writable([]);

    		return {
    			...arrayWritable,
    			add: item => arrayWritable.update(items => [...items, item]),
    			clear: () => arrayWritable.update(() => [])
    		};
    	})();

    	validate_store(ripples, "ripples");
    	component_subscribe($$self, ripples, value => $$invalidate(14, $ripples = value));
    	let componentDomContent;

    	const self = {
    		domContent: null,
    		get width() {
    			return +!!self.domContent && self.domContent.offsetWidth;
    		},
    		get height() {
    			return +!!self.domContent && self.domContent.offsetHeight;
    		},
    		get x() {
    			return +!!self.domContent && self.domContent.getBoundingClientRect().x;
    		},
    		get y() {
    			return +!!self.domContent && self.domContent.getBoundingClientRect().y;
    		}
    	};

    	onMount(() => {
    		Shadow.apply(-depth, self.domContent);
    		Shadow.apply(depth, componentDomContent);
    	});

    	const coords = { x: 50, y: 50 };
    	let __touched = false;
    	let __timer = null;

    	function onMouseDown(event, type) {
    		switch (type) {
    			case "touch":
    				{
    					__touched = true;

    					ripples.add({
    						x: event.pageX - self.x,
    						y: event.pageY - self.y,
    						size: scaleRatio
    					});

    					break;
    				}
    			case "click":
    				{
    					if (__touched) {
    						__touched = false;
    						break;
    					}

    					ripples.add({
    						x: event.clientX - self.x,
    						y: event.clientY - self.y,
    						size: scaleRatio
    					});

    					break;
    				}
    		}

    		clearTimeout(__timer);

    		__timer = setTimeout(
    			() => {
    				ripples.clear();
    			},
    			speed + speed * 2
    		);

    		if (!event.currentTarget) {
    			return;
    		}

    		event.currentTarget.parentElement.classList.remove("unpressed");
    	}

    	const writable_props = [
    		"backgroundColour",
    		"hoverColour",
    		"rippleColour",
    		"textColour",
    		"icon",
    		"iconSize",
    		"width",
    		"roundness",
    		"height",
    		"depth",
    		"isText",
    		"textAlign",
    		"padding"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Button", $$slots, ['default']);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			self.domContent = $$value;
    			$$invalidate(13, self);
    		});
    	}

    	const click_handler = () => dispatch("click");
    	const touchstart_handler = event => onMouseDown(event.touches[0], "touch");
    	const mousedown_handler = event => onMouseDown(event, "click");
    	const touchend_handler = event => onMouseUp(event);
    	const mouseup_handler = event => onMouseUp(event);

    	function component_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			componentDomContent = $$value;
    			$$invalidate(12, componentDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("backgroundColour" in $$props) $$invalidate(0, backgroundColour = $$props.backgroundColour);
    		if ("hoverColour" in $$props) $$invalidate(1, hoverColour = $$props.hoverColour);
    		if ("rippleColour" in $$props) $$invalidate(2, rippleColour = $$props.rippleColour);
    		if ("textColour" in $$props) $$invalidate(3, textColour = $$props.textColour);
    		if ("icon" in $$props) $$invalidate(4, icon = $$props.icon);
    		if ("iconSize" in $$props) $$invalidate(5, iconSize = $$props.iconSize);
    		if ("width" in $$props) $$invalidate(6, width = $$props.width);
    		if ("roundness" in $$props) $$invalidate(7, roundness = $$props.roundness);
    		if ("height" in $$props) $$invalidate(8, height = $$props.height);
    		if ("depth" in $$props) $$invalidate(18, depth = $$props.depth);
    		if ("isText" in $$props) $$invalidate(9, isText = $$props.isText);
    		if ("textAlign" in $$props) $$invalidate(10, textAlign = $$props.textAlign);
    		if ("padding" in $$props) $$invalidate(11, padding = $$props.padding);
    		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		writable,
    		Shadow,
    		Ripple,
    		CSSUtility,
    		backgroundColour,
    		hoverColour,
    		rippleColour,
    		textColour,
    		icon,
    		iconSize,
    		width,
    		roundness,
    		height,
    		depth,
    		isText,
    		textAlign,
    		padding,
    		speed,
    		sizeIn,
    		opacityIn,
    		dispatch,
    		ripples,
    		componentDomContent,
    		self,
    		coords,
    		__touched,
    		__timer,
    		onMouseDown,
    		onMouseUp,
    		offsetX,
    		offsetY,
    		deltaX,
    		deltaY,
    		scaleRatio,
    		$ripples
    	});

    	$$self.$inject_state = $$props => {
    		if ("backgroundColour" in $$props) $$invalidate(0, backgroundColour = $$props.backgroundColour);
    		if ("hoverColour" in $$props) $$invalidate(1, hoverColour = $$props.hoverColour);
    		if ("rippleColour" in $$props) $$invalidate(2, rippleColour = $$props.rippleColour);
    		if ("textColour" in $$props) $$invalidate(3, textColour = $$props.textColour);
    		if ("icon" in $$props) $$invalidate(4, icon = $$props.icon);
    		if ("iconSize" in $$props) $$invalidate(5, iconSize = $$props.iconSize);
    		if ("width" in $$props) $$invalidate(6, width = $$props.width);
    		if ("roundness" in $$props) $$invalidate(7, roundness = $$props.roundness);
    		if ("height" in $$props) $$invalidate(8, height = $$props.height);
    		if ("depth" in $$props) $$invalidate(18, depth = $$props.depth);
    		if ("isText" in $$props) $$invalidate(9, isText = $$props.isText);
    		if ("textAlign" in $$props) $$invalidate(10, textAlign = $$props.textAlign);
    		if ("padding" in $$props) $$invalidate(11, padding = $$props.padding);
    		if ("componentDomContent" in $$props) $$invalidate(12, componentDomContent = $$props.componentDomContent);
    		if ("__touched" in $$props) __touched = $$props.__touched;
    		if ("__timer" in $$props) __timer = $$props.__timer;
    		if ("offsetX" in $$props) $$invalidate(30, offsetX = $$props.offsetX);
    		if ("offsetY" in $$props) $$invalidate(31, offsetY = $$props.offsetY);
    		if ("deltaX" in $$props) $$invalidate(32, deltaX = $$props.deltaX);
    		if ("deltaY" in $$props) $$invalidate(33, deltaY = $$props.deltaY);
    		if ("scaleRatio" in $$props) scaleRatio = $$props.scaleRatio;
    	};

    	let offsetX;
    	let offsetY;
    	let deltaX;
    	let deltaY;
    	let scaleRatio;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*self*/ 8192) {
    			 $$invalidate(30, offsetX = Math.abs(self.width / 2 - coords.x));
    		}

    		if ($$self.$$.dirty[0] & /*self*/ 8192) {
    			 $$invalidate(31, offsetY = Math.abs(self.height / 2 - coords.y));
    		}

    		if ($$self.$$.dirty[0] & /*self, offsetX*/ 1073750016) {
    			 $$invalidate(32, deltaX = self.width / 2 + offsetX);
    		}

    		if ($$self.$$.dirty[0] & /*self*/ 8192 | $$self.$$.dirty[1] & /*offsetY*/ 1) {
    			 $$invalidate(33, deltaY = self.height / 2 + offsetY);
    		}

    		if ($$self.$$.dirty[1] & /*deltaX, deltaY*/ 6) {
    			 scaleRatio = Math.sqrt(deltaX ** 3 + deltaY ** 3);
    		}
    	};

    	return [
    		backgroundColour,
    		hoverColour,
    		rippleColour,
    		textColour,
    		icon,
    		iconSize,
    		width,
    		roundness,
    		height,
    		isText,
    		textAlign,
    		padding,
    		componentDomContent,
    		self,
    		$ripples,
    		dispatch,
    		ripples,
    		onMouseDown,
    		depth,
    		$$scope,
    		$$slots,
    		button_binding,
    		click_handler,
    		touchstart_handler,
    		mousedown_handler,
    		touchend_handler,
    		mouseup_handler,
    		component_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$2,
    			create_fragment$2,
    			safe_not_equal,
    			{
    				backgroundColour: 0,
    				hoverColour: 1,
    				rippleColour: 2,
    				textColour: 3,
    				icon: 4,
    				iconSize: 5,
    				width: 6,
    				roundness: 7,
    				height: 8,
    				depth: 18,
    				isText: 9,
    				textAlign: 10,
    				padding: 11
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get backgroundColour() {
    		return this.$$.ctx[0];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get hoverColour() {
    		return this.$$.ctx[1];
    	}

    	set hoverColour(hoverColour) {
    		this.$set({ hoverColour });
    		flush();
    	}

    	get rippleColour() {
    		return this.$$.ctx[2];
    	}

    	set rippleColour(rippleColour) {
    		this.$set({ rippleColour });
    		flush();
    	}

    	get textColour() {
    		return this.$$.ctx[3];
    	}

    	set textColour(textColour) {
    		this.$set({ textColour });
    		flush();
    	}

    	get icon() {
    		return this.$$.ctx[4];
    	}

    	set icon(icon) {
    		this.$set({ icon });
    		flush();
    	}

    	get iconSize() {
    		return this.$$.ctx[5];
    	}

    	set iconSize(iconSize) {
    		this.$set({ iconSize });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[6];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get roundness() {
    		return this.$$.ctx[7];
    	}

    	set roundness(roundness) {
    		this.$set({ roundness });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[8];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get depth() {
    		return this.$$.ctx[18];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get isText() {
    		return this.$$.ctx[9];
    	}

    	set isText(isText) {
    		this.$set({ isText });
    		flush();
    	}

    	get textAlign() {
    		return this.$$.ctx[10];
    	}

    	set textAlign(textAlign) {
    		this.$set({ textAlign });
    		flush();
    	}

    	get padding() {
    		return this.$$.ctx[11];
    	}

    	set padding(padding) {
    		this.$set({ padding });
    		flush();
    	}
    }

    /* src\ui\blocks\Hint.svelte generated by Svelte v3.24.1 */
    const file$2 = "src\\ui\\blocks\\Hint.svelte";

    // (78:9) Hint
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Hint");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(78:9) Hint",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let component;
    	let span;
    	let icon_1;
    	let t0;
    	let t1;
    	let string;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			component = element("component");
    			span = element("span");
    			icon_1 = element("icon");
    			t0 = text(/*$icon*/ ctx[1]);
    			t1 = space();
    			string = element("string");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(icon_1, "class", "svelte-100k2cs");
    			add_location(icon_1, file$2, 73, 2, 1236);
    			attr_dev(string, "class", "text svelte-100k2cs");
    			add_location(string, file$2, 76, 2, 1269);
    			attr_dev(span, "class", "content error warn info ok none svelte-100k2cs");
    			add_location(span, file$2, 69, 1, 1147);
    			add_location(component, file$2, 68, 0, 1133);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, span);
    			append_dev(span, icon_1);
    			append_dev(icon_1, t0);
    			append_dev(span, t1);
    			append_dev(span, string);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(string, null);
    			}

    			/*span_binding*/ ctx[7](span);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$icon*/ 2) set_data_dev(t0, /*$icon*/ ctx[1]);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*span_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $icon;
    	let { levelWritable = writable(0) } = $$props;

    	const Levels = {
    		INFO: 0,
    		WARN: 1,
    		ERROR: 2,
    		OK: 3,
    		NONE: 4
    	};

    	const LevelClasses = ["info", "warn", "error", "ok", "none"];
    	const LevelIcons = ["error_outline", "warning", "error", "done"];
    	let contentDomContent = null;
    	const icon = writable(LevelIcons[0]);
    	validate_store(icon, "icon");
    	component_subscribe($$self, icon, value => $$invalidate(1, $icon = value));

    	levelWritable.subscribe(level => {
    		if (!contentDomContent) {
    			return;
    		}

    		clearLevelClasses(contentDomContent);
    		contentDomContent.classList.add(LevelClasses[level]);

    		if (LevelIcons[level] != null) {
    			icon.set(LevelIcons[level]);
    		}
    	});

    	onMount(() => {
    		clearLevelClasses(contentDomContent);
    	});

    	function clearLevelClasses(node) {
    		const classesToBeRemoved = [];

    		node.classList.forEach(className => {
    			if (!LevelClasses.includes(className)) {
    				return;
    			}

    			classesToBeRemoved.push(className);
    		});

    		node.classList.remove(...classesToBeRemoved);
    	}

    	const writable_props = ["levelWritable"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Hint> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Hint", $$slots, ['default']);

    	function span_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			contentDomContent = $$value;
    			$$invalidate(0, contentDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("levelWritable" in $$props) $$invalidate(3, levelWritable = $$props.levelWritable);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		writable,
    		levelWritable,
    		Levels,
    		LevelClasses,
    		LevelIcons,
    		contentDomContent,
    		icon,
    		clearLevelClasses,
    		$icon
    	});

    	$$self.$inject_state = $$props => {
    		if ("levelWritable" in $$props) $$invalidate(3, levelWritable = $$props.levelWritable);
    		if ("contentDomContent" in $$props) $$invalidate(0, contentDomContent = $$props.contentDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		contentDomContent,
    		$icon,
    		icon,
    		levelWritable,
    		Levels,
    		$$scope,
    		$$slots,
    		span_binding
    	];
    }

    class Hint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { levelWritable: 3, Levels: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hint",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get levelWritable() {
    		return this.$$.ctx[3];
    	}

    	set levelWritable(levelWritable) {
    		this.$set({ levelWritable });
    		flush();
    	}

    	get Levels() {
    		return this.$$.ctx[4];
    	}

    	set Levels(value) {
    		throw new Error("<Hint>: Cannot set read-only property 'Levels'");
    	}
    }

    /* src\ui\blocks\Input.svelte generated by Svelte v3.24.1 */
    const file$3 = "src\\ui\\blocks\\Input.svelte";
    const get_button_slot_changes = dirty => ({});
    const get_button_slot_context = ctx => ({ submit: /*submit*/ ctx[2] });

    // (121:3) {:else}
    function create_else_block$2(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			set_style(button, "display", "none");
    			add_location(button, file$3, 121, 4, 3259);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*submit*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(121:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (109:3) {#if buttonComponent}
    function create_if_block_1(ctx) {
    	let container;
    	let switch_instance;
    	let current;
    	const switch_instance_spread_levels = [{ height: "100%" }, { width: "100%" }, /*buttonProps*/ ctx[5]];
    	var switch_value = /*buttonComponent*/ ctx[4];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("click", /*submit*/ ctx[2]);
    	}

    	const block = {
    		c: function create() {
    			container = element("container");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(container, "class", "button svelte-82c287");
    			add_location(container, file$3, 109, 4, 3014);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, container, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*buttonProps*/ 32)
    			? get_spread_update(switch_instance_spread_levels, [
    					switch_instance_spread_levels[0],
    					switch_instance_spread_levels[1],
    					get_spread_object(/*buttonProps*/ ctx[5])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*buttonComponent*/ ctx[4])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("click", /*submit*/ ctx[2]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, container, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(109:3) {#if buttonComponent}",
    		ctx
    	});

    	return block;
    }

    // (108:3)      
    function fallback_block$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*buttonComponent*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(108:3)      ",
    		ctx
    	});

    	return block;
    }

    // (129:1) {#if $hintWritable !== null}
    function create_if_block$2(ctx) {
    	let hint;
    	let current;

    	hint = new Hint({
    			props: {
    				levelWritable: /*hintLevelWritable*/ ctx[6],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hint.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hint, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hint_changes = {};
    			if (dirty[0] & /*hintLevelWritable*/ 64) hint_changes.levelWritable = /*hintLevelWritable*/ ctx[6];

    			if (dirty[0] & /*$hintWritable*/ 16777216 | dirty[1] & /*$$scope*/ 8) {
    				hint_changes.$$scope = { dirty, ctx };
    			}

    			hint.$set(hint_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hint.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hint.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hint, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(129:1) {#if $hintWritable !== null}",
    		ctx
    	});

    	return block;
    }

    // (130:2) <Hint levelWritable={hintLevelWritable}>
    function create_default_slot(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*$hintWritable*/ ctx[24]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$hintWritable*/ 16777216) set_data_dev(t, /*$hintWritable*/ ctx[24]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(130:2) <Hint levelWritable={hintLevelWritable}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let component;
    	let form;
    	let input;
    	let t0;
    	let label_1;
    	let string;
    	let t1;
    	let t2;
    	let form_class_value;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	const button_slot_template = /*$$slots*/ ctx[28].button;
    	const button_slot = create_slot(button_slot_template, ctx, /*$$scope*/ ctx[34], get_button_slot_context);
    	const button_slot_or_fallback = button_slot || fallback_block$1(ctx);
    	let if_block = /*$hintWritable*/ ctx[24] !== null && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			component = element("component");
    			form = element("form");
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			string = element("string");
    			t1 = text(/*label*/ ctx[3]);
    			t2 = space();
    			if (button_slot_or_fallback) button_slot_or_fallback.c();
    			t3 = space();
    			if (if_block) if_block.c();
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", /*selfId*/ ctx[25]);
    			attr_dev(input, "class", "text svelte-82c287");
    			attr_dev(input, "placeholder", /*label*/ ctx[3]);
    			set_style(input, "--colour-text", CSSUtility.parse(/*textColour*/ ctx[18]));
    			add_location(input, file$3, 80, 2, 2422);
    			attr_dev(string, "class", "svelte-82c287");
    			add_location(string, file$3, 100, 3, 2889);
    			attr_dev(label_1, "for", /*selfId*/ ctx[25]);
    			set_style(label_1, "--colour-label", CSSUtility.parse(/*labelColour*/ ctx[19]));
    			set_style(label_1, "--floating-label-indent", CSSUtility.parse(/*floatingLabelIndent*/ ctx[20]));
    			attr_dev(label_1, "class", "svelte-82c287");
    			add_location(label_1, file$3, 93, 2, 2711);
    			attr_dev(form, "class", form_class_value = "" + ((/*isActive*/ ctx[21] ? "" : "inactive") + " " + (/*value*/ ctx[0] ? "valued" : "") + " svelte-82c287"));
    			attr_dev(form, "onsubmit", "return false");
    			set_style(form, "--active-colour-background", CSSUtility.parse(/*activeBackgroundColour*/ ctx[17]));
    			set_style(form, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[16]) + "\r\n\t\t");
    			add_location(form, file$3, 71, 1, 2133);
    			set_style(component, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[8]));
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[10]));
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[9]));
    			set_style(component, "--font-size", CSSUtility.parse(/*fontSize*/ ctx[12]));
    			set_style(component, "--label-top", CSSUtility.parse(/*labelTop*/ ctx[13]));
    			set_style(component, "--min-indent", CSSUtility.parse(/*minIndent*/ ctx[14]));
    			set_style(component, "--indent", CSSUtility.parse(/*indent*/ ctx[15]));
    			set_style(component, "--button-width", CSSUtility.parse(/*buttonWidth*/ ctx[11]));
    			attr_dev(component, "class", "svelte-82c287");
    			add_location(component, file$3, 59, 0, 1739);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, form);
    			append_dev(form, input);
    			set_input_value(input, /*value*/ ctx[0]);
    			/*input_binding*/ ctx[30](input);
    			append_dev(form, t0);
    			append_dev(form, label_1);
    			append_dev(label_1, string);
    			append_dev(string, t1);
    			append_dev(form, t2);

    			if (button_slot_or_fallback) {
    				button_slot_or_fallback.m(form, null);
    			}

    			/*form_binding*/ ctx[33](form);
    			append_dev(component, t3);
    			if (if_block) if_block.m(component, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[29]),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[31], false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[32], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*label*/ 8) {
    				attr_dev(input, "placeholder", /*label*/ ctx[3]);
    			}

    			if (!current || dirty[0] & /*textColour*/ 262144) {
    				set_style(input, "--colour-text", CSSUtility.parse(/*textColour*/ ctx[18]));
    			}

    			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			if (!current || dirty[0] & /*label*/ 8) set_data_dev(t1, /*label*/ ctx[3]);

    			if (!current || dirty[0] & /*labelColour*/ 524288) {
    				set_style(label_1, "--colour-label", CSSUtility.parse(/*labelColour*/ ctx[19]));
    			}

    			if (!current || dirty[0] & /*floatingLabelIndent*/ 1048576) {
    				set_style(label_1, "--floating-label-indent", CSSUtility.parse(/*floatingLabelIndent*/ ctx[20]));
    			}

    			if (button_slot) {
    				if (button_slot.p && dirty[1] & /*$$scope*/ 8) {
    					update_slot(button_slot, button_slot_template, ctx, /*$$scope*/ ctx[34], dirty, get_button_slot_changes, get_button_slot_context);
    				}
    			} else {
    				if (button_slot_or_fallback && button_slot_or_fallback.p && dirty[0] & /*buttonComponent, buttonProps*/ 48) {
    					button_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty[0] & /*isActive, value*/ 2097153 && form_class_value !== (form_class_value = "" + ((/*isActive*/ ctx[21] ? "" : "inactive") + " " + (/*value*/ ctx[0] ? "valued" : "") + " svelte-82c287"))) {
    				attr_dev(form, "class", form_class_value);
    			}

    			if (!current || dirty[0] & /*activeBackgroundColour*/ 131072) {
    				set_style(form, "--active-colour-background", CSSUtility.parse(/*activeBackgroundColour*/ ctx[17]));
    			}

    			if (!current || dirty[0] & /*backgroundColour*/ 65536) {
    				set_style(form, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[16]) + "\r\n\t\t");
    			}

    			if (/*$hintWritable*/ ctx[24] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$hintWritable*/ 16777216) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(component, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*roundness*/ 256) {
    				set_style(component, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[8]));
    			}

    			if (!current || dirty[0] & /*width*/ 1024) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[10]));
    			}

    			if (!current || dirty[0] & /*height*/ 512) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[9]));
    			}

    			if (!current || dirty[0] & /*fontSize*/ 4096) {
    				set_style(component, "--font-size", CSSUtility.parse(/*fontSize*/ ctx[12]));
    			}

    			if (!current || dirty[0] & /*labelTop*/ 8192) {
    				set_style(component, "--label-top", CSSUtility.parse(/*labelTop*/ ctx[13]));
    			}

    			if (!current || dirty[0] & /*minIndent*/ 16384) {
    				set_style(component, "--min-indent", CSSUtility.parse(/*minIndent*/ ctx[14]));
    			}

    			if (!current || dirty[0] & /*indent*/ 32768) {
    				set_style(component, "--indent", CSSUtility.parse(/*indent*/ ctx[15]));
    			}

    			if (!current || dirty[0] & /*buttonWidth*/ 2048) {
    				set_style(component, "--button-width", CSSUtility.parse(/*buttonWidth*/ ctx[11]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button_slot_or_fallback, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button_slot_or_fallback, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			/*input_binding*/ ctx[30](null);
    			if (button_slot_or_fallback) button_slot_or_fallback.d(detaching);
    			/*form_binding*/ ctx[33](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $valueWritable,
    		$$unsubscribe_valueWritable = noop,
    		$$subscribe_valueWritable = () => ($$unsubscribe_valueWritable(), $$unsubscribe_valueWritable = subscribe(valueWritable, $$value => $$invalidate(35, $valueWritable = $$value)), valueWritable);

    	let $hintWritable,
    		$$unsubscribe_hintWritable = noop,
    		$$subscribe_hintWritable = () => ($$unsubscribe_hintWritable(), $$unsubscribe_hintWritable = subscribe(hintWritable, $$value => $$invalidate(24, $hintWritable = $$value)), hintWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_valueWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_hintWritable());
    	let { valueWritable = writable("") } = $$props;
    	validate_store(valueWritable, "valueWritable");
    	$$subscribe_valueWritable();
    	let { value = $valueWritable } = $$props;

    	function focus() {
    		inputDomContent.focus();
    	}

    	

    	function submit() {
    		dispatch("submit", valueWritable);
    	}

    	let { label = "Input" } = $$props;
    	let { buttonComponent = Button } = $$props;
    	let { buttonProps = {} } = $$props;
    	let { hintLevelWritable = writable(0) } = $$props;
    	let { hintWritable = writable(null) } = $$props;
    	validate_store(hintWritable, "hintWritable");
    	$$subscribe_hintWritable();
    	let { depth = 3 } = $$props;
    	let { roundness = "var(--roundness)" } = $$props;
    	let { height = 56 } = $$props;
    	let { width = "100%" } = $$props;
    	let { buttonWidth = height } = $$props;
    	let { fontSize = "1rem" } = $$props;
    	let { labelTop = 28 } = $$props;
    	let { minIndent = 16 } = $$props;
    	let { indent = "max(var(--min-indent), var(--roundness))" } = $$props;
    	let { backgroundColour = "--colour-background-secondary" } = $$props;
    	let { activeBackgroundColour = "--colour-background-primary" } = $$props;
    	let { textColour = "--colour-text-primary" } = $$props;
    	let { labelColour = "--colour-text-secondary" } = $$props;
    	let { floatingLabelIndent = "0" } = $$props;
    	const dispatch = createEventDispatcher();
    	const selfId = RandomUtility.int();
    	let isActive = false;
    	let formDomContent = null;
    	let inputDomContent = null;

    	// $: value = $valueWritable;
    	valueWritable.subscribe(valueFromValueWritable => {
    		$$invalidate(0, value = valueFromValueWritable);
    	});

    	onMount(() => {
    		Shadow.apply(depth, formDomContent);
    	});

    	const writable_props = [
    		"valueWritable",
    		"value",
    		"label",
    		"buttonComponent",
    		"buttonProps",
    		"hintLevelWritable",
    		"hintWritable",
    		"depth",
    		"roundness",
    		"height",
    		"width",
    		"buttonWidth",
    		"fontSize",
    		"labelTop",
    		"minIndent",
    		"indent",
    		"backgroundColour",
    		"activeBackgroundColour",
    		"textColour",
    		"labelColour",
    		"floatingLabelIndent"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Input> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Input", $$slots, ['button']);

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			inputDomContent = $$value;
    			$$invalidate(23, inputDomContent);
    		});
    	}

    	const focus_handler = () => {
    		$$invalidate(21, isActive = true);
    	};

    	const blur_handler = () => {
    		$$invalidate(21, isActive = false);
    	};

    	function form_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			formDomContent = $$value;
    			$$invalidate(22, formDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("valueWritable" in $$props) $$subscribe_valueWritable($$invalidate(1, valueWritable = $$props.valueWritable));
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("buttonComponent" in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
    		if ("buttonProps" in $$props) $$invalidate(5, buttonProps = $$props.buttonProps);
    		if ("hintLevelWritable" in $$props) $$invalidate(6, hintLevelWritable = $$props.hintLevelWritable);
    		if ("hintWritable" in $$props) $$subscribe_hintWritable($$invalidate(7, hintWritable = $$props.hintWritable));
    		if ("depth" in $$props) $$invalidate(27, depth = $$props.depth);
    		if ("roundness" in $$props) $$invalidate(8, roundness = $$props.roundness);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("width" in $$props) $$invalidate(10, width = $$props.width);
    		if ("buttonWidth" in $$props) $$invalidate(11, buttonWidth = $$props.buttonWidth);
    		if ("fontSize" in $$props) $$invalidate(12, fontSize = $$props.fontSize);
    		if ("labelTop" in $$props) $$invalidate(13, labelTop = $$props.labelTop);
    		if ("minIndent" in $$props) $$invalidate(14, minIndent = $$props.minIndent);
    		if ("indent" in $$props) $$invalidate(15, indent = $$props.indent);
    		if ("backgroundColour" in $$props) $$invalidate(16, backgroundColour = $$props.backgroundColour);
    		if ("activeBackgroundColour" in $$props) $$invalidate(17, activeBackgroundColour = $$props.activeBackgroundColour);
    		if ("textColour" in $$props) $$invalidate(18, textColour = $$props.textColour);
    		if ("labelColour" in $$props) $$invalidate(19, labelColour = $$props.labelColour);
    		if ("floatingLabelIndent" in $$props) $$invalidate(20, floatingLabelIndent = $$props.floatingLabelIndent);
    		if ("$$scope" in $$props) $$invalidate(34, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		writable,
    		RandomUtility,
    		CSSUtility,
    		Button,
    		Hint,
    		Shadow,
    		valueWritable,
    		value,
    		focus,
    		submit,
    		label,
    		buttonComponent,
    		buttonProps,
    		hintLevelWritable,
    		hintWritable,
    		depth,
    		roundness,
    		height,
    		width,
    		buttonWidth,
    		fontSize,
    		labelTop,
    		minIndent,
    		indent,
    		backgroundColour,
    		activeBackgroundColour,
    		textColour,
    		labelColour,
    		floatingLabelIndent,
    		dispatch,
    		selfId,
    		isActive,
    		formDomContent,
    		inputDomContent,
    		$valueWritable,
    		$hintWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("valueWritable" in $$props) $$subscribe_valueWritable($$invalidate(1, valueWritable = $$props.valueWritable));
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("buttonComponent" in $$props) $$invalidate(4, buttonComponent = $$props.buttonComponent);
    		if ("buttonProps" in $$props) $$invalidate(5, buttonProps = $$props.buttonProps);
    		if ("hintLevelWritable" in $$props) $$invalidate(6, hintLevelWritable = $$props.hintLevelWritable);
    		if ("hintWritable" in $$props) $$subscribe_hintWritable($$invalidate(7, hintWritable = $$props.hintWritable));
    		if ("depth" in $$props) $$invalidate(27, depth = $$props.depth);
    		if ("roundness" in $$props) $$invalidate(8, roundness = $$props.roundness);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("width" in $$props) $$invalidate(10, width = $$props.width);
    		if ("buttonWidth" in $$props) $$invalidate(11, buttonWidth = $$props.buttonWidth);
    		if ("fontSize" in $$props) $$invalidate(12, fontSize = $$props.fontSize);
    		if ("labelTop" in $$props) $$invalidate(13, labelTop = $$props.labelTop);
    		if ("minIndent" in $$props) $$invalidate(14, minIndent = $$props.minIndent);
    		if ("indent" in $$props) $$invalidate(15, indent = $$props.indent);
    		if ("backgroundColour" in $$props) $$invalidate(16, backgroundColour = $$props.backgroundColour);
    		if ("activeBackgroundColour" in $$props) $$invalidate(17, activeBackgroundColour = $$props.activeBackgroundColour);
    		if ("textColour" in $$props) $$invalidate(18, textColour = $$props.textColour);
    		if ("labelColour" in $$props) $$invalidate(19, labelColour = $$props.labelColour);
    		if ("floatingLabelIndent" in $$props) $$invalidate(20, floatingLabelIndent = $$props.floatingLabelIndent);
    		if ("isActive" in $$props) $$invalidate(21, isActive = $$props.isActive);
    		if ("formDomContent" in $$props) $$invalidate(22, formDomContent = $$props.formDomContent);
    		if ("inputDomContent" in $$props) $$invalidate(23, inputDomContent = $$props.inputDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*valueWritable, value*/ 3) {
    			 valueWritable.set(value);
    		}
    	};

    	return [
    		value,
    		valueWritable,
    		submit,
    		label,
    		buttonComponent,
    		buttonProps,
    		hintLevelWritable,
    		hintWritable,
    		roundness,
    		height,
    		width,
    		buttonWidth,
    		fontSize,
    		labelTop,
    		minIndent,
    		indent,
    		backgroundColour,
    		activeBackgroundColour,
    		textColour,
    		labelColour,
    		floatingLabelIndent,
    		isActive,
    		formDomContent,
    		inputDomContent,
    		$hintWritable,
    		selfId,
    		focus,
    		depth,
    		$$slots,
    		input_input_handler,
    		input_binding,
    		focus_handler,
    		blur_handler,
    		form_binding,
    		$$scope
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$4,
    			create_fragment$4,
    			safe_not_equal,
    			{
    				valueWritable: 1,
    				value: 0,
    				focus: 26,
    				submit: 2,
    				label: 3,
    				buttonComponent: 4,
    				buttonProps: 5,
    				hintLevelWritable: 6,
    				hintWritable: 7,
    				depth: 27,
    				roundness: 8,
    				height: 9,
    				width: 10,
    				buttonWidth: 11,
    				fontSize: 12,
    				labelTop: 13,
    				minIndent: 14,
    				indent: 15,
    				backgroundColour: 16,
    				activeBackgroundColour: 17,
    				textColour: 18,
    				labelColour: 19,
    				floatingLabelIndent: 20
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get valueWritable() {
    		return this.$$.ctx[1];
    	}

    	set valueWritable(valueWritable) {
    		this.$set({ valueWritable });
    		flush();
    	}

    	get value() {
    		return this.$$.ctx[0];
    	}

    	set value(value) {
    		this.$set({ value });
    		flush();
    	}

    	get focus() {
    		return this.$$.ctx[26];
    	}

    	set focus(value) {
    		throw new Error("<Input>: Cannot set read-only property 'focus'");
    	}

    	get submit() {
    		return this.$$.ctx[2];
    	}

    	set submit(value) {
    		throw new Error("<Input>: Cannot set read-only property 'submit'");
    	}

    	get label() {
    		return this.$$.ctx[3];
    	}

    	set label(label) {
    		this.$set({ label });
    		flush();
    	}

    	get buttonComponent() {
    		return this.$$.ctx[4];
    	}

    	set buttonComponent(buttonComponent) {
    		this.$set({ buttonComponent });
    		flush();
    	}

    	get buttonProps() {
    		return this.$$.ctx[5];
    	}

    	set buttonProps(buttonProps) {
    		this.$set({ buttonProps });
    		flush();
    	}

    	get hintLevelWritable() {
    		return this.$$.ctx[6];
    	}

    	set hintLevelWritable(hintLevelWritable) {
    		this.$set({ hintLevelWritable });
    		flush();
    	}

    	get hintWritable() {
    		return this.$$.ctx[7];
    	}

    	set hintWritable(hintWritable) {
    		this.$set({ hintWritable });
    		flush();
    	}

    	get depth() {
    		return this.$$.ctx[27];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get roundness() {
    		return this.$$.ctx[8];
    	}

    	set roundness(roundness) {
    		this.$set({ roundness });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[9];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[10];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get buttonWidth() {
    		return this.$$.ctx[11];
    	}

    	set buttonWidth(buttonWidth) {
    		this.$set({ buttonWidth });
    		flush();
    	}

    	get fontSize() {
    		return this.$$.ctx[12];
    	}

    	set fontSize(fontSize) {
    		this.$set({ fontSize });
    		flush();
    	}

    	get labelTop() {
    		return this.$$.ctx[13];
    	}

    	set labelTop(labelTop) {
    		this.$set({ labelTop });
    		flush();
    	}

    	get minIndent() {
    		return this.$$.ctx[14];
    	}

    	set minIndent(minIndent) {
    		this.$set({ minIndent });
    		flush();
    	}

    	get indent() {
    		return this.$$.ctx[15];
    	}

    	set indent(indent) {
    		this.$set({ indent });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[16];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get activeBackgroundColour() {
    		return this.$$.ctx[17];
    	}

    	set activeBackgroundColour(activeBackgroundColour) {
    		this.$set({ activeBackgroundColour });
    		flush();
    	}

    	get textColour() {
    		return this.$$.ctx[18];
    	}

    	set textColour(textColour) {
    		this.$set({ textColour });
    		flush();
    	}

    	get labelColour() {
    		return this.$$.ctx[19];
    	}

    	set labelColour(labelColour) {
    		this.$set({ labelColour });
    		flush();
    	}

    	get floatingLabelIndent() {
    		return this.$$.ctx[20];
    	}

    	set floatingLabelIndent(floatingLabelIndent) {
    		this.$set({ floatingLabelIndent });
    		flush();
    	}
    }

    class Item {
        combine(options) {
            Object.keys(options).forEach((optionKey) => { this[optionKey] = options[optionKey]; });
            return this;
        }
    }
    class Factory {
    }

    class TransitionerResultItem extends Item {
        constructor() {
            super(...arguments);
            this.delay = 0;
            this.duration = 200;
            this.easing = quintInOut;
            this.css = (() => { });
            this.tick = undefined;
        }
    }
    class TransitionerResultItemFactory extends Factory {
        static from(result) {
            return new TransitionerResultItem().combine(result);
        }
    }

    class Transitioner {
        constructor() {
            this.isInRegistered = false;
            this.isOutRegistered = false;
            this.inIndex = 0;
            this.outIndex = 0;
            this.inLength = 0;
            this.outLength = 0;
            // use arrow functions to keep 'this' bound
            // even if destructured
            this.t = () => {
                let index = this.inIndex % this.inLength;
                if (!this.isInRegistered) {
                    index = this.inLength++;
                    setTimeout(() => {
                        this.isInRegistered = true;
                    }, 0);
                }
                ++this.inIndex;
                return {
                    delay: index * 50,
                };
            };
            this.tt = () => {
                let index = this.outIndex % this.outLength;
                if (!this.isOutRegistered) {
                    index = this.outLength++;
                    setTimeout(() => {
                        this.isOutRegistered = true;
                    }, 0);
                }
                ++this.outIndex;
                return {
                    delay: index * 50,
                };
            };
        }
        static noop() {
            return TransitionerResultItemFactory.from({
                delay: 0,
                duration: 0,
                easing: (t) => t,
                css: () => '',
            });
        }
        static fade(element, { delay = 0, duration = 200, easing = quintInOut, }, tick = undefined) {
            const { opacity, } = getComputedStyle(element);
            return TransitionerResultItemFactory.from({
                delay,
                duration,
                easing,
                css: (t) => `opacity: ${t * +opacity}`,
                tick,
            });
        }
        static fadeIn(element, options) {
            isInAnimationRunning.set(true);
            return Transitioner.fade(element, {
                easing: quintOut,
                ...options,
            }, Transitioner.onInTick);
        }
        static fadeOut(element, options) {
            isOutAnimationRunning.set(true);
            return Transitioner.fade(element, {
                easing: quintIn,
                ...options,
            }, Transitioner.onOutTick);
        }
        static dropIn(element, { delay = 0, duration = 500, easing = expoOut, }) {
            const computed = getComputedStyle(element);
            const opacity = Number(computed.opacity);
            const transform = computed.transform === 'none'
                ? ''
                : computed.transform;
            isInAnimationRunning.set(true);
            return TransitionerResultItemFactory.from({
                delay,
                duration,
                easing,
                css: (t, u) => `
				transform: ${transform} translateY(${u * -20}px);
				opacity: ${opacity * Math.min(t * 2, 1)};
			`,
                tick: Transitioner.onInTick,
            });
        }
        static dropOut(element, { delay = 0, duration = 200, easing = expoIn, }) {
            const computed = getComputedStyle(element);
            const opacity = Number(computed.opacity);
            const transform = computed.transform === 'none'
                ? ''
                : computed.transform;
            isOutAnimationRunning.set(true);
            return TransitionerResultItemFactory.from({
                delay,
                duration,
                easing,
                css: (t, u) => `
				transform: ${transform} translateY(${u * -20}px);
				opacity: ${opacity * t};
			`,
                tick: Transitioner.onOutTick,
            });
        }
        static onInTick(t) {
            if (t !== 1) {
                return;
            }
            isInAnimationRunning.set(false);
        }
        static onOutTick(t) {
            if (t !== 0) {
                return;
            }
            isOutAnimationRunning.set(false);
        }
    }
    const { fade, fadeIn, fadeOut, dropIn, dropOut, noop: noop$1, } = Transitioner;

    /* src\ui\blocks\Dialog.svelte generated by Svelte v3.24.1 */
    const file$4 = "src\\ui\\blocks\\Dialog.svelte";

    // (23:0) {#if $isActiveWritable}
    function create_if_block$3(ctx) {
    	let component;
    	let overlay;
    	let overlay_transition;
    	let t;
    	let container;
    	let container_class_value;
    	let component_class_value;
    	let component_intro;
    	let component_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			component = element("component");
    			overlay = element("overlay");
    			t = space();
    			container = element("container");
    			if (default_slot) default_slot.c();
    			add_location(overlay, file$4, 30, 3, 867);
    			attr_dev(container, "class", container_class_value = "content " + (/*$isActiveWritable*/ ctx[6] ? "" : "inactive") + " svelte-cs1xw8");
    			set_style(container, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[2]));
    			add_location(container, file$4, 35, 3, 1011);
    			attr_dev(component, "class", component_class_value = "" + (null_to_empty(/*$isActiveWritable*/ ctx[6] ? "" : "inactive") + " svelte-cs1xw8"));
    			add_location(component, file$4, 23, 1, 740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, overlay);
    			/*overlay_binding*/ ctx[12](overlay);
    			append_dev(component, t);
    			append_dev(component, container);

    			if (default_slot) {
    				default_slot.m(container, null);
    			}

    			/*container_binding*/ ctx[13](container);
    			/*component_binding*/ ctx[14](component);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(overlay, "click", /*click_handler*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*$isActiveWritable*/ 64 && container_class_value !== (container_class_value = "content " + (/*$isActiveWritable*/ ctx[6] ? "" : "inactive") + " svelte-cs1xw8")) {
    				attr_dev(container, "class", container_class_value);
    			}

    			if (!current || dirty & /*roundness*/ 4) {
    				set_style(container, "--border-radius", CSSUtility.parse(/*roundness*/ ctx[2]));
    			}

    			if (!current || dirty & /*$isActiveWritable*/ 64 && component_class_value !== (component_class_value = "" + (null_to_empty(/*$isActiveWritable*/ ctx[6] ? "" : "inactive") + " svelte-cs1xw8"))) {
    				attr_dev(component, "class", component_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!overlay_transition) overlay_transition = create_bidirectional_transition(overlay, fade, {}, true);
    				overlay_transition.run(1);
    			});

    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (component_outro) component_outro.end(1);
    				if (!component_intro) component_intro = create_in_transition(component, dropIn, {});
    				component_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!overlay_transition) overlay_transition = create_bidirectional_transition(overlay, fade, {}, false);
    			overlay_transition.run(0);
    			transition_out(default_slot, local);
    			if (component_intro) component_intro.invalidate();
    			component_outro = create_out_transition(component, dropOut, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			/*overlay_binding*/ ctx[12](null);
    			if (detaching && overlay_transition) overlay_transition.end();
    			if (default_slot) default_slot.d(detaching);
    			/*container_binding*/ ctx[13](null);
    			/*component_binding*/ ctx[14](null);
    			if (detaching && component_outro) component_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(23:0) {#if $isActiveWritable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$isActiveWritable*/ ctx[6] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$isActiveWritable*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isActiveWritable*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $isActiveWritable,
    		$$unsubscribe_isActiveWritable = noop,
    		$$subscribe_isActiveWritable = () => ($$unsubscribe_isActiveWritable(), $$unsubscribe_isActiveWritable = subscribe(isActiveWritable, $$value => $$invalidate(6, $isActiveWritable = $$value)), isActiveWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveWritable());
    	let { depth = 3 } = $$props;
    	let { dismissOnClick = true } = $$props;
    	let { isActiveWritable = writable(true) } = $$props;
    	validate_store(isActiveWritable, "isActiveWritable");
    	$$subscribe_isActiveWritable();
    	let { roundness = "--roundness" } = $$props;

    	function dismiss() {
    		isActiveWritable.set(false);
    	}

    	
    	let contentDomContent = null;
    	let allDomContent = null;
    	let overlayDomContent = null;
    	const writable_props = ["depth", "dismissOnClick", "isActiveWritable", "roundness"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dialog> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Dialog", $$slots, ['default']);
    	const click_handler = () => dismissOnClick && isActiveWritable.set(false);

    	function overlay_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			overlayDomContent = $$value;
    			$$invalidate(5, overlayDomContent);
    		});
    	}

    	function container_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			contentDomContent = $$value;
    			$$invalidate(3, contentDomContent);
    		});
    	}

    	function component_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			allDomContent = $$value;
    			$$invalidate(4, allDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("depth" in $$props) $$invalidate(7, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(0, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(1, isActiveWritable = $$props.isActiveWritable));
    		if ("roundness" in $$props) $$invalidate(2, roundness = $$props.roundness);
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Shadow,
    		CSSUtility,
    		fade,
    		dropIn,
    		dropOut,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		roundness,
    		dismiss,
    		contentDomContent,
    		allDomContent,
    		overlayDomContent,
    		$isActiveWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("depth" in $$props) $$invalidate(7, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(0, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(1, isActiveWritable = $$props.isActiveWritable));
    		if ("roundness" in $$props) $$invalidate(2, roundness = $$props.roundness);
    		if ("contentDomContent" in $$props) $$invalidate(3, contentDomContent = $$props.contentDomContent);
    		if ("allDomContent" in $$props) $$invalidate(4, allDomContent = $$props.allDomContent);
    		if ("overlayDomContent" in $$props) $$invalidate(5, overlayDomContent = $$props.overlayDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*contentDomContent, depth*/ 136) {
    			 contentDomContent && Shadow.apply(depth, contentDomContent);
    		}

    		if ($$self.$$.dirty & /*allDomContent, overlayDomContent*/ 48) {
    			 allDomContent && allDomContent.addEventListener("dismiss", () => overlayDomContent.click());
    		}
    	};

    	return [
    		dismissOnClick,
    		isActiveWritable,
    		roundness,
    		contentDomContent,
    		allDomContent,
    		overlayDomContent,
    		$isActiveWritable,
    		depth,
    		dismiss,
    		$$scope,
    		$$slots,
    		click_handler,
    		overlay_binding,
    		container_binding,
    		component_binding
    	];
    }

    class Dialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			depth: 7,
    			dismissOnClick: 0,
    			isActiveWritable: 1,
    			roundness: 2,
    			dismiss: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialog",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get depth() {
    		return this.$$.ctx[7];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get dismissOnClick() {
    		return this.$$.ctx[0];
    	}

    	set dismissOnClick(dismissOnClick) {
    		this.$set({ dismissOnClick });
    		flush();
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[1];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}

    	get roundness() {
    		return this.$$.ctx[2];
    	}

    	set roundness(roundness) {
    		this.$set({ roundness });
    		flush();
    	}

    	get dismiss() {
    		return this.$$.ctx[8];
    	}

    	set dismiss(value) {
    		throw new Error("<Dialog>: Cannot set read-only property 'dismiss'");
    	}
    }

    /* src\ui\blocks\buttons\SvgButton.svelte generated by Svelte v3.24.1 */
    const file$5 = "src\\ui\\blocks\\buttons\\SvgButton.svelte";

    // (39:1) <Button    {...$$restProps}    {height}    {width}    {backgroundColour}    {hoverColour}    isText={false}    padding='16px 16px'    roundness='50px'    on:click={() => dispatch('click')}   >
    function create_default_slot$1(ctx) {
    	let container;
    	let placeholder;

    	const block = {
    		c: function create() {
    			container = element("container");
    			placeholder = element("placeholder");
    			add_location(placeholder, file$5, 54, 3, 1077);
    			set_style(container, "--svg-colour", /*svgColour*/ ctx[4]);
    			attr_dev(container, "class", "svelte-3cz9mv");
    			add_location(container, file$5, 49, 2, 1007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			append_dev(container, placeholder);
    			/*placeholder_binding*/ ctx[10](placeholder);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*svgColour*/ 16) {
    				set_style(container, "--svg-colour", /*svgColour*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			/*placeholder_binding*/ ctx[10](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(39:1) <Button    {...$$restProps}    {height}    {width}    {backgroundColour}    {hoverColour}    isText={false}    padding='16px 16px'    roundness='50px'    on:click={() => dispatch('click')}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let component;
    	let button;
    	let current;

    	const button_spread_levels = [
    		/*$$restProps*/ ctx[7],
    		{ height: /*height*/ ctx[2] },
    		{ width: /*width*/ ctx[3] },
    		{
    			backgroundColour: /*backgroundColour*/ ctx[1]
    		},
    		{ hoverColour: /*hoverColour*/ ctx[0] },
    		{ isText: false },
    		{ padding: "16px 16px" },
    		{ roundness: "50px" }
    	];

    	let button_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler*/ ctx[11]);

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(button.$$.fragment);
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[2]));
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[3]));
    			add_location(component, file$5, 32, 0, 701);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(button, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = (dirty & /*$$restProps, height, width, backgroundColour, hoverColour*/ 143)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7]),
    					dirty & /*height*/ 4 && { height: /*height*/ ctx[2] },
    					dirty & /*width*/ 8 && { width: /*width*/ ctx[3] },
    					dirty & /*backgroundColour*/ 2 && {
    						backgroundColour: /*backgroundColour*/ ctx[1]
    					},
    					dirty & /*hoverColour*/ 1 && { hoverColour: /*hoverColour*/ ctx[0] },
    					button_spread_levels[5],
    					button_spread_levels[6],
    					button_spread_levels[7]
    				])
    			: {};

    			if (dirty & /*$$scope, svgColour, svgPlaceholderDomContent*/ 4144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (!current || dirty & /*height*/ 4) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[2]));
    			}

    			if (!current || dirty & /*width*/ 8) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[3]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	const omit_props_names = ["hoverColour","backgroundColour","height","width","svgSrc","svg","svgColour"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { hoverColour = "#0000" } = $$props;
    	let { backgroundColour = "#0000" } = $$props;
    	let { height = "100%" } = $$props;
    	let { width = "100%" } = $$props;
    	let { svgSrc = "" } = $$props;
    	let { svg = "" } = $$props;
    	let { svgColour = backgroundColour } = $$props;
    	const dispatch = createEventDispatcher();
    	let svgPlaceholderDomContent = null;

    	onMount(async () => {
    		const svgText = svg || svgSrc && await (await fetch(svgSrc)).text() || "";
    		$$invalidate(5, svgPlaceholderDomContent.outerHTML = svgText, svgPlaceholderDomContent);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SvgButton", $$slots, []);

    	function placeholder_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			svgPlaceholderDomContent = $$value;
    			$$invalidate(5, svgPlaceholderDomContent);
    		});
    	}

    	const click_handler = () => dispatch("click");

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("hoverColour" in $$new_props) $$invalidate(0, hoverColour = $$new_props.hoverColour);
    		if ("backgroundColour" in $$new_props) $$invalidate(1, backgroundColour = $$new_props.backgroundColour);
    		if ("height" in $$new_props) $$invalidate(2, height = $$new_props.height);
    		if ("width" in $$new_props) $$invalidate(3, width = $$new_props.width);
    		if ("svgSrc" in $$new_props) $$invalidate(8, svgSrc = $$new_props.svgSrc);
    		if ("svg" in $$new_props) $$invalidate(9, svg = $$new_props.svg);
    		if ("svgColour" in $$new_props) $$invalidate(4, svgColour = $$new_props.svgColour);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		Button,
    		CSSUtility,
    		hoverColour,
    		backgroundColour,
    		height,
    		width,
    		svgSrc,
    		svg,
    		svgColour,
    		dispatch,
    		svgPlaceholderDomContent
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("hoverColour" in $$props) $$invalidate(0, hoverColour = $$new_props.hoverColour);
    		if ("backgroundColour" in $$props) $$invalidate(1, backgroundColour = $$new_props.backgroundColour);
    		if ("height" in $$props) $$invalidate(2, height = $$new_props.height);
    		if ("width" in $$props) $$invalidate(3, width = $$new_props.width);
    		if ("svgSrc" in $$props) $$invalidate(8, svgSrc = $$new_props.svgSrc);
    		if ("svg" in $$props) $$invalidate(9, svg = $$new_props.svg);
    		if ("svgColour" in $$props) $$invalidate(4, svgColour = $$new_props.svgColour);
    		if ("svgPlaceholderDomContent" in $$props) $$invalidate(5, svgPlaceholderDomContent = $$new_props.svgPlaceholderDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		hoverColour,
    		backgroundColour,
    		height,
    		width,
    		svgColour,
    		svgPlaceholderDomContent,
    		dispatch,
    		$$restProps,
    		svgSrc,
    		svg,
    		placeholder_binding,
    		click_handler
    	];
    }

    class SvgButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			hoverColour: 0,
    			backgroundColour: 1,
    			height: 2,
    			width: 3,
    			svgSrc: 8,
    			svg: 9,
    			svgColour: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SvgButton",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get hoverColour() {
    		return this.$$.ctx[0];
    	}

    	set hoverColour(hoverColour) {
    		this.$set({ hoverColour });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[1];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[2];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[3];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get svgSrc() {
    		return this.$$.ctx[8];
    	}

    	set svgSrc(svgSrc) {
    		this.$set({ svgSrc });
    		flush();
    	}

    	get svg() {
    		return this.$$.ctx[9];
    	}

    	set svg(svg) {
    		this.$set({ svg });
    		flush();
    	}

    	get svgColour() {
    		return this.$$.ctx[4];
    	}

    	set svgColour(svgColour) {
    		this.$set({ svgColour });
    		flush();
    	}
    }

    /* src\ui\blocks\Logo.svelte generated by Svelte v3.24.1 */
    const file$6 = "src\\ui\\blocks\\Logo.svelte";

    function create_fragment$7(ctx) {
    	let component;
    	let svgbutton;
    	let current;

    	svgbutton = new SvgButton({
    			props: {
    				svg: "\r\n\t\t<svg height=24px width=24px xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 749\" fill=" + CSSUtility.parse(/*colour*/ ctx[0]) + ">\r\n\t\t\t<g id=\"Layer_2\" data-name=\"Layer 2\">\r\n\t\t\t\t<rect x=\"750\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_3\" data-name=\"Layer 3\">\r\n\t\t\t\t<rect x=\"500\" y=\"250\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_4\" data-name=\"Layer 4\">\r\n\t\t\t\t<rect y=\"499\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_5\" data-name=\"Layer 5\">\r\n\t\t\t\t<rect x=\"250\" width=\"250\" height=\"500\"/>\r\n\t\t\t</g>\r\n\t\t</svg>\r\n\t\t"
    			},
    			$$inline: true
    		});

    	svgbutton.$on("click", /*click_handler*/ ctx[1]);

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(svgbutton.$$.fragment);
    			attr_dev(component, "class", "svelte-cs6f8h");
    			add_location(component, file$6, 8, 0, 233);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(svgbutton, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const svgbutton_changes = {};
    			if (dirty & /*colour*/ 1) svgbutton_changes.svg = "\r\n\t\t<svg height=24px width=24px xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 749\" fill=" + CSSUtility.parse(/*colour*/ ctx[0]) + ">\r\n\t\t\t<g id=\"Layer_2\" data-name=\"Layer 2\">\r\n\t\t\t\t<rect x=\"750\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_3\" data-name=\"Layer 3\">\r\n\t\t\t\t<rect x=\"500\" y=\"250\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_4\" data-name=\"Layer 4\">\r\n\t\t\t\t<rect y=\"499\" width=\"250\" height=\"250\"/>\r\n\t\t\t</g>\r\n\t\t\t<g id=\"Layer_5\" data-name=\"Layer 5\">\r\n\t\t\t\t<rect x=\"250\" width=\"250\" height=\"500\"/>\r\n\t\t\t</g>\r\n\t\t</svg>\r\n\t\t";

    			if (dirty & /*$$scope*/ 4) {
    				svgbutton_changes.$$scope = { dirty, ctx };
    			}

    			svgbutton.$set(svgbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(svgbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(svgbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_component(svgbutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { colour = "--colour-accent-primary" } = $$props;
    	const writable_props = ["colour"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Logo> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Logo", $$slots, []);

    	const click_handler = () => {
    		if (window.location.href.includes("#")) {
    			push("/");
    		}

    		window.scrollTo({ top: 0, left: 0, behavior: "smooth" });
    	};

    	$$self.$$set = $$props => {
    		if ("colour" in $$props) $$invalidate(0, colour = $$props.colour);
    	};

    	$$self.$capture_state = () => ({ router, SvgButton, CSSUtility, colour });

    	$$self.$inject_state = $$props => {
    		if ("colour" in $$props) $$invalidate(0, colour = $$props.colour);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [colour, click_handler];
    }

    class Logo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { colour: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logo",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get colour() {
    		return this.$$.ctx[0];
    	}

    	set colour(colour) {
    		this.$set({ colour });
    		flush();
    	}
    }

    /* src\ui\blocks\Spacer.svelte generated by Svelte v3.24.1 */
    const file$7 = "src\\ui\\blocks\\Spacer.svelte";

    function create_fragment$8(ctx) {
    	let component;

    	const block = {
    		c: function create() {
    			component = element("component");
    			set_style(component, "--height", "calc(" + CSSUtility.parse(+(/*direction*/ ctx[3] === /*Directions*/ ctx[0].HORIZONTAL) && /*$heightWritable*/ ctx[4]) + " - 1px)");
    			set_style(component, "--width", "calc(" + CSSUtility.parse(+(/*direction*/ ctx[3] === /*Directions*/ ctx[0].VERTICAL) && /*$widthWritable*/ ctx[5]) + " - 1px)");
    			attr_dev(component, "class", "svelte-814ctu");
    			add_location(component, file$7, 17, 0, 392);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*direction, $heightWritable*/ 24) {
    				set_style(component, "--height", "calc(" + CSSUtility.parse(+(/*direction*/ ctx[3] === /*Directions*/ ctx[0].HORIZONTAL) && /*$heightWritable*/ ctx[4]) + " - 1px)");
    			}

    			if (dirty & /*direction, $widthWritable*/ 40) {
    				set_style(component, "--width", "calc(" + CSSUtility.parse(+(/*direction*/ ctx[3] === /*Directions*/ ctx[0].VERTICAL) && /*$widthWritable*/ ctx[5]) + " - 1px)");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $heightWritable,
    		$$unsubscribe_heightWritable = noop,
    		$$subscribe_heightWritable = () => ($$unsubscribe_heightWritable(), $$unsubscribe_heightWritable = subscribe(heightWritable, $$value => $$invalidate(4, $heightWritable = $$value)), heightWritable);

    	let $widthWritable,
    		$$unsubscribe_widthWritable = noop,
    		$$subscribe_widthWritable = () => ($$unsubscribe_widthWritable(), $$unsubscribe_widthWritable = subscribe(widthWritable, $$value => $$invalidate(5, $widthWritable = $$value)), widthWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_heightWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_widthWritable());
    	const Directions = { HORIZONTAL: 0, VERTICAL: 1 };
    	let { height = 24 } = $$props;
    	let { width = 24 } = $$props;
    	let { heightWritable = writable(height) } = $$props;
    	validate_store(heightWritable, "heightWritable");
    	$$subscribe_heightWritable();
    	let { widthWritable = writable(width) } = $$props;
    	validate_store(widthWritable, "widthWritable");
    	$$subscribe_widthWritable();
    	let { direction = Directions.HORIZONTAL } = $$props;
    	const writable_props = ["height", "width", "heightWritable", "widthWritable", "direction"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spacer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Spacer", $$slots, []);

    	$$self.$$set = $$props => {
    		if ("height" in $$props) $$invalidate(6, height = $$props.height);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("heightWritable" in $$props) $$subscribe_heightWritable($$invalidate(1, heightWritable = $$props.heightWritable));
    		if ("widthWritable" in $$props) $$subscribe_widthWritable($$invalidate(2, widthWritable = $$props.widthWritable));
    		if ("direction" in $$props) $$invalidate(3, direction = $$props.direction);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		CSSUtility,
    		Directions,
    		height,
    		width,
    		heightWritable,
    		widthWritable,
    		direction,
    		$heightWritable,
    		$widthWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(6, height = $$props.height);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("heightWritable" in $$props) $$subscribe_heightWritable($$invalidate(1, heightWritable = $$props.heightWritable));
    		if ("widthWritable" in $$props) $$subscribe_widthWritable($$invalidate(2, widthWritable = $$props.widthWritable));
    		if ("direction" in $$props) $$invalidate(3, direction = $$props.direction);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		Directions,
    		heightWritable,
    		widthWritable,
    		direction,
    		$heightWritable,
    		$widthWritable,
    		height,
    		width
    	];
    }

    class Spacer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			Directions: 0,
    			height: 6,
    			width: 7,
    			heightWritable: 1,
    			widthWritable: 2,
    			direction: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spacer",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get Directions() {
    		return this.$$.ctx[0];
    	}

    	set Directions(value) {
    		throw new Error("<Spacer>: Cannot set read-only property 'Directions'");
    	}

    	get height() {
    		return this.$$.ctx[6];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[7];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get heightWritable() {
    		return this.$$.ctx[1];
    	}

    	set heightWritable(heightWritable) {
    		this.$set({ heightWritable });
    		flush();
    	}

    	get widthWritable() {
    		return this.$$.ctx[2];
    	}

    	set widthWritable(widthWritable) {
    		this.$set({ widthWritable });
    		flush();
    	}

    	get direction() {
    		return this.$$.ctx[3];
    	}

    	set direction(direction) {
    		this.$set({ direction });
    		flush();
    	}
    }

    /* src\ui\blocks\AppBar.svelte generated by Svelte v3.24.1 */

    const file$8 = "src\\ui\\blocks\\AppBar.svelte";

    // (78:3) {:else}
    function create_else_block$3(ctx) {
    	let heading;
    	let t;

    	const block = {
    		c: function create() {
    			heading = element("heading");
    			t = text(/*title*/ ctx[2]);
    			attr_dev(heading, "class", "svelte-1ts8alz");
    			add_location(heading, file$8, 78, 4, 1959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, heading, anchor);
    			append_dev(heading, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(heading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(78:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (74:3) {#if !title}
    function create_if_block$4(ctx) {
    	let container;
    	let logo;
    	let current;
    	logo = new Logo({ $$inline: true });

    	const block = {
    		c: function create() {
    			container = element("container");
    			create_component(logo.$$.fragment);
    			attr_dev(container, "class", "logo svelte-1ts8alz");
    			add_location(container, file$8, 74, 4, 1884);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			mount_component(logo, container, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			destroy_component(logo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(74:3) {#if !title}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let component;
    	let container2;
    	let container0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let container1;
    	let container2_intro;
    	let container2_outro;
    	let t1;
    	let spacer;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*title*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const default_slot_template = /*$$slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	spacer = new Spacer({
    			props: {
    				heightWritable: /*baseHeightWritable*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			component = element("component");
    			container2 = element("container");
    			container0 = element("container");
    			if_block.c();
    			t0 = space();
    			container1 = element("container");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(spacer.$$.fragment);
    			attr_dev(container0, "class", "content left svelte-1ts8alz");
    			add_location(container0, file$8, 70, 2, 1821);
    			attr_dev(container1, "class", "content right svelte-1ts8alz");
    			add_location(container1, file$8, 82, 2, 2017);
    			attr_dev(container2, "class", "app-bar svelte-1ts8alz");
    			set_style(container2, "--app-bar-padding", CSSUtility.parse(/*$appBarPaddingWritable*/ ctx[6]));
    			set_style(container2, "--content-padding", CSSUtility.parse(/*$contentPaddingWritable*/ ctx[7]));
    			add_location(container2, file$8, 60, 1, 1564);
    			add_location(component, file$8, 59, 0, 1550);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, container2);
    			append_dev(container2, container0);
    			if_blocks[current_block_type_index].m(container0, null);
    			append_dev(container2, t0);
    			append_dev(container2, container1);

    			if (default_slot) {
    				default_slot.m(container1, null);
    			}

    			/*container2_binding*/ ctx[16](container2);
    			append_dev(component, t1);
    			mount_component(spacer, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(container0, null);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16384) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*$appBarPaddingWritable*/ 64) {
    				set_style(container2, "--app-bar-padding", CSSUtility.parse(/*$appBarPaddingWritable*/ ctx[6]));
    			}

    			if (!current || dirty & /*$contentPaddingWritable*/ 128) {
    				set_style(container2, "--content-padding", CSSUtility.parse(/*$contentPaddingWritable*/ ctx[7]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (container2_outro) container2_outro.end(1);
    				if (!container2_intro) container2_intro = create_in_transition(container2, /*dropIn*/ ctx[8], {});
    				container2_intro.start();
    			});

    			transition_in(spacer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			if (container2_intro) container2_intro.invalidate();
    			container2_outro = create_out_transition(container2, /*dropOut*/ ctx[9], {});
    			transition_out(spacer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if_blocks[current_block_type_index].d();
    			if (default_slot) default_slot.d(detaching);
    			/*container2_binding*/ ctx[16](null);
    			if (detaching && container2_outro) container2_outro.end();
    			destroy_component(spacer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $computedPaddingWritable,
    		$$unsubscribe_computedPaddingWritable = noop,
    		$$subscribe_computedPaddingWritable = () => ($$unsubscribe_computedPaddingWritable(), $$unsubscribe_computedPaddingWritable = subscribe(computedPaddingWritable, $$value => $$invalidate(18, $computedPaddingWritable = $$value)), computedPaddingWritable);

    	let $appBarPaddingWritable,
    		$$unsubscribe_appBarPaddingWritable = noop,
    		$$subscribe_appBarPaddingWritable = () => ($$unsubscribe_appBarPaddingWritable(), $$unsubscribe_appBarPaddingWritable = subscribe(appBarPaddingWritable, $$value => $$invalidate(6, $appBarPaddingWritable = $$value)), appBarPaddingWritable);

    	let $contentPaddingWritable,
    		$$unsubscribe_contentPaddingWritable = noop,
    		$$subscribe_contentPaddingWritable = () => ($$unsubscribe_contentPaddingWritable(), $$unsubscribe_contentPaddingWritable = subscribe(contentPaddingWritable, $$value => $$invalidate(7, $contentPaddingWritable = $$value)), contentPaddingWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_computedPaddingWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_appBarPaddingWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_contentPaddingWritable());
    	const baseHeightWritable = writable(0);
    	let { computedPaddingWritable = writable(0) } = $$props;
    	validate_store(computedPaddingWritable, "computedPaddingWritable");
    	$$subscribe_computedPaddingWritable();
    	let { title = null } = $$props;
    	let { appBarPadding = "--padding" } = $$props;
    	let { appBarPaddingWritable = writable(appBarPadding) } = $$props;
    	validate_store(appBarPaddingWritable, "appBarPaddingWritable");
    	$$subscribe_appBarPaddingWritable();
    	let { contentPadding = 0 } = $$props;
    	let { contentPaddingWritable = writable(contentPadding) } = $$props;
    	validate_store(contentPaddingWritable, "contentPaddingWritable");
    	$$subscribe_contentPaddingWritable();
    	let { isInAnimated = false } = $$props;
    	let { isOutAnimated = false } = $$props;
    	const dropIn$1 = isInAnimated ? dropIn : noop$1;
    	const dropOut$1 = isOutAnimated ? dropOut : noop$1;
    	let appBarContainerDomContent = null;
    	let appBarContainerDomContentComputedStyle = {};

    	onMount(() => {
    		onResize();
    		window.addEventListener("resize", onResize);
    	});

    	onDestroy(() => {
    		window.removeEventListener("resize", onResize);
    	});

    	function onResize() {
    		appBarContainerDomContentComputedStyle = getComputedStyle(appBarContainerDomContent);
    		computedPaddingWritable.set(Number.parseFloat(appBarContainerDomContentComputedStyle.paddingLeft));
    		baseHeightWritable.set(Number.parseFloat(appBarContainerDomContentComputedStyle.height) + $computedPaddingWritable * 2);
    	}

    	const writable_props = [
    		"computedPaddingWritable",
    		"title",
    		"appBarPadding",
    		"appBarPaddingWritable",
    		"contentPadding",
    		"contentPaddingWritable",
    		"isInAnimated",
    		"isOutAnimated"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AppBar> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AppBar", $$slots, ['default']);

    	function container2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			appBarContainerDomContent = $$value;
    			$$invalidate(5, appBarContainerDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("computedPaddingWritable" in $$props) $$subscribe_computedPaddingWritable($$invalidate(1, computedPaddingWritable = $$props.computedPaddingWritable));
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("appBarPadding" in $$props) $$invalidate(10, appBarPadding = $$props.appBarPadding);
    		if ("appBarPaddingWritable" in $$props) $$subscribe_appBarPaddingWritable($$invalidate(3, appBarPaddingWritable = $$props.appBarPaddingWritable));
    		if ("contentPadding" in $$props) $$invalidate(11, contentPadding = $$props.contentPadding);
    		if ("contentPaddingWritable" in $$props) $$subscribe_contentPaddingWritable($$invalidate(4, contentPaddingWritable = $$props.contentPaddingWritable));
    		if ("isInAnimated" in $$props) $$invalidate(12, isInAnimated = $$props.isInAnimated);
    		if ("isOutAnimated" in $$props) $$invalidate(13, isOutAnimated = $$props.isOutAnimated);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		writable,
    		Logo,
    		CSSUtility,
    		Spacer,
    		dropInRaw: dropIn,
    		dropOutRaw: dropOut,
    		noop: noop$1,
    		baseHeightWritable,
    		computedPaddingWritable,
    		title,
    		appBarPadding,
    		appBarPaddingWritable,
    		contentPadding,
    		contentPaddingWritable,
    		isInAnimated,
    		isOutAnimated,
    		dropIn: dropIn$1,
    		dropOut: dropOut$1,
    		appBarContainerDomContent,
    		appBarContainerDomContentComputedStyle,
    		onResize,
    		$computedPaddingWritable,
    		$appBarPaddingWritable,
    		$contentPaddingWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("computedPaddingWritable" in $$props) $$subscribe_computedPaddingWritable($$invalidate(1, computedPaddingWritable = $$props.computedPaddingWritable));
    		if ("title" in $$props) $$invalidate(2, title = $$props.title);
    		if ("appBarPadding" in $$props) $$invalidate(10, appBarPadding = $$props.appBarPadding);
    		if ("appBarPaddingWritable" in $$props) $$subscribe_appBarPaddingWritable($$invalidate(3, appBarPaddingWritable = $$props.appBarPaddingWritable));
    		if ("contentPadding" in $$props) $$invalidate(11, contentPadding = $$props.contentPadding);
    		if ("contentPaddingWritable" in $$props) $$subscribe_contentPaddingWritable($$invalidate(4, contentPaddingWritable = $$props.contentPaddingWritable));
    		if ("isInAnimated" in $$props) $$invalidate(12, isInAnimated = $$props.isInAnimated);
    		if ("isOutAnimated" in $$props) $$invalidate(13, isOutAnimated = $$props.isOutAnimated);
    		if ("appBarContainerDomContent" in $$props) $$invalidate(5, appBarContainerDomContent = $$props.appBarContainerDomContent);
    		if ("appBarContainerDomContentComputedStyle" in $$props) appBarContainerDomContentComputedStyle = $$props.appBarContainerDomContentComputedStyle;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		baseHeightWritable,
    		computedPaddingWritable,
    		title,
    		appBarPaddingWritable,
    		contentPaddingWritable,
    		appBarContainerDomContent,
    		$appBarPaddingWritable,
    		$contentPaddingWritable,
    		dropIn$1,
    		dropOut$1,
    		appBarPadding,
    		contentPadding,
    		isInAnimated,
    		isOutAnimated,
    		$$scope,
    		$$slots,
    		container2_binding
    	];
    }

    class AppBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			baseHeightWritable: 0,
    			computedPaddingWritable: 1,
    			title: 2,
    			appBarPadding: 10,
    			appBarPaddingWritable: 3,
    			contentPadding: 11,
    			contentPaddingWritable: 4,
    			isInAnimated: 12,
    			isOutAnimated: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppBar",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get baseHeightWritable() {
    		return this.$$.ctx[0];
    	}

    	set baseHeightWritable(value) {
    		throw new Error("<AppBar>: Cannot set read-only property 'baseHeightWritable'");
    	}

    	get computedPaddingWritable() {
    		return this.$$.ctx[1];
    	}

    	set computedPaddingWritable(computedPaddingWritable) {
    		this.$set({ computedPaddingWritable });
    		flush();
    	}

    	get title() {
    		return this.$$.ctx[2];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get appBarPadding() {
    		return this.$$.ctx[10];
    	}

    	set appBarPadding(appBarPadding) {
    		this.$set({ appBarPadding });
    		flush();
    	}

    	get appBarPaddingWritable() {
    		return this.$$.ctx[3];
    	}

    	set appBarPaddingWritable(appBarPaddingWritable) {
    		this.$set({ appBarPaddingWritable });
    		flush();
    	}

    	get contentPadding() {
    		return this.$$.ctx[11];
    	}

    	set contentPadding(contentPadding) {
    		this.$set({ contentPadding });
    		flush();
    	}

    	get contentPaddingWritable() {
    		return this.$$.ctx[4];
    	}

    	set contentPaddingWritable(contentPaddingWritable) {
    		this.$set({ contentPaddingWritable });
    		flush();
    	}

    	get isInAnimated() {
    		return this.$$.ctx[12];
    	}

    	set isInAnimated(isInAnimated) {
    		this.$set({ isInAnimated });
    		flush();
    	}

    	get isOutAnimated() {
    		return this.$$.ctx[13];
    	}

    	set isOutAnimated(isOutAnimated) {
    		this.$set({ isOutAnimated });
    		flush();
    	}
    }

    /* src\ui\blocks\Scene.svelte generated by Svelte v3.24.1 */

    const file$9 = "src\\ui\\blocks\\Scene.svelte";

    // (85:8)      
    function fallback_block$2(ctx) {
    	let container;
    	let string;

    	const block = {
    		c: function create() {
    			container = element("container");
    			string = element("string");
    			string.textContent = `${strings.ui.scenes.common.warn.EMPTY_SCENE}`;
    			attr_dev(string, "class", "svelte-1p3dob5");
    			add_location(string, file$9, 86, 4, 2123);
    			attr_dev(container, "class", "placeholder svelte-1p3dob5");
    			add_location(container, file$9, 85, 3, 2086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			append_dev(container, string);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(85:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let component;
    	let container;
    	let component_intro;
    	let component_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[16].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	const block = {
    		c: function create() {
    			component = element("component");
    			container = element("container");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(container, "class", "content svelte-1p3dob5");
    			set_style(container, "--columns", /*columns*/ ctx[0]);
    			set_style(container, "--rows", /*rows*/ ctx[1]);
    			set_style(container, "--gap", /*gap*/ ctx[2]);
    			set_style(container, "--is-or-not-padding", /*isPadded*/ ctx[7] ? "var(--padding)" : "0px");
    			set_style(container, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[8]));
    			add_location(container, file$9, 74, 1, 1831);
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[5]));
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[6]));
    			set_style(component, "--align", CSSUtility.parse(/*align*/ ctx[4]));
    			set_style(component, "--justify", CSSUtility.parse(/*justify*/ ctx[3]));
    			attr_dev(component, "class", "svelte-1p3dob5");
    			add_location(component, file$9, 46, 0, 1138);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, container);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(container, null);
    			}

    			/*component_binding*/ ctx[21](component);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(component, "introstart", /*introstart_handler*/ ctx[17], false, false, false),
    					listen_dev(component, "introend", /*introend_handler*/ ctx[18], false, false, false),
    					listen_dev(component, "outrostart", /*outrostart_handler*/ ctx[19], false, false, false),
    					listen_dev(component, "outroend", /*outroend_handler*/ ctx[20], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32768) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*columns*/ 1) {
    				set_style(container, "--columns", /*columns*/ ctx[0]);
    			}

    			if (!current || dirty & /*rows*/ 2) {
    				set_style(container, "--rows", /*rows*/ ctx[1]);
    			}

    			if (!current || dirty & /*gap*/ 4) {
    				set_style(container, "--gap", /*gap*/ ctx[2]);
    			}

    			if (!current || dirty & /*isPadded*/ 128) {
    				set_style(container, "--is-or-not-padding", /*isPadded*/ ctx[7] ? "var(--padding)" : "0px");
    			}

    			if (!current || dirty & /*backgroundColour*/ 256) {
    				set_style(container, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[8]));
    			}

    			if (!current || dirty & /*width*/ 32) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[5]));
    			}

    			if (!current || dirty & /*height*/ 64) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[6]));
    			}

    			if (!current || dirty & /*align*/ 16) {
    				set_style(component, "--align", CSSUtility.parse(/*align*/ ctx[4]));
    			}

    			if (!current || dirty & /*justify*/ 8) {
    				set_style(component, "--justify", CSSUtility.parse(/*justify*/ ctx[3]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);

    			add_render_callback(() => {
    				if (component_outro) component_outro.end(1);
    				if (!component_intro) component_intro = create_in_transition(component, /*dropIn*/ ctx[11], {});
    				component_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			if (component_intro) component_intro.invalidate();
    			component_outro = create_out_transition(component, /*dropOut*/ ctx[12], {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*component_binding*/ ctx[21](null);
    			if (detaching && component_outro) component_outro.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $isSceneOutAnimationRunning;
    	validate_store(isSceneOutAnimationRunning, "isSceneOutAnimationRunning");
    	component_subscribe($$self, isSceneOutAnimationRunning, $$value => $$invalidate(22, $isSceneOutAnimationRunning = $$value));
    	let { columns = "auto" } = $$props;
    	let { rows = "auto" } = $$props;
    	let { gap = "0" } = $$props;
    	let { justify = "start" } = $$props;
    	let { align = "center" } = $$props;
    	let { width = "auto" } = $$props;
    	let { height = "auto" } = $$props;
    	let { isPadded = true } = $$props;
    	let { backgroundColour = "--colour-background-primary" } = $$props;
    	let { isInAnimated = false } = $$props;
    	let { isOutAnimated = false } = $$props;
    	const dropIn$1 = isInAnimated ? dropIn : noop$1;
    	const dropOut$1 = isOutAnimated ? dropOut : noop$1;
    	let componentDomContent = null;
    	let isLocalInAnimationRunning = false;

    	const writable_props = [
    		"columns",
    		"rows",
    		"gap",
    		"justify",
    		"align",
    		"width",
    		"height",
    		"isPadded",
    		"backgroundColour",
    		"isInAnimated",
    		"isOutAnimated"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Scene> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Scene", $$slots, ['default']);

    	const introstart_handler = () => {
    		isSceneInAnimationRunning.set($$invalidate(10, isLocalInAnimationRunning = true));
    	};

    	const introend_handler = () => {
    		// eslint-disable-next-line no-unused-vars
    		isSceneInAnimationRunning.set($$invalidate(10, isLocalInAnimationRunning = false));
    	};

    	const outrostart_handler = () => {
    		isSceneOutAnimationRunning.set(true);
    		ScrollUtility.disable();
    	};

    	const outroend_handler = () => {
    		isSceneOutAnimationRunning.set(false);
    		ScrollUtility.enable();
    	};

    	function component_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			componentDomContent = $$value;
    			(((($$invalidate(9, componentDomContent), $$invalidate(13, isInAnimated)), $$invalidate(14, isOutAnimated)), $$invalidate(10, isLocalInAnimationRunning)), $$invalidate(22, $isSceneOutAnimationRunning));
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("columns" in $$props) $$invalidate(0, columns = $$props.columns);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("gap" in $$props) $$invalidate(2, gap = $$props.gap);
    		if ("justify" in $$props) $$invalidate(3, justify = $$props.justify);
    		if ("align" in $$props) $$invalidate(4, align = $$props.align);
    		if ("width" in $$props) $$invalidate(5, width = $$props.width);
    		if ("height" in $$props) $$invalidate(6, height = $$props.height);
    		if ("isPadded" in $$props) $$invalidate(7, isPadded = $$props.isPadded);
    		if ("backgroundColour" in $$props) $$invalidate(8, backgroundColour = $$props.backgroundColour);
    		if ("isInAnimated" in $$props) $$invalidate(13, isInAnimated = $$props.isInAnimated);
    		if ("isOutAnimated" in $$props) $$invalidate(14, isOutAnimated = $$props.isOutAnimated);
    		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		strings,
    		CSSUtility,
    		ScrollUtility,
    		dropInRaw: dropIn,
    		dropOutRaw: dropOut,
    		noop: noop$1,
    		isSceneOutAnimationRunning,
    		isSceneInAnimationRunning,
    		columns,
    		rows,
    		gap,
    		justify,
    		align,
    		width,
    		height,
    		isPadded,
    		backgroundColour,
    		isInAnimated,
    		isOutAnimated,
    		dropIn: dropIn$1,
    		dropOut: dropOut$1,
    		componentDomContent,
    		isLocalInAnimationRunning,
    		$isSceneOutAnimationRunning
    	});

    	$$self.$inject_state = $$props => {
    		if ("columns" in $$props) $$invalidate(0, columns = $$props.columns);
    		if ("rows" in $$props) $$invalidate(1, rows = $$props.rows);
    		if ("gap" in $$props) $$invalidate(2, gap = $$props.gap);
    		if ("justify" in $$props) $$invalidate(3, justify = $$props.justify);
    		if ("align" in $$props) $$invalidate(4, align = $$props.align);
    		if ("width" in $$props) $$invalidate(5, width = $$props.width);
    		if ("height" in $$props) $$invalidate(6, height = $$props.height);
    		if ("isPadded" in $$props) $$invalidate(7, isPadded = $$props.isPadded);
    		if ("backgroundColour" in $$props) $$invalidate(8, backgroundColour = $$props.backgroundColour);
    		if ("isInAnimated" in $$props) $$invalidate(13, isInAnimated = $$props.isInAnimated);
    		if ("isOutAnimated" in $$props) $$invalidate(14, isOutAnimated = $$props.isOutAnimated);
    		if ("componentDomContent" in $$props) $$invalidate(9, componentDomContent = $$props.componentDomContent);
    		if ("isLocalInAnimationRunning" in $$props) $$invalidate(10, isLocalInAnimationRunning = $$props.isLocalInAnimationRunning);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isInAnimated, isOutAnimated, componentDomContent, isLocalInAnimationRunning, $isSceneOutAnimationRunning*/ 4220416) {
    			 (isInAnimated || isOutAnimated) && componentDomContent && isLocalInAnimationRunning && $$invalidate(9, componentDomContent.style.display = $isSceneOutAnimationRunning ? "none" : "", componentDomContent);
    		}
    	};

    	return [
    		columns,
    		rows,
    		gap,
    		justify,
    		align,
    		width,
    		height,
    		isPadded,
    		backgroundColour,
    		componentDomContent,
    		isLocalInAnimationRunning,
    		dropIn$1,
    		dropOut$1,
    		isInAnimated,
    		isOutAnimated,
    		$$scope,
    		$$slots,
    		introstart_handler,
    		introend_handler,
    		outrostart_handler,
    		outroend_handler,
    		component_binding
    	];
    }

    class Scene extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			columns: 0,
    			rows: 1,
    			gap: 2,
    			justify: 3,
    			align: 4,
    			width: 5,
    			height: 6,
    			isPadded: 7,
    			backgroundColour: 8,
    			isInAnimated: 13,
    			isOutAnimated: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scene",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get columns() {
    		return this.$$.ctx[0];
    	}

    	set columns(columns) {
    		this.$set({ columns });
    		flush();
    	}

    	get rows() {
    		return this.$$.ctx[1];
    	}

    	set rows(rows) {
    		this.$set({ rows });
    		flush();
    	}

    	get gap() {
    		return this.$$.ctx[2];
    	}

    	set gap(gap) {
    		this.$set({ gap });
    		flush();
    	}

    	get justify() {
    		return this.$$.ctx[3];
    	}

    	set justify(justify) {
    		this.$set({ justify });
    		flush();
    	}

    	get align() {
    		return this.$$.ctx[4];
    	}

    	set align(align) {
    		this.$set({ align });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[5];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[6];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get isPadded() {
    		return this.$$.ctx[7];
    	}

    	set isPadded(isPadded) {
    		this.$set({ isPadded });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[8];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get isInAnimated() {
    		return this.$$.ctx[13];
    	}

    	set isInAnimated(isInAnimated) {
    		this.$set({ isInAnimated });
    		flush();
    	}

    	get isOutAnimated() {
    		return this.$$.ctx[14];
    	}

    	set isOutAnimated(isOutAnimated) {
    		this.$set({ isOutAnimated });
    		flush();
    	}
    }

    /* src\ui\blocks\scenes\AppBarScene.svelte generated by Svelte v3.24.1 */
    const file$a = "src\\ui\\blocks\\scenes\\AppBarScene.svelte";
    const get_appBar_slot_changes = dirty => ({});
    const get_appBar_slot_context = ctx => ({});

    // (19:21)     
    function fallback_block$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ title: /*title*/ ctx[1] }, /*appBarProps*/ ctx[2]];
    	var switch_value = /*appBarComponent*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*title, appBarProps*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*title*/ 2 && { title: /*title*/ ctx[1] },
    					dirty & /*appBarProps*/ 4 && get_spread_object(/*appBarProps*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*appBarComponent*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(19:21)     ",
    		ctx
    	});

    	return block;
    }

    // (26:1) <Scene    height='auto'    width='auto'    {...$$restProps}   >
    function create_default_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(26:1) <Scene    height='auto'    width='auto'    {...$$restProps}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let component;
    	let t;
    	let scene;
    	let current;
    	const appBar_slot_template = /*$$slots*/ ctx[6].appBar;
    	const appBar_slot = create_slot(appBar_slot_template, ctx, /*$$scope*/ ctx[7], get_appBar_slot_context);
    	const appBar_slot_or_fallback = appBar_slot || fallback_block$3(ctx);
    	const scene_spread_levels = [{ height: "auto" }, { width: "auto" }, /*$$restProps*/ ctx[5]];

    	let scene_props = {
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < scene_spread_levels.length; i += 1) {
    		scene_props = assign(scene_props, scene_spread_levels[i]);
    	}

    	scene = new Scene({ props: scene_props, $$inline: true });

    	const block = {
    		c: function create() {
    			component = element("component");
    			if (appBar_slot_or_fallback) appBar_slot_or_fallback.c();
    			t = space();
    			create_component(scene.$$.fragment);
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[3]));
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[4]));
    			attr_dev(component, "class", "svelte-f67efg");
    			add_location(component, file$a, 12, 0, 322);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);

    			if (appBar_slot_or_fallback) {
    				appBar_slot_or_fallback.m(component, null);
    			}

    			append_dev(component, t);
    			mount_component(scene, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (appBar_slot) {
    				if (appBar_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(appBar_slot, appBar_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_appBar_slot_changes, get_appBar_slot_context);
    				}
    			} else {
    				if (appBar_slot_or_fallback && appBar_slot_or_fallback.p && dirty & /*appBarComponent, title, appBarProps*/ 7) {
    					appBar_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			const scene_changes = (dirty & /*$$restProps*/ 32)
    			? get_spread_update(scene_spread_levels, [
    					scene_spread_levels[0],
    					scene_spread_levels[1],
    					get_spread_object(/*$$restProps*/ ctx[5])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 128) {
    				scene_changes.$$scope = { dirty, ctx };
    			}

    			scene.$set(scene_changes);

    			if (!current || dirty & /*height*/ 8) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[3]));
    			}

    			if (!current || dirty & /*width*/ 16) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[4]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appBar_slot_or_fallback, local);
    			transition_in(scene.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appBar_slot_or_fallback, local);
    			transition_out(scene.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if (appBar_slot_or_fallback) appBar_slot_or_fallback.d(detaching);
    			destroy_component(scene);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	const omit_props_names = ["appBarComponent","title","appBarProps","height","width"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { appBarComponent = AppBar } = $$props;
    	let { title = null } = $$props;
    	let { appBarProps = {} } = $$props;
    	let { height = "auto" } = $$props;
    	let { width = "auto" } = $$props;
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AppBarScene", $$slots, ['appBar','default']);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("appBarComponent" in $$new_props) $$invalidate(0, appBarComponent = $$new_props.appBarComponent);
    		if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
    		if ("appBarProps" in $$new_props) $$invalidate(2, appBarProps = $$new_props.appBarProps);
    		if ("height" in $$new_props) $$invalidate(3, height = $$new_props.height);
    		if ("width" in $$new_props) $$invalidate(4, width = $$new_props.width);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		AppBar,
    		Scene,
    		CSSUtility,
    		appBarComponent,
    		title,
    		appBarProps,
    		height,
    		width
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("appBarComponent" in $$props) $$invalidate(0, appBarComponent = $$new_props.appBarComponent);
    		if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
    		if ("appBarProps" in $$props) $$invalidate(2, appBarProps = $$new_props.appBarProps);
    		if ("height" in $$props) $$invalidate(3, height = $$new_props.height);
    		if ("width" in $$props) $$invalidate(4, width = $$new_props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		appBarComponent,
    		title,
    		appBarProps,
    		height,
    		width,
    		$$restProps,
    		$$slots,
    		$$scope
    	];
    }

    class AppBarScene extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			appBarComponent: 0,
    			title: 1,
    			appBarProps: 2,
    			height: 3,
    			width: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppBarScene",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get appBarComponent() {
    		return this.$$.ctx[0];
    	}

    	set appBarComponent(appBarComponent) {
    		this.$set({ appBarComponent });
    		flush();
    	}

    	get title() {
    		return this.$$.ctx[1];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get appBarProps() {
    		return this.$$.ctx[2];
    	}

    	set appBarProps(appBarProps) {
    		this.$set({ appBarProps });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[3];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[4];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}
    }

    /* src\ui\blocks\dialogs\ConfirmDialog.svelte generated by Svelte v3.24.1 */
    const file$b = "src\\ui\\blocks\\dialogs\\ConfirmDialog.svelte";

    // (27:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >
    function create_default_slot_3(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8192) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[13], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(27:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >",
    		ctx
    	});

    	return block;
    }

    // (36:2) <Button      icon='close'     width='100%'     backgroundColour='--colour-background-primary'     hoverColour='--colour-background-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('cancel');     }}    >
    function create_default_slot_2(ctx) {
    	let t_value = strings.common.info.CANCEL + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(36:2) <Button      icon='close'     width='100%'     backgroundColour='--colour-background-primary'     hoverColour='--colour-background-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('cancel');     }}    >",
    		ctx
    	});

    	return block;
    }

    // (49:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('confirm');     }}    >
    function create_default_slot_1(ctx) {
    	let t_value = strings.common.info.CONFIRM + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(49:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('confirm');     }}    >",
    		ctx
    	});

    	return block;
    }

    // (21:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialogDomContent}  >
    function create_default_slot$3(ctx) {
    	let appbarscene;
    	let t0;
    	let container;
    	let button0;
    	let t1;
    	let button1;
    	let current;

    	appbarscene = new AppBarScene({
    			props: {
    				title: /*title*/ ctx[0],
    				columns: /*sceneColumns*/ ctx[1],
    				rows: /*sceneRows*/ ctx[2],
    				gap: /*sceneGap*/ ctx[3],
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				icon: "close",
    				width: "100%",
    				backgroundColour: "--colour-background-primary",
    				hoverColour: "--colour-background-secondary",
    				rippleColour: "--colour-text-secondary",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[10]);

    	button1 = new Button({
    			props: {
    				icon: "adjust",
    				width: "100%",
    				backgroundColour: "--colour-ok-primary",
    				hoverColour: "--colour-ok-secondary",
    				rippleColour: "--colour-text-secondary",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(appbarscene.$$.fragment);
    			t0 = space();
    			container = element("container");
    			create_component(button0.$$.fragment);
    			t1 = space();
    			create_component(button1.$$.fragment);
    			attr_dev(container, "class", "buttons svelte-101nfp8");
    			add_location(container, file$b, 34, 1, 855);
    		},
    		m: function mount(target, anchor) {
    			mount_component(appbarscene, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, container, anchor);
    			mount_component(button0, container, null);
    			append_dev(container, t1);
    			mount_component(button1, container, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const appbarscene_changes = {};
    			if (dirty & /*title*/ 1) appbarscene_changes.title = /*title*/ ctx[0];
    			if (dirty & /*sceneColumns*/ 2) appbarscene_changes.columns = /*sceneColumns*/ ctx[1];
    			if (dirty & /*sceneRows*/ 4) appbarscene_changes.rows = /*sceneRows*/ ctx[2];
    			if (dirty & /*sceneGap*/ 8) appbarscene_changes.gap = /*sceneGap*/ ctx[3];

    			if (dirty & /*$$scope*/ 8192) {
    				appbarscene_changes.$$scope = { dirty, ctx };
    			}

    			appbarscene.$set(appbarscene_changes);
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appbarscene.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appbarscene.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(appbarscene, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(container);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(21:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialogDomContent}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let dialog;
    	let current;

    	let dialog_props = {
    		depth: /*depth*/ ctx[4],
    		dismissOnClick: /*dismissOnClick*/ ctx[5],
    		isActiveWritable: /*isActiveWritable*/ ctx[6],
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	/*dialog_binding*/ ctx[12](dialog);

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_changes = {};
    			if (dirty & /*depth*/ 16) dialog_changes.depth = /*depth*/ ctx[4];
    			if (dirty & /*dismissOnClick*/ 32) dialog_changes.dismissOnClick = /*dismissOnClick*/ ctx[5];
    			if (dirty & /*isActiveWritable*/ 64) dialog_changes.isActiveWritable = /*isActiveWritable*/ ctx[6];

    			if (dirty & /*$$scope, dialogDomContent, title, sceneColumns, sceneRows, sceneGap*/ 8335) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*dialog_binding*/ ctx[12](null);
    			destroy_component(dialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { title = "Confirm.dialog" } = $$props;
    	let { sceneColumns = "auto" } = $$props;
    	let { sceneRows = "auto" } = $$props;
    	let { sceneGap = "0" } = $$props;
    	let { depth = 3 } = $$props;
    	let { dismissOnClick = false } = $$props;
    	let { isActiveWritable = writable(true) } = $$props;
    	const dispatch = createEventDispatcher();
    	let dialogDomContent = null;

    	const writable_props = [
    		"title",
    		"sceneColumns",
    		"sceneRows",
    		"sceneGap",
    		"depth",
    		"dismissOnClick",
    		"isActiveWritable"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ConfirmDialog> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ConfirmDialog", $$slots, ['default']);

    	const click_handler = () => {
    		dialogDomContent.dismiss();
    		dispatch("cancel");
    	};

    	const click_handler_1 = () => {
    		dialogDomContent.dismiss();
    		dispatch("confirm");
    	};

    	function dialog_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			dialogDomContent = $$value;
    			$$invalidate(7, dialogDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$invalidate(6, isActiveWritable = $$props.isActiveWritable);
    		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		writable,
    		Dialog,
    		Button,
    		strings,
    		AppBarScene,
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		dispatch,
    		dialogDomContent
    	});

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$invalidate(6, isActiveWritable = $$props.isActiveWritable);
    		if ("dialogDomContent" in $$props) $$invalidate(7, dialogDomContent = $$props.dialogDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		dialogDomContent,
    		dispatch,
    		$$slots,
    		click_handler,
    		click_handler_1,
    		dialog_binding,
    		$$scope
    	];
    }

    class ConfirmDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			title: 0,
    			sceneColumns: 1,
    			sceneRows: 2,
    			sceneGap: 3,
    			depth: 4,
    			dismissOnClick: 5,
    			isActiveWritable: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConfirmDialog",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get title() {
    		return this.$$.ctx[0];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get sceneColumns() {
    		return this.$$.ctx[1];
    	}

    	set sceneColumns(sceneColumns) {
    		this.$set({ sceneColumns });
    		flush();
    	}

    	get sceneRows() {
    		return this.$$.ctx[2];
    	}

    	set sceneRows(sceneRows) {
    		this.$set({ sceneRows });
    		flush();
    	}

    	get sceneGap() {
    		return this.$$.ctx[3];
    	}

    	set sceneGap(sceneGap) {
    		this.$set({ sceneGap });
    		flush();
    	}

    	get depth() {
    		return this.$$.ctx[4];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get dismissOnClick() {
    		return this.$$.ctx[5];
    	}

    	set dismissOnClick(dismissOnClick) {
    		this.$set({ dismissOnClick });
    		flush();
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[6];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}
    }

    /* src\ui\blocks\dialogs\InputDialog.svelte generated by Svelte v3.24.1 */
    const file$c = "src\\ui\\blocks\\dialogs\\InputDialog.svelte";

    // (41:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >
    function create_default_slot_3$1(ctx) {
    	let t0;
    	let spacer;
    	let t1;
    	let input_1;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);
    	spacer = new Spacer({ $$inline: true });

    	let input_1_props = {
    		label: /*title*/ ctx[0],
    		buttonComponent: null
    	};

    	input_1 = new Input({ props: input_1_props, $$inline: true });
    	/*input_1_binding*/ ctx[13](input_1);
    	input_1.$on("submit", /*submit_handler*/ ctx[14]);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t0 = space();
    			create_component(spacer.$$.fragment);
    			t1 = space();
    			create_component(input_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			mount_component(spacer, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(input_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 262144) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[18], dirty, null, null);
    				}
    			}

    			const input_1_changes = {};
    			if (dirty & /*title*/ 1) input_1_changes.label = /*title*/ ctx[0];
    			input_1.$set(input_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(spacer.$$.fragment, local);
    			transition_in(input_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(spacer.$$.fragment, local);
    			transition_out(input_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(spacer, detaching);
    			if (detaching) detach_dev(t1);
    			/*input_1_binding*/ ctx[13](null);
    			destroy_component(input_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(41:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >",
    		ctx
    	});

    	return block;
    }

    // (60:2) <Button      icon='close'     width='100%'     backgroundColour='--colour-background-primary'     hoverColour='--colour-background-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dismiss();      dispatch('cancel');     }}    >
    function create_default_slot_2$1(ctx) {
    	let t_value = strings.common.info.CANCEL + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(60:2) <Button      icon='close'     width='100%'     backgroundColour='--colour-background-primary'     hoverColour='--colour-background-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dismiss();      dispatch('cancel');     }}    >",
    		ctx
    	});

    	return block;
    }

    // (73:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => input.submit()}    >
    function create_default_slot_1$1(ctx) {
    	let t_value = strings.common.info.CONFIRM + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(73:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => input.submit()}    >",
    		ctx
    	});

    	return block;
    }

    // (35:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialog}  >
    function create_default_slot$4(ctx) {
    	let appbarscene;
    	let t0;
    	let container;
    	let button0;
    	let t1;
    	let button1;
    	let current;

    	appbarscene = new AppBarScene({
    			props: {
    				title: /*title*/ ctx[0],
    				columns: /*sceneColumns*/ ctx[1],
    				rows: /*sceneRows*/ ctx[2],
    				gap: /*sceneGap*/ ctx[3],
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Button({
    			props: {
    				icon: "close",
    				width: "100%",
    				backgroundColour: "--colour-background-primary",
    				hoverColour: "--colour-background-secondary",
    				rippleColour: "--colour-text-secondary",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[15]);

    	button1 = new Button({
    			props: {
    				icon: "adjust",
    				width: "100%",
    				backgroundColour: "--colour-ok-primary",
    				hoverColour: "--colour-ok-secondary",
    				rippleColour: "--colour-text-secondary",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_1*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(appbarscene.$$.fragment);
    			t0 = space();
    			container = element("container");
    			create_component(button0.$$.fragment);
    			t1 = space();
    			create_component(button1.$$.fragment);
    			attr_dev(container, "class", "buttons svelte-101nfp8");
    			add_location(container, file$c, 58, 1, 1320);
    		},
    		m: function mount(target, anchor) {
    			mount_component(appbarscene, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, container, anchor);
    			mount_component(button0, container, null);
    			append_dev(container, t1);
    			mount_component(button1, container, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const appbarscene_changes = {};
    			if (dirty & /*title*/ 1) appbarscene_changes.title = /*title*/ ctx[0];
    			if (dirty & /*sceneColumns*/ 2) appbarscene_changes.columns = /*sceneColumns*/ ctx[1];
    			if (dirty & /*sceneRows*/ 4) appbarscene_changes.rows = /*sceneRows*/ ctx[2];
    			if (dirty & /*sceneGap*/ 8) appbarscene_changes.gap = /*sceneGap*/ ctx[3];

    			if (dirty & /*$$scope, title, input*/ 262401) {
    				appbarscene_changes.$$scope = { dirty, ctx };
    			}

    			appbarscene.$set(appbarscene_changes);
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appbarscene.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appbarscene.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(appbarscene, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(container);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(35:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialog}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let dialog_1;
    	let current;

    	let dialog_1_props = {
    		depth: /*depth*/ ctx[4],
    		dismissOnClick: /*dismissOnClick*/ ctx[5],
    		isActiveWritable: /*isActiveWritable*/ ctx[6],
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};

    	dialog_1 = new Dialog({ props: dialog_1_props, $$inline: true });
    	/*dialog_1_binding*/ ctx[17](dialog_1);

    	const block = {
    		c: function create() {
    			create_component(dialog_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_1_changes = {};
    			if (dirty & /*depth*/ 16) dialog_1_changes.depth = /*depth*/ ctx[4];
    			if (dirty & /*dismissOnClick*/ 32) dialog_1_changes.dismissOnClick = /*dismissOnClick*/ ctx[5];
    			if (dirty & /*isActiveWritable*/ 64) dialog_1_changes.isActiveWritable = /*isActiveWritable*/ ctx[6];

    			if (dirty & /*$$scope, input, title, sceneColumns, sceneRows, sceneGap*/ 262415) {
    				dialog_1_changes.$$scope = { dirty, ctx };
    			}

    			dialog_1.$set(dialog_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*dialog_1_binding*/ ctx[17](null);
    			destroy_component(dialog_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $isActiveWritable,
    		$$unsubscribe_isActiveWritable = noop,
    		$$subscribe_isActiveWritable = () => ($$unsubscribe_isActiveWritable(), $$unsubscribe_isActiveWritable = subscribe(isActiveWritable, $$value => $$invalidate(19, $isActiveWritable = $$value)), isActiveWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveWritable());
    	let { title = "Input.dialog" } = $$props;
    	let { sceneColumns = "auto" } = $$props;
    	let { sceneRows = "auto" } = $$props;
    	let { sceneGap = "0" } = $$props;
    	let { depth = 3 } = $$props;
    	let { dismissOnClick = false } = $$props;
    	let { isActiveWritable = writable(true) } = $$props;
    	validate_store(isActiveWritable, "isActiveWritable");
    	$$subscribe_isActiveWritable();
    	let { clearOnDismiss = true } = $$props;
    	const dispatch = createEventDispatcher();
    	let dialog = null;
    	let input = null;

    	function dismiss() {
    		dialog.dismiss();

    		if (clearOnDismiss) {
    			input.valueWritable.set("");
    		}
    	}

    	const writable_props = [
    		"title",
    		"sceneColumns",
    		"sceneRows",
    		"sceneGap",
    		"depth",
    		"dismissOnClick",
    		"isActiveWritable",
    		"clearOnDismiss"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InputDialog> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("InputDialog", $$slots, ['default']);

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(8, input);
    		});
    	}

    	const submit_handler = ({ detail: value }) => {
    		dismiss();
    		dispatch("submit", value);
    	};

    	const click_handler = () => {
    		dismiss();
    		dispatch("cancel");
    	};

    	const click_handler_1 = () => input.submit();

    	function dialog_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			dialog = $$value;
    			$$invalidate(7, dialog);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(6, isActiveWritable = $$props.isActiveWritable));
    		if ("clearOnDismiss" in $$props) $$invalidate(11, clearOnDismiss = $$props.clearOnDismiss);
    		if ("$$scope" in $$props) $$invalidate(18, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		writable,
    		Dialog,
    		Button,
    		Input,
    		strings,
    		Spacer,
    		AppBarScene,
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		clearOnDismiss,
    		dispatch,
    		dialog,
    		input,
    		dismiss,
    		$isActiveWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(6, isActiveWritable = $$props.isActiveWritable));
    		if ("clearOnDismiss" in $$props) $$invalidate(11, clearOnDismiss = $$props.clearOnDismiss);
    		if ("dialog" in $$props) $$invalidate(7, dialog = $$props.dialog);
    		if ("input" in $$props) $$invalidate(8, input = $$props.input);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$isActiveWritable, input*/ 524544) {
    			 $isActiveWritable && input?.focus();
    		}
    	};

    	return [
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		dialog,
    		input,
    		dispatch,
    		dismiss,
    		clearOnDismiss,
    		$$slots,
    		input_1_binding,
    		submit_handler,
    		click_handler,
    		click_handler_1,
    		dialog_1_binding,
    		$$scope
    	];
    }

    class InputDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			title: 0,
    			sceneColumns: 1,
    			sceneRows: 2,
    			sceneGap: 3,
    			depth: 4,
    			dismissOnClick: 5,
    			isActiveWritable: 6,
    			clearOnDismiss: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputDialog",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get title() {
    		return this.$$.ctx[0];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get sceneColumns() {
    		return this.$$.ctx[1];
    	}

    	set sceneColumns(sceneColumns) {
    		this.$set({ sceneColumns });
    		flush();
    	}

    	get sceneRows() {
    		return this.$$.ctx[2];
    	}

    	set sceneRows(sceneRows) {
    		this.$set({ sceneRows });
    		flush();
    	}

    	get sceneGap() {
    		return this.$$.ctx[3];
    	}

    	set sceneGap(sceneGap) {
    		this.$set({ sceneGap });
    		flush();
    	}

    	get depth() {
    		return this.$$.ctx[4];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get dismissOnClick() {
    		return this.$$.ctx[5];
    	}

    	set dismissOnClick(dismissOnClick) {
    		this.$set({ dismissOnClick });
    		flush();
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[6];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}

    	get clearOnDismiss() {
    		return this.$$.ctx[11];
    	}

    	set clearOnDismiss(clearOnDismiss) {
    		this.$set({ clearOnDismiss });
    		flush();
    	}
    }

    /* src\ui\blocks\dialogs\OkDialog.svelte generated by Svelte v3.24.1 */
    const file$d = "src\\ui\\blocks\\dialogs\\OkDialog.svelte";

    // (27:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >
    function create_default_slot_2$2(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(27:1) <AppBarScene    {title}    columns={sceneColumns}    rows={sceneRows}    gap={sceneGap}   >",
    		ctx
    	});

    	return block;
    }

    // (36:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('ok');     }}    >
    function create_default_slot_1$2(ctx) {
    	let t_value = strings.common.info.OK + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(36:2) <Button      icon='adjust'     width='100%'     backgroundColour='--colour-ok-primary'     hoverColour='--colour-ok-secondary'     rippleColour='--colour-text-secondary'     on:click={() => {      dialogDomContent.dismiss();      dispatch('ok');     }}    >",
    		ctx
    	});

    	return block;
    }

    // (21:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialogDomContent}  >
    function create_default_slot$5(ctx) {
    	let appbarscene;
    	let t;
    	let container;
    	let button;
    	let current;

    	appbarscene = new AppBarScene({
    			props: {
    				title: /*title*/ ctx[0],
    				columns: /*sceneColumns*/ ctx[1],
    				rows: /*sceneRows*/ ctx[2],
    				gap: /*sceneGap*/ ctx[3],
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				icon: "adjust",
    				width: "100%",
    				backgroundColour: "--colour-ok-primary",
    				hoverColour: "--colour-ok-secondary",
    				rippleColour: "--colour-text-secondary",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(appbarscene.$$.fragment);
    			t = space();
    			container = element("container");
    			create_component(button.$$.fragment);
    			attr_dev(container, "class", "buttons svelte-1q3zs58");
    			add_location(container, file$d, 34, 1, 849);
    		},
    		m: function mount(target, anchor) {
    			mount_component(appbarscene, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, container, anchor);
    			mount_component(button, container, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const appbarscene_changes = {};
    			if (dirty & /*title*/ 1) appbarscene_changes.title = /*title*/ ctx[0];
    			if (dirty & /*sceneColumns*/ 2) appbarscene_changes.columns = /*sceneColumns*/ ctx[1];
    			if (dirty & /*sceneRows*/ 4) appbarscene_changes.rows = /*sceneRows*/ ctx[2];
    			if (dirty & /*sceneGap*/ 8) appbarscene_changes.gap = /*sceneGap*/ ctx[3];

    			if (dirty & /*$$scope*/ 4096) {
    				appbarscene_changes.$$scope = { dirty, ctx };
    			}

    			appbarscene.$set(appbarscene_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appbarscene.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appbarscene.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(appbarscene, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(container);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(21:0) <Dialog   {depth}   {dismissOnClick}   {isActiveWritable}   bind:this={dialogDomContent}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let dialog;
    	let current;

    	let dialog_props = {
    		depth: /*depth*/ ctx[4],
    		dismissOnClick: /*dismissOnClick*/ ctx[5],
    		isActiveWritable: /*isActiveWritable*/ ctx[6],
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	dialog = new Dialog({ props: dialog_props, $$inline: true });
    	/*dialog_binding*/ ctx[11](dialog);

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_changes = {};
    			if (dirty & /*depth*/ 16) dialog_changes.depth = /*depth*/ ctx[4];
    			if (dirty & /*dismissOnClick*/ 32) dialog_changes.dismissOnClick = /*dismissOnClick*/ ctx[5];
    			if (dirty & /*isActiveWritable*/ 64) dialog_changes.isActiveWritable = /*isActiveWritable*/ ctx[6];

    			if (dirty & /*$$scope, dialogDomContent, title, sceneColumns, sceneRows, sceneGap*/ 4239) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*dialog_binding*/ ctx[11](null);
    			destroy_component(dialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { title = "Ok.dialog" } = $$props;
    	let { sceneColumns = "auto" } = $$props;
    	let { sceneRows = "auto" } = $$props;
    	let { sceneGap = "0" } = $$props;
    	let { depth = 3 } = $$props;
    	let { dismissOnClick = true } = $$props;
    	let { isActiveWritable = writable(true) } = $$props;
    	const dispatch = createEventDispatcher();
    	let dialogDomContent = null;

    	const writable_props = [
    		"title",
    		"sceneColumns",
    		"sceneRows",
    		"sceneGap",
    		"depth",
    		"dismissOnClick",
    		"isActiveWritable"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OkDialog> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("OkDialog", $$slots, ['default']);

    	const click_handler = () => {
    		dialogDomContent.dismiss();
    		dispatch("ok");
    	};

    	function dialog_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			dialogDomContent = $$value;
    			$$invalidate(7, dialogDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$invalidate(6, isActiveWritable = $$props.isActiveWritable);
    		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		writable,
    		Dialog,
    		Button,
    		strings,
    		AppBarScene,
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		dispatch,
    		dialogDomContent
    	});

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("sceneColumns" in $$props) $$invalidate(1, sceneColumns = $$props.sceneColumns);
    		if ("sceneRows" in $$props) $$invalidate(2, sceneRows = $$props.sceneRows);
    		if ("sceneGap" in $$props) $$invalidate(3, sceneGap = $$props.sceneGap);
    		if ("depth" in $$props) $$invalidate(4, depth = $$props.depth);
    		if ("dismissOnClick" in $$props) $$invalidate(5, dismissOnClick = $$props.dismissOnClick);
    		if ("isActiveWritable" in $$props) $$invalidate(6, isActiveWritable = $$props.isActiveWritable);
    		if ("dialogDomContent" in $$props) $$invalidate(7, dialogDomContent = $$props.dialogDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		title,
    		sceneColumns,
    		sceneRows,
    		sceneGap,
    		depth,
    		dismissOnClick,
    		isActiveWritable,
    		dialogDomContent,
    		dispatch,
    		$$slots,
    		click_handler,
    		dialog_binding,
    		$$scope
    	];
    }

    class OkDialog extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			title: 0,
    			sceneColumns: 1,
    			sceneRows: 2,
    			sceneGap: 3,
    			depth: 4,
    			dismissOnClick: 5,
    			isActiveWritable: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OkDialog",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get title() {
    		return this.$$.ctx[0];
    	}

    	set title(title) {
    		this.$set({ title });
    		flush();
    	}

    	get sceneColumns() {
    		return this.$$.ctx[1];
    	}

    	set sceneColumns(sceneColumns) {
    		this.$set({ sceneColumns });
    		flush();
    	}

    	get sceneRows() {
    		return this.$$.ctx[2];
    	}

    	set sceneRows(sceneRows) {
    		this.$set({ sceneRows });
    		flush();
    	}

    	get sceneGap() {
    		return this.$$.ctx[3];
    	}

    	set sceneGap(sceneGap) {
    		this.$set({ sceneGap });
    		flush();
    	}

    	get depth() {
    		return this.$$.ctx[4];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get dismissOnClick() {
    		return this.$$.ctx[5];
    	}

    	set dismissOnClick(dismissOnClick) {
    		this.$set({ dismissOnClick });
    		flush();
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[6];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}
    }

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var lottie = createCommonjsModule(function (module) {
    (typeof navigator !== "undefined") && (function(root, factory) {
        if ( module.exports) {
            module.exports = factory(root);
        } else {
            root.lottie = factory(root);
            root.bodymovin = root.lottie;
        }
    }((window || {}), function(window) {
    var svgNS = "http://www.w3.org/2000/svg";

    var locationHref = '';

    var initialDefaultFrame = -999999;

    var subframeEnabled = true;
    var expressionsPlugin;
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var bm_pow = Math.pow;
    var bm_sqrt = Math.sqrt;
    var bm_floor = Math.floor;
    var bm_max = Math.max;
    var bm_min = Math.min;

    var BMMath = {};
    (function(){
        var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
        var i, len = propertyNames.length;
        for(i=0;i<len;i+=1){
            BMMath[propertyNames[i]] = Math[propertyNames[i]];
        }
    }());

    function ProjectInterface(){return {};}

    BMMath.random = Math.random;
    BMMath.abs = function(val){
        var tOfVal = typeof val;
        if(tOfVal === 'object' && val.length){
            var absArr = createSizedArray(val.length);
            var i, len = val.length;
            for(i=0;i<len;i+=1){
                absArr[i] = Math.abs(val[i]);
            }
            return absArr;
        }
        return Math.abs(val);

    };
    var defaultCurveSegments = 150;
    var degToRads = Math.PI/180;
    var roundCorner = 0.5519;

    function styleDiv(element){
        element.style.position = 'absolute';
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = 'block';
        element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';
        element.style.backfaceVisibility  = element.style.webkitBackfaceVisibility = 'visible';
        element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = "preserve-3d";
    }

    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier){
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMCompleteEvent(type, frameMultiplier){
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier){
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMSegmentStartEvent(type, firstFrame, totalFrames){
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
    }

    function BMDestroyEvent(type, target){
        this.type = type;
        this.target = target;
    }

    function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = 'renderFrameError';
        this.nativeError = nativeError;
        this.currentTime = currentTime;
    }

    function BMConfigErrorEvent(nativeError) {
        this.type = 'configError';
        this.nativeError = nativeError;
    }

    var createElementID = (function(){
        var _count = 0;
        return function createID() {
            return '__lottie_element_' + ++_count
        }
    }());

    function HSVtoRGB(h, s, v) {
        var r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v; g = t; b = p; break;
            case 1: r = q; g = v; b = p; break;
            case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break;
            case 4: r = t; g = p; b = v; break;
            case 5: r = v; g = p; b = q; break;
        }
        return [ r,
            g,
             b ];
    }

    function RGBtoHSV(r, g, b) {
        var max = Math.max(r, g, b), min = Math.min(r, g, b),
            d = max - min,
            h,
            s = (max === 0 ? 0 : d / max),
            v = max / 255;

        switch (max) {
            case min: h = 0; break;
            case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
            case g: h = (b - r) + d * 2; h /= 6 * d; break;
            case b: h = (r - g) + d * 4; h /= 6 * d; break;
        }

        return [
             h,
             s,
             v
        ];
    }

    function addSaturationToRGB(color,offset){
        var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
        hsv[1] += offset;
        if (hsv[1] > 1) {
            hsv[1] = 1;
        }
        else if (hsv[1] <= 0) {
            hsv[1] = 0;
        }
        return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
    }

    function addBrightnessToRGB(color,offset){
        var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
        hsv[2] += offset;
        if (hsv[2] > 1) {
            hsv[2] = 1;
        }
        else if (hsv[2] < 0) {
            hsv[2] = 0;
        }
        return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
    }

    function addHueToRGB(color,offset) {
        var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);
        hsv[0] += offset/360;
        if (hsv[0] > 1) {
            hsv[0] -= 1;
        }
        else if (hsv[0] < 0) {
            hsv[0] += 1;
        }
        return HSVtoRGB(hsv[0],hsv[1],hsv[2]);
    }

    var rgbToHex = (function(){
        var colorMap = [];
        var i;
        var hex;
        for(i=0;i<256;i+=1){
            hex = i.toString(16);
            colorMap[i] = hex.length == 1 ? '0' + hex : hex;
        }

        return function(r, g, b) {
            if(r<0){
                r = 0;
            }
            if(g<0){
                g = 0;
            }
            if(b<0){
                b = 0;
            }
            return '#' + colorMap[r] + colorMap[g] + colorMap[b];
        };
    }());
    function BaseEvent(){}
    BaseEvent.prototype = {
    	triggerEvent: function (eventName, args) {
    	    if (this._cbs[eventName]) {
    	        var len = this._cbs[eventName].length;
    	        for (var i = 0; i < len; i++){
    	            this._cbs[eventName][i](args);
    	        }
    	    }
    	},
    	addEventListener: function (eventName, callback) {
    	    if (!this._cbs[eventName]){
    	        this._cbs[eventName] = [];
    	    }
    	    this._cbs[eventName].push(callback);

    		return function() {
    			this.removeEventListener(eventName, callback);
    		}.bind(this);
    	},
    	removeEventListener: function (eventName,callback){
    	    if (!callback){
    	        this._cbs[eventName] = null;
    	    }else if(this._cbs[eventName]){
    	        var i = 0, len = this._cbs[eventName].length;
    	        while(i<len){
    	            if(this._cbs[eventName][i] === callback){
    	                this._cbs[eventName].splice(i,1);
    	                i -=1;
    	                len -= 1;
    	            }
    	            i += 1;
    	        }
    	        if(!this._cbs[eventName].length){
    	            this._cbs[eventName] = null;
    	        }
    	    }
    	}
    };
    var createTypedArray = (function(){
    	function createRegularArray(type, len){
    		var i = 0, arr = [], value;
    		switch(type) {
    			case 'int16':
    			case 'uint8c':
    				value = 1;
    				break;
    			default:
    				value = 1.1;
    				break;
    		}
    		for(i = 0; i < len; i += 1) {
    			arr.push(value);
    		}
    		return arr;
    	}
    	function createTypedArray(type, len){
    		if(type === 'float32') {
    			return new Float32Array(len);
    		} else if(type === 'int16') {
    			return new Int16Array(len);
    		} else if(type === 'uint8c') {
    			return new Uint8ClampedArray(len);
    		}
    	}
    	if(typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
    		return createTypedArray;
    	} else {
    		return createRegularArray;
    	}
    }());

    function createSizedArray(len) {
    	return Array.apply(null,{length:len});
    }
    function createNS(type) {
    	//return {appendChild:function(){},setAttribute:function(){},style:{}}
    	return document.createElementNS(svgNS, type);
    }
    function createTag(type) {
    	//return {appendChild:function(){},setAttribute:function(){},style:{}}
    	return document.createElement(type);
    }
    function DynamicPropertyContainer(){}DynamicPropertyContainer.prototype = {
    	addDynamicProperty: function(prop) {
    		if(this.dynamicProperties.indexOf(prop) === -1) {
    	        this.dynamicProperties.push(prop);
    	        this.container.addDynamicProperty(this);
    	    	this._isAnimated = true;
    	    }
    	},
    	iterateDynamicProperties: function(){
    	    this._mdf = false;
    	    var i, len = this.dynamicProperties.length;
    	    for(i=0;i<len;i+=1){
    	        this.dynamicProperties[i].getValue();
    	        if(this.dynamicProperties[i]._mdf) {
    	            this._mdf = true;
    	        }
    	    }
    	},
    	initDynamicPropertyContainer: function(container){
    	    this.container = container;
    	    this.dynamicProperties = [];
    	    this._mdf = false;
    	    this._isAnimated = false;
    	}
    };
    var getBlendMode = (function() {

    	var blendModeEnums = {
            0:'source-over',
            1:'multiply',
            2:'screen',
            3:'overlay',
            4:'darken',
            5:'lighten',
            6:'color-dodge',
            7:'color-burn',
            8:'hard-light',
            9:'soft-light',
            10:'difference',
            11:'exclusion',
            12:'hue',
            13:'saturation',
            14:'color',
            15:'luminosity'
        };

    	return function(mode) {
    		return blendModeEnums[mode] || '';
    	}
    }());
    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */

    /**
     * 2D transformation matrix object initialized with identity matrix.
     *
     * The matrix can synchronize a canvas context by supplying the context
     * as an argument, or later apply current absolute transform to an
     * existing context.
     *
     * All values are handled as floating point values.
     *
     * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
     * @prop {number} a - scale x
     * @prop {number} b - shear y
     * @prop {number} c - shear x
     * @prop {number} d - scale y
     * @prop {number} e - translate x
     * @prop {number} f - translate y
     * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
     * @constructor
     */

    var Matrix = (function(){

        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;

        function reset(){
            this.props[0] = 1;
            this.props[1] = 0;
            this.props[2] = 0;
            this.props[3] = 0;
            this.props[4] = 0;
            this.props[5] = 1;
            this.props[6] = 0;
            this.props[7] = 0;
            this.props[8] = 0;
            this.props[9] = 0;
            this.props[10] = 1;
            this.props[11] = 0;
            this.props[12] = 0;
            this.props[13] = 0;
            this.props[14] = 0;
            this.props[15] = 1;
            return this;
        }

        function rotate(angle) {
            if(angle === 0){
                return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
        }

        function rotateX(angle){
            if(angle === 0){
                return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin,  mCos, 0, 0, 0, 0, 1);
        }

        function rotateY(angle){
            if(angle === 0){
                return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos,  0,  mSin, 0, 0, 1, 0, 0, -mSin,  0,  mCos, 0, 0, 0, 0, 1);
        }

        function rotateZ(angle){
            if(angle === 0){
                return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
        }

        function shear(sx,sy){
            return this._t(1, sy, sx, 1, 0, 0);
        }

        function skew(ax, ay){
            return this.shear(_tan(ax), _tan(ay));
        }

        function skewFromAxis(ax, angle){
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, mSin,  0, 0, -mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)
                ._t(1, 0,  0, 0, _tan(ax),  1, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)
                ._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);
            //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
        }

        function scale(sx, sy, sz) {
            if(!sz && sz !== 0) {
                sz = 1;
            }
            if(sx === 1 && sy === 1 && sz === 1){
                return this;
            }
            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }

        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            this.props[0] = a;
            this.props[1] = b;
            this.props[2] = c;
            this.props[3] = d;
            this.props[4] = e;
            this.props[5] = f;
            this.props[6] = g;
            this.props[7] = h;
            this.props[8] = i;
            this.props[9] = j;
            this.props[10] = k;
            this.props[11] = l;
            this.props[12] = m;
            this.props[13] = n;
            this.props[14] = o;
            this.props[15] = p;
            return this;
        }

        function translate(tx, ty, tz) {
            tz = tz || 0;
            if(tx !== 0 || ty !== 0 || tz !== 0){
                return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);
            }
            return this;
        }

        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {

            var _p = this.props;

            if(a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0){
                //NOTE: commenting this condition because TurboFan deoptimizes code when present
                //if(m2 !== 0 || n2 !== 0 || o2 !== 0){
                    _p[12] = _p[12] * a2 + _p[15] * m2;
                    _p[13] = _p[13] * f2 + _p[15] * n2;
                    _p[14] = _p[14] * k2 + _p[15] * o2;
                    _p[15] = _p[15] * p2;
                //}
                this._identityCalculated = false;
                return this;
            }

            var a1 = _p[0];
            var b1 = _p[1];
            var c1 = _p[2];
            var d1 = _p[3];
            var e1 = _p[4];
            var f1 = _p[5];
            var g1 = _p[6];
            var h1 = _p[7];
            var i1 = _p[8];
            var j1 = _p[9];
            var k1 = _p[10];
            var l1 = _p[11];
            var m1 = _p[12];
            var n1 = _p[13];
            var o1 = _p[14];
            var p1 = _p[15];

            /* matrix order (canvas compatible):
             * ace
             * bdf
             * 001
             */
            _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2 ;
            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2 ;
            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2 ;

            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2 ;
            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2 ;
            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2 ;
            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2 ;

            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2 ;
            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2 ;
            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2 ;
            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2 ;

            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2 ;
            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2 ;
            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2 ;
            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2 ;

            this._identityCalculated = false;
            return this;
        }

        function isIdentity() {
            if(!this._identityCalculated){
                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
                this._identityCalculated = true;
            }
            return this._identity;
        }

        function equals(matr){
            var i = 0;
            while (i < 16) {
                if(matr.props[i] !== this.props[i]) {
                    return false;
                }
                i+=1;
            }
            return true;
        }

        function clone(matr){
            var i;
            for(i=0;i<16;i+=1){
                matr.props[i] = this.props[i];
            }
        }

        function cloneFromProps(props){
            var i;
            for(i=0;i<16;i+=1){
                this.props[i] = props[i];
            }
        }

        function applyToPoint(x, y, z) {

            return {
                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
            };
            /*return {
             x: x * me.a + y * me.c + me.e,
             y: x * me.b + y * me.d + me.f
             };*/
        }
        function applyToX(x, y, z) {
            return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
        }
        function applyToY(x, y, z) {
            return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
        }
        function applyToZ(x, y, z) {
            return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
        }

        function getInverseMatrix() {
            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
            var a = this.props[5]/determinant;
            var b = - this.props[1]/determinant;
            var c = - this.props[4]/determinant;
            var d = this.props[0]/determinant;
            var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12])/determinant;
            var f = - (this.props[0] * this.props[13] - this.props[1] * this.props[12])/determinant;
            var inverseMatrix = new Matrix();
            inverseMatrix.props[0] = a;
            inverseMatrix.props[1] = b;
            inverseMatrix.props[4] = c;
            inverseMatrix.props[5] = d;
            inverseMatrix.props[12] = e;
            inverseMatrix.props[13] = f;
            return inverseMatrix;
        }

        function inversePoint(pt) {
            var inverseMatrix = this.getInverseMatrix();
            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0)
        }

        function inversePoints(pts){
            var i, len = pts.length, retPts = [];
            for(i=0;i<len;i+=1){
                retPts[i] = inversePoint(pts[i]);
            }
            return retPts;
        }

        function applyToTriplePoints(pt1, pt2, pt3) {
            var arr = createTypedArray('float32', 6);
            if(this.isIdentity()) {
                arr[0] = pt1[0];
                arr[1] = pt1[1];
                arr[2] = pt2[0];
                arr[3] = pt2[1];
                arr[4] = pt3[0];
                arr[5] = pt3[1];
            } else {
                var p0 = this.props[0], p1 = this.props[1], p4 = this.props[4], p5 = this.props[5], p12 = this.props[12], p13 = this.props[13];
                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
            }
            return arr;
        }

        function applyToPointArray(x,y,z){
            var arr;
            if(this.isIdentity()) {
                arr = [x,y,z];
            } else {
                arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
            }
            return arr;
        }

        function applyToPointStringified(x, y) {
            if(this.isIdentity()) {
                return x + ',' + y;
            }
            var _p = this.props;
            return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100+','+ Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
        }

        function toCSS() {
            //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
            /*if(this.isIdentity()) {
                return '';
            }*/
            var i = 0;
            var props = this.props;
            var cssValue = 'matrix3d(';
            var v = 10000;
            while(i<16){
                cssValue += _rnd(props[i]*v)/v;
                cssValue += i === 15 ? ')':',';
                i += 1;
            }
            return cssValue;
        }

        function roundMatrixProperty(val) {
            var v = 10000;
            if((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
                return _rnd(val * v) / v;
            }
            return val;
        }

        function to2dCSS() {
            //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
            /*if(this.isIdentity()) {
                return '';
            }*/
            var props = this.props;
            var _a = roundMatrixProperty(props[0]);
            var _b = roundMatrixProperty(props[1]);
            var _c = roundMatrixProperty(props[4]);
            var _d = roundMatrixProperty(props[5]);
            var _e = roundMatrixProperty(props[12]);
            var _f = roundMatrixProperty(props[13]);
            return "matrix(" + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ")";
        }

        return function(){
            this.reset = reset;
            this.rotate = rotate;
            this.rotateX = rotateX;
            this.rotateY = rotateY;
            this.rotateZ = rotateZ;
            this.skew = skew;
            this.skewFromAxis = skewFromAxis;
            this.shear = shear;
            this.scale = scale;
            this.setTransform = setTransform;
            this.translate = translate;
            this.transform = transform;
            this.applyToPoint = applyToPoint;
            this.applyToX = applyToX;
            this.applyToY = applyToY;
            this.applyToZ = applyToZ;
            this.applyToPointArray = applyToPointArray;
            this.applyToTriplePoints = applyToTriplePoints;
            this.applyToPointStringified = applyToPointStringified;
            this.toCSS = toCSS;
            this.to2dCSS = to2dCSS;
            this.clone = clone;
            this.cloneFromProps = cloneFromProps;
            this.equals = equals;
            this.inversePoints = inversePoints;
            this.inversePoint = inversePoint;
            this.getInverseMatrix = getInverseMatrix;
            this._t = this.transform;
            this.isIdentity = isIdentity;
            this._identity = true;
            this._identityCalculated = false;

            this.props = createTypedArray('float32', 16);
            this.reset();
        };
    }());

    /*
     Copyright 2014 David Bau.

     Permission is hereby granted, free of charge, to any person obtaining
     a copy of this software and associated documentation files (the
     "Software"), to deal in the Software without restriction, including
     without limitation the rights to use, copy, modify, merge, publish,
     distribute, sublicense, and/or sell copies of the Software, and to
     permit persons to whom the Software is furnished to do so, subject to
     the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

     */

    (function (pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
        var global = this,
            width = 256,        // each RC4 output is 0 <= x < 256
            chunks = 6,         // at least six RC4 outputs for each double
            digits = 52,        // there are 52 significant digits in a double
            rngname = 'random', // rngname: name for Math.random and Math.seedrandom
            startdenom = math.pow(width, chunks),
            significance = math.pow(2, digits),
            overflow = significance * 2,
            mask = width - 1,
            nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
        function seedrandom(seed, options, callback) {
            var key = [];
            options = (options === true) ? { entropy: true } : (options || {});

            // Flatten the seed string or build one from local entropy if needed.
            var shortseed = mixkey(flatten(
                options.entropy ? [seed, tostring(pool)] :
                    (seed === null) ? autoseed() : seed, 3), key);

            // Use the seed to initialize an ARC4 generator.
            var arc4 = new ARC4(key);

            // This function returns a random double in [0, 1) that contains
            // randomness in every bit of the mantissa of the IEEE 754 value.
            var prng = function() {
                var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                    d = startdenom,                 //   and denominator d = 2 ^ 48.
                    x = 0;                          //   and no 'extra last byte'.
                while (n < significance) {          // Fill up all significant digits by
                    n = (n + x) * width;              //   shifting numerator and
                    d *= width;                       //   denominator and generating a
                    x = arc4.g(1);                    //   new least-significant-byte.
                }
                while (n >= overflow) {             // To avoid rounding up, before adding
                    n /= 2;                           //   last byte, shift everything
                    d /= 2;                           //   right using integer math until
                    x >>>= 1;                         //   we have exactly the desired bits.
                }
                return (n + x) / d;                 // Form the number within [0, 1).
            };

            prng.int32 = function() { return arc4.g(4) | 0; };
            prng.quick = function() { return arc4.g(4) / 0x100000000; };
            prng.double = prng;

            // Mix the randomness into accumulated entropy.
            mixkey(tostring(arc4.S), pool);

            // Calling convention: what to return as a function of prng, seed, is_math.
            return (options.pass || callback ||
            function(prng, seed, is_math_call, state) {
                if (state) {
                    // Load the arc4 state from the given state if it has an S array.
                    if (state.S) { copy(state, arc4); }
                    // Only provide the .state method if requested via options.state.
                    prng.state = function() { return copy(arc4, {}); };
                }

                // If called as a method of Math (Math.seedrandom()), mutate
                // Math.random because that is how seedrandom.js has worked since v1.0.
                if (is_math_call) { math[rngname] = prng; return seed; }

                // Otherwise, it is a newer calling convention, so return the
                // prng directly.
                else return prng;
            })(
                prng,
                shortseed,
                'global' in options ? options.global : (this == math),
                options.state);
        }
        math['seed' + rngname] = seedrandom;

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
        function ARC4(key) {
            var t, keylen = key.length,
                me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

            // The empty key [] is treated as [0].
            if (!keylen) { key = [keylen++]; }

            // Set up S using the standard key scheduling algorithm.
            while (i < width) {
                s[i] = i++;
            }
            for (i = 0; i < width; i++) {
                s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
                s[j] = t;
            }

            // The "g" method returns the next (count) outputs as one number.
            me.g = function(count) {
                // Using instance members instead of closure state nearly doubles speed.
                var t, r = 0,
                    i = me.i, j = me.j, s = me.S;
                while (count--) {
                    t = s[i = mask & (i + 1)];
                    r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
                }
                me.i = i; me.j = j;
                return r;
                // For robust unpredictability, the function call below automatically
                // discards an initial batch of values.  This is called RC4-drop[256].
                // See http://google.com/search?q=rsa+fluhrer+response&btnI
            };
        }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
        function copy(f, t) {
            t.i = f.i;
            t.j = f.j;
            t.S = f.S.slice();
            return t;
        }

    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
        function flatten(obj, depth) {
            var result = [], typ = (typeof obj), prop;
            if (depth && typ == 'object') {
                for (prop in obj) {
                    try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
                }
            }
            return (result.length ? result : typ == 'string' ? obj : obj + '\0');
        }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
        function mixkey(seed, key) {
            var stringseed = seed + '', smear, j = 0;
            while (j < stringseed.length) {
                key[mask & j] =
                    mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
            }
            return tostring(key);
        }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
        function autoseed() {
            try {
                if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }
                var out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
                return tostring(out);
            } catch (e) {
                var browser = global.navigator,
                    plugins = browser && browser.plugins;
                return [+new Date(), global, plugins, global.screen, tostring(pool)];
            }
        }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
        function tostring(a) {
            return String.fromCharCode.apply(0, a);
        }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
        mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //

    // End anonymous scope, and pass initial values.
    })(
        [],     // pool: entropy pool starts empty
        BMMath    // math: package containing random, pow, and seedrandom
    );
    var BezierFactory = (function(){
        /**
         * BezierEasing - use bezier curve for transition easing function
         * by Gaëtan Renaudeau 2014 - 2015 – MIT License
         *
         * Credits: is based on Firefox's nsSMILKeySpline.cpp
         * Usage:
         * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
         * spline.get(x) => returns the easing value | x must be in [0, 1] range
         *
         */

            var ob = {};
        ob.getBezierEasing = getBezierEasing;
        var beziers = {};

        function getBezierEasing(a,b,c,d,nm){
            var str = nm || ('bez_' + a+'_'+b+'_'+c+'_'+d).replace(/\./g, 'p');
            if(beziers[str]){
                return beziers[str];
            }
            var bezEasing = new BezierEasing([a,b,c,d]);
            beziers[str] = bezEasing;
            return bezEasing;
        }

    // These values are established by empiricism with tests (tradeoff: performance VS precision)
        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 0.001;
        var SUBDIVISION_PRECISION = 0.0000001;
        var SUBDIVISION_MAX_ITERATIONS = 10;

        var kSplineTableSize = 11;
        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

        var float32ArraySupported = typeof Float32Array === "function";

        function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
        function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
        function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
        function calcBezier (aT, aA1, aA2) {
            return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
        }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
        function getSlope (aT, aA1, aA2) {
            return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function binarySubdivide (aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i = 0;
            do {
                currentT = aA + (aB - aA) / 2.0;
                currentX = calcBezier(currentT, mX1, mX2) - aX;
                if (currentX > 0.0) {
                    aB = currentT;
                } else {
                    aA = currentT;
                }
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
        }

        function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
            for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
                var currentSlope = getSlope(aGuessT, mX1, mX2);
                if (currentSlope === 0.0) return aGuessT;
                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
                aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
        }

        /**
         * points is an array of [ mX1, mY1, mX2, mY2 ]
         */
        function BezierEasing (points) {
            this._p = points;
            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            this._precomputed = false;

            this.get = this.get.bind(this);
        }

        BezierEasing.prototype = {

            get: function (x) {
                var mX1 = this._p[0],
                    mY1 = this._p[1],
                    mX2 = this._p[2],
                    mY2 = this._p[3];
                if (!this._precomputed) this._precompute();
                if (mX1 === mY1 && mX2 === mY2) return x; // linear
                // Because JavaScript number are imprecise, we should guarantee the extremes are right.
                if (x === 0) return 0;
                if (x === 1) return 1;
                return calcBezier(this._getTForX(x), mY1, mY2);
            },

            // Private part

            _precompute: function () {
                var mX1 = this._p[0],
                    mY1 = this._p[1],
                    mX2 = this._p[2],
                    mY2 = this._p[3];
                this._precomputed = true;
                if (mX1 !== mY1 || mX2 !== mY2)
                    this._calcSampleValues();
            },

            _calcSampleValues: function () {
                var mX1 = this._p[0],
                    mX2 = this._p[2];
                for (var i = 0; i < kSplineTableSize; ++i) {
                    this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
                }
            },

            /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
            _getTForX: function (aX) {
                var mX1 = this._p[0],
                    mX2 = this._p[2],
                    mSampleValues = this._mSampleValues;

                var intervalStart = 0.0;
                var currentSample = 1;
                var lastSample = kSplineTableSize - 1;

                for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                    intervalStart += kSampleStepSize;
                }
                --currentSample;

                // Interpolate to provide an initial guess for t
                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
                var guessForT = intervalStart + dist * kSampleStepSize;

                var initialSlope = getSlope(guessForT, mX1, mX2);
                if (initialSlope >= NEWTON_MIN_SLOPE) {
                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
                } else if (initialSlope === 0.0) {
                    return guessForT;
                } else {
                    return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
                }
            }
        };

        return ob;

    }());
    (function () {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if(!window.requestAnimationFrame)
            window.requestAnimationFrame = function (callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = setTimeout(function () {
                        callback(currTime + timeToCall);
                    },
                    timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        if(!window.cancelAnimationFrame)
            window.cancelAnimationFrame = function (id) {
                clearTimeout(id);
            };
    }());

    function extendPrototype(sources,destination){
        var i, len = sources.length, sourcePrototype;
        for (i = 0;i < len;i += 1) {
            sourcePrototype = sources[i].prototype;
            for (var attr in sourcePrototype) {
                if (sourcePrototype.hasOwnProperty(attr)) destination.prototype[attr] = sourcePrototype[attr];
            }
        }
    }

    function getDescriptor(object, prop) {
        return Object.getOwnPropertyDescriptor(object, prop);
    }

    function createProxyFunction(prototype) {
    	function ProxyFunction(){}
    	ProxyFunction.prototype = prototype;
    	return ProxyFunction;
    }
    function bezFunction(){

        function pointOnLine2D(x1,y1, x2,y2, x3,y3){
            var det1 = (x1*y2) + (y1*x3) + (x2*y3) - (x3*y2) - (y3*x1) - (x2*y1);
            return det1 > -0.001 && det1 < 0.001;
        }

        function pointOnLine3D(x1,y1,z1, x2,y2,z2, x3,y3,z3){
            if(z1 === 0 && z2 === 0 && z3 === 0) {
                return pointOnLine2D(x1,y1, x2,y2, x3,y3);
            }
            var dist1 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));
            var dist2 = Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2) + Math.pow(z3 - z1, 2));
            var dist3 = Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2) + Math.pow(z3 - z2, 2));
            var diffDist;
            if(dist1 > dist2){
                if(dist1 > dist3){
                    diffDist = dist1 - dist2 - dist3;
                } else {
                    diffDist = dist3 - dist2 - dist1;
                }
            } else if(dist3 > dist2){
                diffDist = dist3 - dist2 - dist1;
            } else {
                diffDist = dist2 - dist1 - dist3;
            }
            return diffDist > -0.0001 && diffDist < 0.0001;
        }

        var getBezierLength = (function(){

            return function(pt1,pt2,pt3,pt4){
                var curveSegments = defaultCurveSegments;
                var k;
                var i, len;
                var ptCoord,perc,addedLength = 0;
                var ptDistance;
                var point = [],lastPoint = [];
                var lengthData = bezier_length_pool.newElement();
                len = pt3.length;
                for(k=0;k<curveSegments;k+=1){
                    perc = k/(curveSegments-1);
                    ptDistance = 0;
                    for(i=0;i<len;i+=1){
                        ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bm_pow(perc,2)*pt4[i]+bm_pow(perc,3)*pt2[i];
                        point[i] = ptCoord;
                        if(lastPoint[i] !== null){
                            ptDistance += bm_pow(point[i] - lastPoint[i],2);
                        }
                        lastPoint[i] = point[i];
                    }
                    if(ptDistance){
                        ptDistance = bm_sqrt(ptDistance);
                        addedLength += ptDistance;
                    }
                    lengthData.percents[k] = perc;
                    lengthData.lengths[k] = addedLength;
                }
                lengthData.addedLength = addedLength;
                return lengthData;
            };
        }());

        function getSegmentsLength(shapeData) {
            var segmentsLength = segments_length_pool.newElement();
            var closed = shapeData.c;
            var pathV = shapeData.v;
            var pathO = shapeData.o;
            var pathI = shapeData.i;
            var i, len = shapeData._length;
            var lengths = segmentsLength.lengths;
            var totalLength = 0;
            for(i=0;i<len-1;i+=1){
                lengths[i] = getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);
                totalLength += lengths[i].addedLength;
            }
            if(closed && len){
                lengths[i] = getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);
                totalLength += lengths[i].addedLength;
            }
            segmentsLength.totalLength = totalLength;
            return segmentsLength;
        }

        function BezierData(length){
            this.segmentLength = 0;
            this.points = new Array(length);
        }

        function PointData(partial,point){
            this.partialLength = partial;
            this.point = point;
        }

        var buildBezierData = (function(){

            var storedData = {};

            return function (pt1, pt2, pt3, pt4){
                var bezierName = (pt1[0]+'_'+pt1[1]+'_'+pt2[0]+'_'+pt2[1]+'_'+pt3[0]+'_'+pt3[1]+'_'+pt4[0]+'_'+pt4[1]).replace(/\./g, 'p');
                if(!storedData[bezierName]){
                    var curveSegments = defaultCurveSegments;
                    var k, i, len;
                    var ptCoord,perc,addedLength = 0;
                    var ptDistance;
                    var point,lastPoint = null;
                    if (pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){
                        curveSegments = 2;
                    }
                    var bezierData = new BezierData(curveSegments);
                    len = pt3.length;
                    for (k = 0; k < curveSegments; k += 1) {
                        point = createSizedArray(len);
                        perc = k / (curveSegments - 1);
                        ptDistance = 0;
                        for (i = 0; i < len; i += 1){
                            ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*(pt1[i] + pt3[i])+3*(1-perc)*bm_pow(perc,2)*(pt2[i] + pt4[i])+bm_pow(perc,3)*pt2[i];
                            point[i] = ptCoord;
                            if(lastPoint !== null){
                                ptDistance += bm_pow(point[i] - lastPoint[i],2);
                            }
                        }
                        ptDistance = bm_sqrt(ptDistance);
                        addedLength += ptDistance;
                        bezierData.points[k] = new PointData(ptDistance, point);
                        lastPoint = point;
                    }
                    bezierData.segmentLength = addedLength;
                    storedData[bezierName] = bezierData;
                }
                return storedData[bezierName];
            };
        }());

        function getDistancePerc(perc,bezierData){
            var percents = bezierData.percents;
            var lengths = bezierData.lengths;
            var len = percents.length;
            var initPos = bm_floor((len-1)*perc);
            var lengthPos = perc*bezierData.addedLength;
            var lPerc = 0;
            if(initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]){
                return percents[initPos];
            }else {
                var dir = lengths[initPos] > lengthPos ? -1 : 1;
                var flag = true;
                while(flag){
                    if(lengths[initPos] <= lengthPos && lengths[initPos+1] > lengthPos){
                        lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos+1] - lengths[initPos]);
                        flag = false;
                    }else {
                        initPos += dir;
                    }
                    if(initPos < 0 || initPos >= len - 1){
                        //FIX for TypedArrays that don't store floating point values with enough accuracy
                        if(initPos === len - 1) {
                            return percents[initPos];
                        }
                        flag = false;
                    }
                }
                return percents[initPos] + (percents[initPos+1] - percents[initPos])*lPerc;
            }
        }

        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
            var t1 = getDistancePerc(percent,bezierData);
            var u1 = 1 - t1;
            var ptX = Math.round((u1*u1*u1* pt1[0] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[0] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[0] + t1*t1*t1* pt2[0])* 1000) / 1000;
            var ptY = Math.round((u1*u1*u1* pt1[1] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[1] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[1] + t1*t1*t1* pt2[1])* 1000) / 1000;
            return [ptX, ptY];
        }

        var bezier_segment_points = createTypedArray('float32', 8);

        function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc, bezierData){

            startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;
            var t0 = getDistancePerc(startPerc,bezierData);
            endPerc = endPerc > 1 ? 1 : endPerc;
            var t1 = getDistancePerc(endPerc,bezierData);
            var i, len = pt1.length;
            var u0 = 1 - t0;
            var u1 = 1 - t1;
            var u0u0u0 = u0*u0*u0;
            var t0u0u0_3 = t0*u0*u0*3;
            var t0t0u0_3 = t0*t0*u0*3;
            var t0t0t0 = t0*t0*t0;
            //
            var u0u0u1 = u0*u0*u1;
            var t0u0u1_3 = t0*u0*u1 + u0*t0*u1 + u0*u0*t1;
            var t0t0u1_3 = t0*t0*u1 + u0*t0*t1 + t0*u0*t1;
            var t0t0t1 = t0*t0*t1;
            //
            var u0u1u1 = u0*u1*u1;
            var t0u1u1_3 = t0*u1*u1 + u0*t1*u1 + u0*u1*t1;
            var t0t1u1_3 = t0*t1*u1 + u0*t1*t1 + t0*u1*t1;
            var t0t1t1 = t0*t1*t1;
            //
            var u1u1u1 = u1*u1*u1;
            var t1u1u1_3 = t1*u1*u1 + u1*t1*u1 + u1*u1*t1;
            var t1t1u1_3 = t1*t1*u1 + u1*t1*t1 + t1*u1*t1;
            var t1t1t1 = t1*t1*t1;
            for(i=0;i<len;i+=1){
                bezier_segment_points[i * 4] = Math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000;
                bezier_segment_points[i * 4 + 1] = Math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000;
                bezier_segment_points[i * 4 + 2] = Math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000;
                bezier_segment_points[i * 4 + 3] = Math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000;
            }

            return bezier_segment_points;
        }

        return {
            getSegmentsLength : getSegmentsLength,
            getNewSegment : getNewSegment,
            getPointInSegment : getPointInSegment,
            buildBezierData : buildBezierData,
            pointOnLine2D : pointOnLine2D,
            pointOnLine3D : pointOnLine3D
        };
    }

    var bez = bezFunction();
    function dataFunctionManager(){

        //var tCanvasHelper = createTag('canvas').getContext('2d');

        function completeLayers(layers, comps, fontManager){
            var layerData;
            var i, len = layers.length;
            var j, jLen, k, kLen;
            for(i=0;i<len;i+=1){
                layerData = layers[i];
                if(!('ks' in layerData) || layerData.completed){
                    continue;
                }
                layerData.completed = true;
                if(layerData.tt){
                    layers[i-1].td = layerData.tt;
                }
                if(layerData.hasMask){
                    var maskProps = layerData.masksProperties;
                    jLen = maskProps.length;
                    for(j=0;j<jLen;j+=1){
                        if(maskProps[j].pt.k.i){
                            convertPathsToAbsoluteValues(maskProps[j].pt.k);
                        }else {
                            kLen = maskProps[j].pt.k.length;
                            for(k=0;k<kLen;k+=1){
                                if(maskProps[j].pt.k[k].s){
                                    convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                                }
                                if(maskProps[j].pt.k[k].e){
                                    convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                                }
                            }
                        }
                    }
                }
                if(layerData.ty===0){
                    layerData.layers = findCompLayers(layerData.refId, comps);
                    completeLayers(layerData.layers,comps);
                }else if(layerData.ty === 4){
                    completeShapes(layerData.shapes);
                }else if(layerData.ty == 5){
                    completeText(layerData);
                }
            }
        }

        function findCompLayers(id,comps){
            var i = 0, len = comps.length;
            while(i<len){
                if(comps[i].id === id){
                    if(!comps[i].layers.__used) {
                        comps[i].layers.__used = true;
                        return comps[i].layers;
                    }
                    return JSON.parse(JSON.stringify(comps[i].layers));
                }
                i += 1;
            }
        }

        function completeShapes(arr){
            var i, len = arr.length;
            var j, jLen;
            for(i=len-1;i>=0;i-=1){
                if(arr[i].ty == 'sh'){
                    if(arr[i].ks.k.i){
                        convertPathsToAbsoluteValues(arr[i].ks.k);
                    }else {
                        jLen = arr[i].ks.k.length;
                        for(j=0;j<jLen;j+=1){
                            if(arr[i].ks.k[j].s){
                                convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                            }
                            if(arr[i].ks.k[j].e){
                                convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                            }
                        }
                    }
                }else if(arr[i].ty == 'gr'){
                    completeShapes(arr[i].it);
                }
            }
            /*if(hasPaths){
                //mx: distance
                //ss: sensitivity
                //dc: decay
                arr.splice(arr.length-1,0,{
                    "ty": "ms",
                    "mx":20,
                    "ss":10,
                     "dc":0.001,
                    "maxDist":200
                });
            }*/
        }

        function convertPathsToAbsoluteValues(path){
            var i, len = path.i.length;
            for(i=0;i<len;i+=1){
                path.i[i][0] += path.v[i][0];
                path.i[i][1] += path.v[i][1];
                path.o[i][0] += path.v[i][0];
                path.o[i][1] += path.v[i][1];
            }
        }

        function checkVersion(minimum,animVersionString){
            var animVersion = animVersionString ? animVersionString.split('.') : [100,100,100];
            if(minimum[0]>animVersion[0]){
                return true;
            } else if(animVersion[0] > minimum[0]){
                return false;
            }
            if(minimum[1]>animVersion[1]){
                return true;
            } else if(animVersion[1] > minimum[1]){
                return false;
            }
            if(minimum[2]>animVersion[2]){
                return true;
            } else if(animVersion[2] > minimum[2]){
                return false;
            }
        }

        var checkText = (function(){
            var minimumVersion = [4,4,14];

            function updateTextLayer(textLayer){
                var documentData = textLayer.t.d;
                textLayer.t.d = {
                    k: [
                        {
                            s:documentData,
                            t:0
                        }
                    ]
                };
            }

            function iterateLayers(layers){
                var i, len = layers.length;
                for(i=0;i<len;i+=1){
                    if(layers[i].ty === 5){
                        updateTextLayer(layers[i]);
                    }
                }
            }

            return function (animationData){
                if(checkVersion(minimumVersion,animationData.v)){
                    iterateLayers(animationData.layers);
                    if(animationData.assets){
                        var i, len = animationData.assets.length;
                        for(i=0;i<len;i+=1){
                            if(animationData.assets[i].layers){
                                iterateLayers(animationData.assets[i].layers);

                            }
                        }
                    }
                }
            };
        }());

        var checkChars = (function() {
            var minimumVersion = [4,7,99];
            return function (animationData){
                if(animationData.chars && !checkVersion(minimumVersion,animationData.v)){
                    var i, len = animationData.chars.length, j, jLen;
                    var pathData, paths;
                    for(i = 0; i < len; i += 1) {
                        if(animationData.chars[i].data && animationData.chars[i].data.shapes) {
                            paths = animationData.chars[i].data.shapes[0].it;
                            jLen = paths.length;

                            for(j = 0; j < jLen; j += 1) {
                                pathData = paths[j].ks.k;
                                if(!pathData.__converted) {
                                    convertPathsToAbsoluteValues(paths[j].ks.k);
                                    pathData.__converted = true;
                                }
                            }
                        }
                    }
                }
            };
        }());

        var checkColors = (function(){
            var minimumVersion = [4,1,9];

            function iterateShapes(shapes){
                var i, len = shapes.length;
                var j, jLen;
                for(i=0;i<len;i+=1){
                    if(shapes[i].ty === 'gr'){
                        iterateShapes(shapes[i].it);
                    }else if(shapes[i].ty === 'fl' || shapes[i].ty === 'st'){
                        if(shapes[i].c.k && shapes[i].c.k[0].i){
                            jLen = shapes[i].c.k.length;
                            for(j=0;j<jLen;j+=1){
                                if(shapes[i].c.k[j].s){
                                    shapes[i].c.k[j].s[0] /= 255;
                                    shapes[i].c.k[j].s[1] /= 255;
                                    shapes[i].c.k[j].s[2] /= 255;
                                    shapes[i].c.k[j].s[3] /= 255;
                                }
                                if(shapes[i].c.k[j].e){
                                    shapes[i].c.k[j].e[0] /= 255;
                                    shapes[i].c.k[j].e[1] /= 255;
                                    shapes[i].c.k[j].e[2] /= 255;
                                    shapes[i].c.k[j].e[3] /= 255;
                                }
                            }
                        } else {
                            shapes[i].c.k[0] /= 255;
                            shapes[i].c.k[1] /= 255;
                            shapes[i].c.k[2] /= 255;
                            shapes[i].c.k[3] /= 255;
                        }
                    }
                }
            }

            function iterateLayers(layers){
                var i, len = layers.length;
                for(i=0;i<len;i+=1){
                    if(layers[i].ty === 4){
                        iterateShapes(layers[i].shapes);
                    }
                }
            }

            return function (animationData){
                if(checkVersion(minimumVersion,animationData.v)){
                    iterateLayers(animationData.layers);
                    if(animationData.assets){
                        var i, len = animationData.assets.length;
                        for(i=0;i<len;i+=1){
                            if(animationData.assets[i].layers){
                                iterateLayers(animationData.assets[i].layers);

                            }
                        }
                    }
                }
            };
        }());

        var checkShapes = (function(){
            var minimumVersion = [4,4,18];



            function completeShapes(arr){
                var i, len = arr.length;
                var j, jLen;
                for(i=len-1;i>=0;i-=1){
                    if(arr[i].ty == 'sh'){
                        if(arr[i].ks.k.i){
                            arr[i].ks.k.c = arr[i].closed;
                        }else {
                            jLen = arr[i].ks.k.length;
                            for(j=0;j<jLen;j+=1){
                                if(arr[i].ks.k[j].s){
                                    arr[i].ks.k[j].s[0].c = arr[i].closed;
                                }
                                if(arr[i].ks.k[j].e){
                                    arr[i].ks.k[j].e[0].c = arr[i].closed;
                                }
                            }
                        }
                    }else if(arr[i].ty == 'gr'){
                        completeShapes(arr[i].it);
                    }
                }
            }

            function iterateLayers(layers){
                var layerData;
                var i, len = layers.length;
                var j, jLen, k, kLen;
                for(i=0;i<len;i+=1){
                    layerData = layers[i];
                    if(layerData.hasMask){
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;
                        for(j=0;j<jLen;j+=1){
                            if(maskProps[j].pt.k.i){
                                maskProps[j].pt.k.c = maskProps[j].cl;
                            }else {
                                kLen = maskProps[j].pt.k.length;
                                for(k=0;k<kLen;k+=1){
                                    if(maskProps[j].pt.k[k].s){
                                        maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                                    }
                                    if(maskProps[j].pt.k[k].e){
                                        maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                                    }
                                }
                            }
                        }
                    }
                    if(layerData.ty === 4){
                        completeShapes(layerData.shapes);
                    }
                }
            }

            return function (animationData){
                if(checkVersion(minimumVersion,animationData.v)){
                    iterateLayers(animationData.layers);
                    if(animationData.assets){
                        var i, len = animationData.assets.length;
                        for(i=0;i<len;i+=1){
                            if(animationData.assets[i].layers){
                                iterateLayers(animationData.assets[i].layers);

                            }
                        }
                    }
                }
            };
        }());

        function completeData(animationData, fontManager){
            if(animationData.__complete){
                return;
            }
            checkColors(animationData);
            checkText(animationData);
            checkChars(animationData);
            checkShapes(animationData);
            completeLayers(animationData.layers, animationData.assets);
            animationData.__complete = true;
            //blitAnimation(animationData, animationData.assets, fontManager);
        }

        function completeText(data, fontManager){
            if(data.t.a.length === 0 && !('m' in data.t.p)){
                data.singleShape = true;
            }
        }

        var moduleOb = {};
        moduleOb.completeData = completeData;
        moduleOb.checkColors = checkColors;
        moduleOb.checkChars = checkChars;
        moduleOb.checkShapes = checkShapes;
        moduleOb.completeLayers = completeLayers;

        return moduleOb;
    }

    var dataManager = dataFunctionManager();

    var FontManager = (function(){

        var maxWaitingTime = 5000;
        var emptyChar = {
            w: 0,
            size:0,
            shapes:[]
        };
        var combinedCharacters = [];
        //Hindi characters
        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366
        , 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379
        , 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

        function trimFontOptions(font) {
            var familyArray = font.split(',');
            var i, len = familyArray.length;
            var enabledFamilies = [];
            for (i = 0; i < len; i += 1) {
                if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
                    enabledFamilies.push(familyArray[i]);
                }
            }
            return enabledFamilies.join(',');
        }

        function setUpNode(font, family){
            var parentNode = createTag('span');
            parentNode.style.fontFamily    = family;
            var node = createTag('span');
            // Characters that vary significantly among different fonts
            node.innerHTML = 'giItT1WQy@!-/#';
            // Visible - so we can measure it - but not on the screen
            parentNode.style.position      = 'absolute';
            parentNode.style.left          = '-10000px';
            parentNode.style.top           = '-10000px';
            // Large font size makes even subtle changes obvious
            parentNode.style.fontSize      = '300px';
            // Reset any font properties
            parentNode.style.fontVariant   = 'normal';
            parentNode.style.fontStyle     = 'normal';
            parentNode.style.fontWeight    = 'normal';
            parentNode.style.letterSpacing = '0';
            parentNode.appendChild(node);
            document.body.appendChild(parentNode);

            // Remember width with no applied web font
            var width = node.offsetWidth;
            node.style.fontFamily = trimFontOptions(font) + ', ' + family;
            return {node:node, w:width, parent:parentNode};
        }

        function checkLoadedFonts() {
            var i, len = this.fonts.length;
            var node, w;
            var loadedCount = len;
            for(i=0;i<len; i+= 1){
                if(this.fonts[i].loaded){
                    loadedCount -= 1;
                    continue;
                }
                if(this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0){
                    this.fonts[i].loaded = true;
                } else {
                    node = this.fonts[i].monoCase.node;
                    w = this.fonts[i].monoCase.w;
                    if(node.offsetWidth !== w){
                        loadedCount -= 1;
                        this.fonts[i].loaded = true;
                    }else {
                        node = this.fonts[i].sansCase.node;
                        w = this.fonts[i].sansCase.w;
                        if(node.offsetWidth !== w){
                            loadedCount -= 1;
                            this.fonts[i].loaded = true;
                        }
                    }
                    if(this.fonts[i].loaded){
                        this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                        this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
                    }
                }
            }

            if(loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime){
                setTimeout(this.checkLoadedFontsBinded, 20);
            }else {
                setTimeout(this.setIsLoadedBinded, 10);

            }
        }

        function createHelper(def, fontData){
            var tHelper = createNS('text');
            tHelper.style.fontSize = '100px';
            //tHelper.style.fontFamily = fontData.fFamily;
            tHelper.setAttribute('font-family', fontData.fFamily);
            tHelper.setAttribute('font-style', fontData.fStyle);
            tHelper.setAttribute('font-weight', fontData.fWeight);
            tHelper.textContent = '1';
            if(fontData.fClass){
                tHelper.style.fontFamily = 'inherit';
                tHelper.setAttribute('class', fontData.fClass);
            } else {
                tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            var tCanvasHelper = createTag('canvas').getContext('2d');
            tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px '+ fontData.fFamily;
            //tCanvasHelper.font = ' 100px '+ fontData.fFamily;
            return tHelper;
        }

        function addFonts(fontData, defs){
            if(!fontData){
                this.isLoaded = true;
                return;
            }
            if(this.chars){
                this.isLoaded = true;
                this.fonts = fontData.list;
                return;
            }


            var fontArr = fontData.list;
            var i, len = fontArr.length;
            var _pendingFonts = len;
            for(i=0; i<len; i+= 1){
                var shouldLoadFont = true;
                var loadedSelector;
                var j;
                fontArr[i].loaded = false;
                fontArr[i].monoCase = setUpNode(fontArr[i].fFamily,'monospace');
                fontArr[i].sansCase = setUpNode(fontArr[i].fFamily,'sans-serif');
                if(!fontArr[i].fPath) {
                    fontArr[i].loaded = true;
                    _pendingFonts -= 1;
                }else if(fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3){
                    loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="'+ fontArr[i].fFamily +'"], style[f-origin="3"][f-family="'+ fontArr[i].fFamily +'"]');

                    if (loadedSelector.length > 0) {
                        shouldLoadFont = false;
                    }

                    if (shouldLoadFont) {
                        var s = createTag('style');
                        s.setAttribute('f-forigin', fontArr[i].fOrigin);
                        s.setAttribute('f-origin', fontArr[i].origin);
                        s.setAttribute('f-family', fontArr[i].fFamily);
                        s.type = "text/css";
                        s.innerHTML = "@font-face {" + "font-family: "+fontArr[i].fFamily+"; font-style: normal; src: url('"+fontArr[i].fPath+"');}";
                        defs.appendChild(s);
                    }
                } else if(fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1){
                    loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

                    for (j = 0; j < loadedSelector.length; j++) {
                        if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                            // Font is already loaded
                            shouldLoadFont = false;
                        }
                    }

                    if (shouldLoadFont) {
                        var l = createTag('link');
                        l.setAttribute('f-forigin', fontArr[i].fOrigin);
                        l.setAttribute('f-origin', fontArr[i].origin);
                        l.type = "text/css";
                        l.rel = "stylesheet";
                        l.href = fontArr[i].fPath;
                        document.body.appendChild(l);
                    }
                } else if(fontArr[i].fOrigin === 't' || fontArr[i].origin === 2){
                    loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

                    for (j = 0; j < loadedSelector.length; j++) {
                        if (fontArr[i].fPath === loadedSelector[j].src) {
                            // Font is already loaded
                            shouldLoadFont = false;
                        }
                    }

                    if (shouldLoadFont) {
                        var sc = createTag('link');
                        sc.setAttribute('f-forigin', fontArr[i].fOrigin);
                        sc.setAttribute('f-origin', fontArr[i].origin);
                        sc.setAttribute('rel','stylesheet');
                        sc.setAttribute('href',fontArr[i].fPath);
                        defs.appendChild(sc);
                    }
                }
                fontArr[i].helper = createHelper(defs,fontArr[i]);
                fontArr[i].cache = {};
                this.fonts.push(fontArr[i]);
            }
            if (_pendingFonts === 0) {
                this.isLoaded = true;
            } else {
                //On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
                //Adding this timeout seems to fix it
               setTimeout(this.checkLoadedFonts.bind(this), 100);
            }
        }

        function addChars(chars){
            if(!chars){
                return;
            }
            if(!this.chars){
                this.chars = [];
            }
            var i, len = chars.length;
            var j, jLen = this.chars.length, found;
            for(i=0;i<len;i+=1){
                j = 0;
                found = false;
                while(j<jLen){
                    if(this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch){
                        found = true;
                    }
                    j += 1;
                }
                if(!found){
                    this.chars.push(chars[i]);
                    jLen += 1;
                }
            }
        }

        function getCharData(char, style, font){
            var i = 0, len = this.chars.length;
            while( i < len) {
                if(this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font){

                    return this.chars[i];
                }
                i+= 1;
            }
            if((typeof char === 'string' && char.charCodeAt(0) !== 13 || !char) && console && console.warn) {
                console.warn('Missing character from exported characters list: ', char, style, font);
            }
            return emptyChar;
        }

        function measureText(char, fontName, size) {
            var fontData = this.getFontByName(fontName);
            var index = char.charCodeAt(0);
            if(!fontData.cache[index + 1]) {
                var tHelper = fontData.helper;
                //Canvas version
                //fontData.cache[index] = tHelper.measureText(char).width / 100;
                //SVG version
                //console.log(tHelper.getBBox().width)
                if (char === ' ') {
                    tHelper.textContent = '|' + char + '|';
                    var doubleSize = tHelper.getComputedTextLength();
                    tHelper.textContent = '||';
                    var singleSize = tHelper.getComputedTextLength();
                    fontData.cache[index + 1] = (doubleSize - singleSize)/100;
                } else {
                    tHelper.textContent = char;
                    fontData.cache[index + 1] = (tHelper.getComputedTextLength())/100;
                }
            }
            return fontData.cache[index + 1] * size;
        }

        function getFontByName(name){
            var i = 0, len = this.fonts.length;
            while(i<len){
                if(this.fonts[i].fName === name) {
                    return this.fonts[i];
                }
                i += 1;
            }
            return this.fonts[0];
        }

        function getCombinedCharacterCodes() {
            return combinedCharacters;
        }

        function setIsLoaded() {
            this.isLoaded = true;
        }

        var Font = function(){
            this.fonts = [];
            this.chars = null;
            this.typekitLoaded = 0;
            this.isLoaded = false;
            this.initTime = Date.now();
            this.setIsLoadedBinded = this.setIsLoaded.bind(this);
            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };
        //TODO: for now I'm adding these methods to the Class and not the prototype. Think of a better way to implement it. 
        Font.getCombinedCharacterCodes = getCombinedCharacterCodes;

        var fontPrototype = {
            addChars: addChars,
            addFonts: addFonts,
            getCharData: getCharData,
            getFontByName: getFontByName,
            measureText: measureText,
            checkLoadedFonts: checkLoadedFonts,
            setIsLoaded: setIsLoaded,
        };

        Font.prototype = fontPrototype;

        return Font;

    }());
    var PropertyFactory = (function(){

        var initFrame = initialDefaultFrame;
        var math_abs = Math.abs;

        function interpolateValue(frameNum, caching) {
            var offsetTime = this.offsetTime;
            var newValue;
            if (this.propType === 'multidimensional') {
                newValue = createTypedArray('float32', this.pv.length);
            }
            var iterationIndex = caching.lastIndex;
            var i = iterationIndex;
            var len = this.keyframes.length - 1, flag = true;
            var keyData, nextKeyData;

            while (flag) {
                keyData = this.keyframes[i];
                nextKeyData = this.keyframes[i + 1];
                if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime){
                    if(keyData.h){
                        keyData = nextKeyData;
                    }
                    iterationIndex = 0;
                    break;
                }
                if ((nextKeyData.t - offsetTime) > frameNum){
                    iterationIndex = i;
                    break;
                }
                if (i < len - 1){
                    i += 1;
                } else {
                    iterationIndex = 0;
                    flag = false;
                }
            }

            var k, kLen, perc, jLen, j, fnc;
            var nextKeyTime = nextKeyData.t - offsetTime;
            var keyTime = keyData.t - offsetTime;
            var endValue;
            if (keyData.to) {
                if (!keyData.bezierData) {
                    keyData.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
                }
                var bezierData = keyData.bezierData;
                if (frameNum >= nextKeyTime || frameNum < keyTime) {
                    var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                    kLen = bezierData.points[ind].point.length;
                    for (k = 0; k < kLen; k += 1) {
                        newValue[k] = bezierData.points[ind].point[k];
                    }
                    // caching._lastKeyframeIndex = -1;
                } else {
                    if (keyData.__fnct) {
                        fnc = keyData.__fnct;
                    } else {
                        fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                        keyData.__fnct = fnc;
                    }
                    perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                    var distanceInLine = bezierData.segmentLength*perc;

                    var segmentPerc;
                    var addedLength =  (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
                    j =  (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
                    flag = true;
                    jLen = bezierData.points.length;
                    while (flag) {
                        addedLength += bezierData.points[j].partialLength;
                        if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                            kLen = bezierData.points[j].point.length;
                            for (k = 0; k < kLen; k += 1) {
                                newValue[k] = bezierData.points[j].point[k];
                            }
                            break;
                        } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                            segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                            kLen = bezierData.points[j].point.length;
                            for (k = 0; k < kLen; k += 1) {
                                newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                            }
                            break;
                        }
                        if (j < jLen - 1){
                            j += 1;
                        } else {
                            flag = false;
                        }
                    }
                    caching._lastPoint = j;
                    caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
                    caching._lastKeyframeIndex = i;
                }
            } else {
                var outX, outY, inX, inY, keyValue;
                len = keyData.s.length;
                endValue = nextKeyData.s || keyData.e;
                if (this.sh && keyData.h !== 1) {
                    if (frameNum >= nextKeyTime) {
                        newValue[0] = endValue[0];
                        newValue[1] = endValue[1];
                        newValue[2] = endValue[2];
                    } else if (frameNum <= keyTime) {
                        newValue[0] = keyData.s[0];
                        newValue[1] = keyData.s[1];
                        newValue[2] = keyData.s[2];
                    } else {
                        var quatStart = createQuaternion(keyData.s);
                        var quatEnd = createQuaternion(endValue);
                        var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                        quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                    }
                    
                } else {
                    for(i = 0; i < len; i += 1) {
                        if (keyData.h !== 1) {
                            if (frameNum >= nextKeyTime) {
                                perc = 1;
                            } else if(frameNum < keyTime) {
                                perc = 0;
                            } else {
                                if(keyData.o.x.constructor === Array) {
                                    if (!keyData.__fnct) {
                                        keyData.__fnct = [];
                                    }
                                    if (!keyData.__fnct[i]) {
                                        outX = (typeof keyData.o.x[i] === 'undefined') ? keyData.o.x[0] : keyData.o.x[i];
                                        outY = (typeof keyData.o.y[i] === 'undefined') ? keyData.o.y[0] : keyData.o.y[i];
                                        inX = (typeof keyData.i.x[i] === 'undefined') ? keyData.i.x[0] : keyData.i.x[i];
                                        inY = (typeof keyData.i.y[i] === 'undefined') ? keyData.i.y[0] : keyData.i.y[i];
                                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                        keyData.__fnct[i] = fnc;
                                    } else {
                                        fnc = keyData.__fnct[i];
                                    }
                                } else {
                                    if (!keyData.__fnct) {
                                        outX = keyData.o.x;
                                        outY = keyData.o.y;
                                        inX = keyData.i.x;
                                        inY = keyData.i.y;
                                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                                        keyData.__fnct = fnc;
                                    } else {
                                        fnc = keyData.__fnct;
                                    }
                                }
                                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime ));
                            }
                        }

                        endValue = nextKeyData.s || keyData.e;
                        keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

                        if (this.propType === 'multidimensional') {
                            newValue[i] = keyValue;
                        } else {
                            newValue = keyValue;
                        }
                    }
                }
            }
            caching.lastIndex = iterationIndex;
            return newValue;
        }

        //based on @Toji's https://github.com/toji/gl-matrix/
        function slerp(a, b, t) {
            var out = [];
            var ax = a[0], ay = a[1], az = a[2], aw = a[3],
            bx = b[0], by = b[1], bz = b[2], bw = b[3];

            var omega, cosom, sinom, scale0, scale1;

            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            } else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[0] = scale0 * ax + scale1 * bx;
            out[1] = scale0 * ay + scale1 * by;
            out[2] = scale0 * az + scale1 * bz;
            out[3] = scale0 * aw + scale1 * bw;

            return out;
        }

        function quaternionToEuler(out, quat) {
            var qx = quat[0];
            var qy = quat[1];
            var qz = quat[2];
            var qw = quat[3];
            var heading = Math.atan2(2*qy*qw-2*qx*qz , 1 - 2*qy*qy - 2*qz*qz);
            var attitude = Math.asin(2*qx*qy + 2*qz*qw); 
            var bank = Math.atan2(2*qx*qw-2*qy*qz , 1 - 2*qx*qx - 2*qz*qz);
            out[0] = heading/degToRads;
            out[1] = attitude/degToRads;
            out[2] = bank/degToRads;
        }

        function createQuaternion(values) {
            var heading = values[0] * degToRads;
            var attitude = values[1] * degToRads;
            var bank = values[2] * degToRads;
            var c1 = Math.cos(heading / 2);
            var c2 = Math.cos(attitude / 2);
            var c3 = Math.cos(bank / 2);
            var s1 = Math.sin(heading / 2);
            var s2 = Math.sin(attitude / 2);
            var s3 = Math.sin(bank / 2);
            var w = c1 * c2 * c3 - s1 * s2 * s3;
            var x = s1 * s2 * c3 + c1 * c2 * s3;
            var y = s1 * c2 * c3 + c1 * s2 * s3;
            var z = c1 * s2 * c3 - s1 * c2 * s3;

            return [x,y,z,w];
        }

        function getValueAtCurrentTime(){
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length- 1].t-this.offsetTime;
            if(!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))){
                if(this._caching.lastFrame >= frameNum) {
                    this._caching._lastKeyframeIndex = -1;
                    this._caching.lastIndex = 0;
                }

                var renderResult = this.interpolateValue(frameNum, this._caching);
                this.pv = renderResult;
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
        }

        function setVValue(val) {
            var multipliedValue;
            if(this.propType === 'unidimensional') {
                multipliedValue = val * this.mult;
                if(math_abs(this.v - multipliedValue) > 0.00001) {
                    this.v = multipliedValue;
                    this._mdf = true;
                }
            } else {
                var i = 0, len = this.v.length;
                while (i < len) {
                    multipliedValue = val[i] * this.mult;
                    if (math_abs(this.v[i] - multipliedValue) > 0.00001) {
                        this.v[i] = multipliedValue;
                        this._mdf = true;
                    }
                    i += 1;
                }
            }
        }

        function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
                return;
            }
            if(this.lock) {
                this.setVValue(this.pv);
                return;
            }
            this.lock = true;
            this._mdf = this._isFirstFrame;
            var i, len = this.effectsSequence.length;
            var finalValue = this.kf ? this.pv : this.data.k;
            for(i = 0; i < len; i += 1) {
                finalValue = this.effectsSequence[i](finalValue);
            }
            this.setVValue(finalValue);
            this._isFirstFrame = false;
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
        }

        function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
        }

        function ValueProperty(elem, data, mult, container){
            this.propType = 'unidimensional';
            this.mult = mult || 1;
            this.data = data;
            this.v = mult ? data.k * mult : data.k;
            this.pv = data.k;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.vel = 0;
            this.effectsSequence = [];
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
        }

        function MultiDimensionalProperty(elem, data, mult, container) {
            this.propType = 'multidimensional';
            this.mult = mult || 1;
            this.data = data;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.frameId = -1;
            var i, len = data.k.length;
            this.v = createTypedArray('float32', len);
            this.pv = createTypedArray('float32', len);
            var arr = createTypedArray('float32', len);
            this.vel = createTypedArray('float32', len);
            for (i = 0; i < len; i += 1) {
                this.v[i] = data.k[i] * this.mult;
                this.pv[i] = data.k[i];
            }
            this._isFirstFrame = true;
            this.effectsSequence = [];
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
        }

        function KeyframedValueProperty(elem, data, mult, container) {
            this.propType = 'unidimensional';
            this.keyframes = data.k;
            this.offsetTime = elem.data.st;
            this.frameId = -1;
            this._caching = {lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1};
            this.k = true;
            this.kf = true;
            this.data = data;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.v = initFrame;
            this.pv = initFrame;
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.effectsSequence = [getValueAtCurrentTime.bind(this)];
            this.addEffect = addEffect;
        }

        function KeyframedMultidimensionalProperty(elem, data, mult, container){
            this.propType = 'multidimensional';
            var i, len = data.k.length;
            var s, e,to,ti;
            for (i = 0; i < len - 1; i += 1) {
                if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
                    s = data.k[i].s;
                    e = data.k[i + 1].s;
                    to = data.k[i].to;
                    ti = data.k[i].ti;
                    if((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0] + to[0],s[1] + to[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0] + ti[0],e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0] + to[0],s[1] + to[1],s[2] + to[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0] + ti[0],e[1] + ti[1],e[2] + ti[2]))){
                        data.k[i].to = null;
                        data.k[i].ti = null;
                    }
                    if(s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                        if(s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
                            data.k[i].to = null;
                            data.k[i].ti = null;
                        }
                    }
                }
            }
            this.effectsSequence = [getValueAtCurrentTime.bind(this)];
            this.keyframes = data.k;
            this.offsetTime = elem.data.st;
            this.k = true;
            this.kf = true;
            this._isFirstFrame = true;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.frameId = -1;
            var arrLen = data.k[0].s.length;
            this.v = createTypedArray('float32', arrLen);
            this.pv = createTypedArray('float32', arrLen);
            for (i = 0; i < arrLen; i += 1) {
                this.v[i] = initFrame;
                this.pv[i] = initFrame;
            }
            this._caching={lastFrame:initFrame,lastIndex:0,value:createTypedArray('float32', arrLen)};
            this.addEffect = addEffect;
        }

        function getProp(elem,data,type, mult, container) {
            var p;
            if(!data.k.length){
                p = new ValueProperty(elem,data, mult, container);
            }else if(typeof(data.k[0]) === 'number'){
                p = new MultiDimensionalProperty(elem,data, mult, container);
            }else {
                switch(type){
                    case 0:
                        p = new KeyframedValueProperty(elem,data,mult, container);
                        break;
                    case 1:
                        p = new KeyframedMultidimensionalProperty(elem,data,mult, container);
                        break;
                }
            }
            if(p.effectsSequence.length){
                container.addDynamicProperty(p);
            }
            return p;
        }

        var ob = {
            getProp: getProp
        };
        return ob;
    }());
    var TransformPropertyFactory = (function() {

        var defaultVector = [0,0];

        function applyToMatrix(mat) {
            var _mdf = this._mdf;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || _mdf;
            if (this.a) {
                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.s) {
                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk) {
                mat.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r) {
                mat.rotate(-this.r.v);
            } else {
                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.data.p.s) {
                if (this.data.p.z) {
                    mat.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                    mat.translate(this.px.v, this.py.v, 0);
                }
            } else {
                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
        }
        function processKeys(forceRender){
            if (this.elem.globalData.frameId === this.frameId) {
                return;
            }
            if(this._isDirty) {
                this.precalculateMatrix();
                this._isDirty = false;
            }

            this.iterateDynamicProperties();

            if (this._mdf || forceRender) {
                this.v.cloneFromProps(this.pre.props);
                if (this.appliedTransformations < 1) {
                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                }
                if(this.appliedTransformations < 2) {
                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                }
                if (this.sk && this.appliedTransformations < 3) {
                    this.v.skewFromAxis(-this.sk.v, this.sa.v);
                }
                if (this.r && this.appliedTransformations < 4) {
                    this.v.rotate(-this.r.v);
                } else if (!this.r && this.appliedTransformations < 4){
                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                }
                if (this.autoOriented) {
                    var v1,v2, frameRate = this.elem.globalData.frameRate;
                    if(this.p && this.p.keyframes && this.p.getValueAtTime) {
                        if (this.p._caching.lastFrame+this.p.offsetTime <= this.p.keyframes[0].t) {
                            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate,0);
                            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                        } else if(this.p._caching.lastFrame+this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                            v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
                            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                        } else {
                            v1 = this.p.pv;
                            v2 = this.p.getValueAtTime((this.p._caching.lastFrame+this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                        }
                    } else if(this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                        v1 = [];
                        v2 = [];
                        var px = this.px, py = this.py, frameRate;
                        if (px._caching.lastFrame+px.offsetTime <= px.keyframes[0].t) {
                            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate,0);
                            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate,0);
                            v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate,0);
                            v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate,0);
                        } else if(px._caching.lastFrame+px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                            v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate),0);
                            v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate),0);
                            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate,0);
                            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate,0);
                        } else {
                            v1 = [px.pv, py.pv];
                            v2[0] = px.getValueAtTime((px._caching.lastFrame+px.offsetTime - 0.01) / frameRate,px.offsetTime);
                            v2[1] = py.getValueAtTime((py._caching.lastFrame+py.offsetTime - 0.01) / frameRate,py.offsetTime);
                        }
                    } else {
                        v1 = v2 = defaultVector;
                    }
                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
                }
                if(this.data.p && this.data.p.s){
                    if(this.data.p.z) {
                        this.v.translate(this.px.v, this.py.v, -this.pz.v);
                    } else {
                        this.v.translate(this.px.v, this.py.v, 0);
                    }
                }else {
                    this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);
                }
            }
            this.frameId = this.elem.globalData.frameId;
        }

        function precalculateMatrix() {
            if(!this.a.k) {
                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
                this.appliedTransformations = 1;
            } else {
                return;
            }
            if(!this.s.effectsSequence.length) {
                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
                this.appliedTransformations = 2;
            } else {
                return;
            }
            if(this.sk) {
                if(!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                this.appliedTransformations = 3;
                } else {
                    return;
                }
            }
            if (this.r) {
                if(!this.r.effectsSequence.length) {
                    this.pre.rotate(-this.r.v);
                    this.appliedTransformations = 4;
                } else {
                    return;
                }
            } else if(!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
                this.appliedTransformations = 4;
            }
        }

        function autoOrient(){
            //
            //var prevP = this.getValueAtTime();
        }

        function addDynamicProperty(prop) {
            this._addDynamicProperty(prop);
            this.elem.addDynamicProperty(prop);
            this._isDirty = true;
        }

        function TransformProperty(elem,data,container){
            this.elem = elem;
            this.frameId = -1;
            this.propType = 'transform';
            this.data = data;
            this.v = new Matrix();
            //Precalculated matrix with non animated properties
            this.pre = new Matrix();
            this.appliedTransformations = 0;
            this.initDynamicPropertyContainer(container || elem);
            if(data.p && data.p.s){
                this.px = PropertyFactory.getProp(elem,data.p.x,0,0,this);
                this.py = PropertyFactory.getProp(elem,data.p.y,0,0,this);
                if(data.p.z){
                    this.pz = PropertyFactory.getProp(elem,data.p.z,0,0,this);
                }
            }else {
                this.p = PropertyFactory.getProp(elem,data.p || {k:[0,0,0]},1,0,this);
            }
            if(data.rx) {
                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
                if(data.or.k[0].ti) {
                    var i, len = data.or.k.length;
                    for(i=0;i<len;i+=1) {
                        data.or.k[i].to = data.or.k[i].ti = null;
                    }
                }
                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
                //sh Indicates it needs to be capped between -180 and 180
                this.or.sh = true;
            } else {
                this.r = PropertyFactory.getProp(elem, data.r || {k: 0}, 0, degToRads, this);
            }
            if(data.sk){
                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
            }
            this.a = PropertyFactory.getProp(elem,data.a || {k:[0,0,0]},1,0,this);
            this.s = PropertyFactory.getProp(elem,data.s || {k:[100,100,100]},1,0.01,this);
            // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
            if(data.o){
                this.o = PropertyFactory.getProp(elem,data.o,0,0.01,elem);
            } else {
                this.o = {_mdf:false,v:1};
            }
            this._isDirty = true;
            if(!this.dynamicProperties.length){
                this.getValue(true);
            }
        }

        TransformProperty.prototype = {
            applyToMatrix: applyToMatrix,
            getValue: processKeys,
            precalculateMatrix: precalculateMatrix,
            autoOrient: autoOrient
        };

        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

        function getTransformProperty(elem,data,container){
            return new TransformProperty(elem,data,container);
        }

        return {
            getTransformProperty: getTransformProperty
        };

    }());
    function ShapePath(){
    	this.c = false;
    	this._length = 0;
    	this._maxLength = 8;
    	this.v = createSizedArray(this._maxLength);
    	this.o = createSizedArray(this._maxLength);
    	this.i = createSizedArray(this._maxLength);
    }

    ShapePath.prototype.setPathData = function(closed, len) {
    	this.c = closed;
    	this.setLength(len);
    	var i = 0;
    	while(i < len){
    		this.v[i] = point_pool.newElement();
    		this.o[i] = point_pool.newElement();
    		this.i[i] = point_pool.newElement();
    		i += 1;
    	}
    };

    ShapePath.prototype.setLength = function(len) {
    	while(this._maxLength < len) {
    		this.doubleArrayLength();
    	}
    	this._length = len;
    };

    ShapePath.prototype.doubleArrayLength = function() {
    	this.v = this.v.concat(createSizedArray(this._maxLength));
    	this.i = this.i.concat(createSizedArray(this._maxLength));
    	this.o = this.o.concat(createSizedArray(this._maxLength));
    	this._maxLength *= 2;
    };

    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {
    	var arr;
    	this._length = Math.max(this._length, pos + 1);
    	if(this._length >= this._maxLength) {
    		this.doubleArrayLength();
    	}
    	switch(type){
    		case 'v':
    			arr = this.v;
    			break;
    		case 'i':
    			arr = this.i;
    			break;
    		case 'o':
    			arr = this.o;
    			break;
    	}
    	if(!arr[pos] || (arr[pos] && !replace)){
    		arr[pos] = point_pool.newElement();
    	}
    	arr[pos][0] = x;
    	arr[pos][1] = y;
    };

    ShapePath.prototype.setTripleAt = function(vX,vY,oX,oY,iX,iY,pos, replace) {
    	this.setXYAt(vX,vY,'v',pos, replace);
    	this.setXYAt(oX,oY,'o',pos, replace);
    	this.setXYAt(iX,iY,'i',pos, replace);
    };

    ShapePath.prototype.reverse = function() {
    	var newPath = new ShapePath();
    	newPath.setPathData(this.c, this._length);
    	var vertices = this.v, outPoints = this.o, inPoints = this.i;
    	var init = 0;
    	if (this.c) {
    		newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
            init = 1;
        }
        var cnt = this._length - 1;
        var len = this._length;

        var i;
        for (i = init; i < len; i += 1) {
        	newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
            cnt -= 1;
        }
        return newPath;
    };
    var ShapePropertyFactory = (function(){

        var initFrame = -999999;

        function interpolateShape(frameNum, previousValue, caching) {
            var iterationIndex = caching.lastIndex;
            var keyPropS,keyPropE,isHold, j, k, jLen, kLen, perc, vertexValue;
            var kf = this.keyframes;
            if(frameNum < kf[0].t-this.offsetTime){
                keyPropS = kf[0].s[0];
                isHold = true;
                iterationIndex = 0;
            }else if(frameNum >= kf[kf.length - 1].t-this.offsetTime){
                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
                /*if(kf[kf.length - 1].s){
                    keyPropS = kf[kf.length - 1].s[0];
                }else{
                    keyPropS = kf[kf.length - 2].e[0];
                }*/
                isHold = true;
            }else {
                var i = iterationIndex;
                var len = kf.length- 1,flag = true,keyData,nextKeyData;
                while(flag){
                    keyData = kf[i];
                    nextKeyData = kf[i+1];
                    if((nextKeyData.t - this.offsetTime) > frameNum){
                        break;
                    }
                    if(i < len - 1){
                        i += 1;
                    }else {
                        flag = false;
                    }
                }
                isHold = keyData.h === 1;
                iterationIndex = i;
                if(!isHold){
                    if(frameNum >= nextKeyData.t-this.offsetTime){
                        perc = 1;
                    }else if(frameNum < keyData.t-this.offsetTime){
                        perc = 0;
                    }else {
                        var fnc;
                        if(keyData.__fnct){
                            fnc = keyData.__fnct;
                        }else {
                            fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;
                            keyData.__fnct = fnc;
                        }
                        perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));
                    }
                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
                }
                keyPropS = keyData.s[0];
            }
            jLen = previousValue._length;
            kLen = keyPropS.i[0].length;
            caching.lastIndex = iterationIndex;

            for(j=0;j<jLen;j+=1){
                for(k=0;k<kLen;k+=1){
                    vertexValue = isHold ? keyPropS.i[j][k] :  keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;
                    previousValue.i[j][k] = vertexValue;
                    vertexValue = isHold ? keyPropS.o[j][k] :  keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;
                    previousValue.o[j][k] = vertexValue;
                    vertexValue = isHold ? keyPropS.v[j][k] :  keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;
                    previousValue.v[j][k] = vertexValue;
                }
            }
        }

        function interpolateShapeCurrentTime(){
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            var lastFrame = this._caching.lastFrame;
            if(!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))){
                ////
                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
                this.interpolateShape(frameNum, this.pv, this._caching);
                ////
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
        }

        function resetShape(){
            this.paths = this.localShapeCollection;
        }

        function shapesEqual(shape1, shape2) {
            if(shape1._length !== shape2._length || shape1.c !== shape2.c){
                return false;
            }
            var i, len = shape1._length;
            for(i = 0; i < len; i += 1) {
                if(shape1.v[i][0] !== shape2.v[i][0] 
                || shape1.v[i][1] !== shape2.v[i][1] 
                || shape1.o[i][0] !== shape2.o[i][0] 
                || shape1.o[i][1] !== shape2.o[i][1] 
                || shape1.i[i][0] !== shape2.i[i][0] 
                || shape1.i[i][1] !== shape2.i[i][1]) {
                    return false;
                }
            }
            return true;
        }

        function setVValue(newPath) {
            if(!shapesEqual(this.v, newPath)) {
                this.v = shape_pool.clone(newPath);
                this.localShapeCollection.releaseShapes();
                this.localShapeCollection.addShape(this.v);
                this._mdf = true;
                this.paths = this.localShapeCollection;
            }
        }

        function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId) {
                return;
            } else if (!this.effectsSequence.length) {
                this._mdf = false;
                return;
            }
            if (this.lock) {
                this.setVValue(this.pv);
                return;
            }
            this.lock = true;
            this._mdf = false;
            var finalValue = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
            var i, len = this.effectsSequence.length;
            for(i = 0; i < len; i += 1) {
                finalValue = this.effectsSequence[i](finalValue);
            }
            this.setVValue(finalValue);
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
        }
        function ShapeProperty(elem, data, type){
            this.propType = 'shape';
            this.comp = elem.comp;
            this.container = elem;
            this.elem = elem;
            this.data = data;
            this.k = false;
            this.kf = false;
            this._mdf = false;
            var pathData = type === 3 ? data.pt.k : data.ks.k;
            this.v = shape_pool.clone(pathData);
            this.pv = shape_pool.clone(this.v);
            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.reset = resetShape;
            this.effectsSequence = [];
        }

        function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
        }

        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence;
        ShapeProperty.prototype.setVValue = setVValue;
        ShapeProperty.prototype.addEffect = addEffect;

        function KeyframedShapeProperty(elem,data,type){
            this.propType = 'shape';
            this.comp = elem.comp;
            this.elem = elem;
            this.container = elem;
            this.offsetTime = elem.data.st;
            this.keyframes = type === 3 ? data.pt.k : data.ks.k;
            this.k = true;
            this.kf = true;
            var len = this.keyframes[0].s[0].i.length;
            var jLen = this.keyframes[0].s[0].i[0].length;
            this.v = shape_pool.newElement();
            this.v.setPathData(this.keyframes[0].s[0].c, len);
            this.pv = shape_pool.clone(this.v);
            this.localShapeCollection = shapeCollection_pool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.lastFrame = initFrame;
            this.reset = resetShape;
            this._caching = {lastFrame: initFrame, lastIndex: 0};
            this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }
        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue;
        KeyframedShapeProperty.prototype.addEffect = addEffect;

        var EllShapeProperty = (function(){

            var cPoint = roundCorner;

            function EllShapeProperty(elem,data) {
                /*this.v = {
                    v: createSizedArray(4),
                    i: createSizedArray(4),
                    o: createSizedArray(4),
                    c: true
                };*/
                this.v = shape_pool.newElement();
                this.v.setPathData(true, 4);
                this.localShapeCollection = shapeCollection_pool.newShapeCollection();
                this.paths = this.localShapeCollection;
                this.localShapeCollection.addShape(this.v);
                this.d = data.d;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
                this.s = PropertyFactory.getProp(elem,data.s,1,0,this);
                if(this.dynamicProperties.length){
                    this.k = true;
                }else {
                    this.k = false;
                    this.convertEllToPath();
                }
            }
            EllShapeProperty.prototype = {
                reset: resetShape,
                getValue: function (){
                    if(this.elem.globalData.frameId === this.frameId){
                        return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();

                    if(this._mdf){
                        this.convertEllToPath();
                    }
                },
                convertEllToPath: function() {
                    var p0 = this.p.v[0], p1 = this.p.v[1], s0 = this.s.v[0]/2, s1 = this.s.v[1]/2;
                    var _cw = this.d !== 3;
                    var _v = this.v;
                    _v.v[0][0] = p0;
                    _v.v[0][1] = p1 - s1;
                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.v[1][1] = p1;
                    _v.v[2][0] = p0;
                    _v.v[2][1] = p1 + s1;
                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.v[3][1] = p1;
                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.i[0][1] = p1 - s1;
                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.i[1][1] = p1 - s1 * cPoint;
                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.i[2][1] = p1 + s1;
                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.i[3][1] = p1 + s1 * cPoint;
                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                    _v.o[0][1] = p1 - s1;
                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                    _v.o[1][1] = p1 + s1 * cPoint;
                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                    _v.o[2][1] = p1 + s1;
                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                    _v.o[3][1] = p1 - s1 * cPoint;
                }
            };

            extendPrototype([DynamicPropertyContainer], EllShapeProperty);

            return EllShapeProperty;
        }());

        var StarShapeProperty = (function() {

            function StarShapeProperty(elem,data) {
                this.v = shape_pool.newElement();
                this.v.setPathData(true, 0);
                this.elem = elem;
                this.comp = elem.comp;
                this.data = data;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                if(data.sy === 1){
                    this.ir = PropertyFactory.getProp(elem,data.ir,0,0,this);
                    this.is = PropertyFactory.getProp(elem,data.is,0,0.01,this);
                    this.convertToPath = this.convertStarToPath;
                } else {
                    this.convertToPath = this.convertPolygonToPath;
                }
                this.pt = PropertyFactory.getProp(elem,data.pt,0,0,this);
                this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
                this.r = PropertyFactory.getProp(elem,data.r,0,degToRads,this);
                this.or = PropertyFactory.getProp(elem,data.or,0,0,this);
                this.os = PropertyFactory.getProp(elem,data.os,0,0.01,this);
                this.localShapeCollection = shapeCollection_pool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                if(this.dynamicProperties.length){
                    this.k = true;
                }else {
                    this.k = false;
                    this.convertToPath();
                }
            }
            StarShapeProperty.prototype = {
                reset: resetShape,
                getValue: function() {
                    if(this.elem.globalData.frameId === this.frameId){
                        return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if(this._mdf){
                        this.convertToPath();
                    }
                },
                convertStarToPath: function() {
                    var numPts = Math.floor(this.pt.v)*2;
                    var angle = Math.PI*2/numPts;
                    /*this.v.v.length = numPts;
                    this.v.i.length = numPts;
                    this.v.o.length = numPts;*/
                    var longFlag = true;
                    var longRad = this.or.v;
                    var shortRad = this.ir.v;
                    var longRound = this.os.v;
                    var shortRound = this.is.v;
                    var longPerimSegment = 2*Math.PI*longRad/(numPts*2);
                    var shortPerimSegment = 2*Math.PI*shortRad/(numPts*2);
                    var i, rad,roundness,perimSegment, currentAng = -Math.PI/ 2;
                    currentAng += this.r.v;
                    var dir = this.data.d === 3 ? -1 : 1;
                    this.v._length = 0;
                    for(i=0;i<numPts;i+=1){
                        rad = longFlag ? longRad : shortRad;
                        roundness = longFlag ? longRound : shortRound;
                        perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                        var x = rad * Math.cos(currentAng);
                        var y = rad * Math.sin(currentAng);
                        var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
                        var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
                        x +=  + this.p.v[0];
                        y +=  + this.p.v[1];
                        this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);

                        /*this.v.v[i] = [x,y];
                        this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                        this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                        this.v._length = numPts;*/
                        longFlag = !longFlag;
                        currentAng += angle*dir;
                    }
                },
                convertPolygonToPath: function() {
                    var numPts = Math.floor(this.pt.v);
                    var angle = Math.PI*2/numPts;
                    var rad = this.or.v;
                    var roundness = this.os.v;
                    var perimSegment = 2*Math.PI*rad/(numPts*4);
                    var i, currentAng = -Math.PI/ 2;
                    var dir = this.data.d === 3 ? -1 : 1;
                    currentAng += this.r.v;
                    this.v._length = 0;
                    for(i=0;i<numPts;i+=1){
                        var x = rad * Math.cos(currentAng);
                        var y = rad * Math.sin(currentAng);
                        var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);
                        var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);
                        x +=  + this.p.v[0];
                        y +=  + this.p.v[1];
                        this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);
                        currentAng += angle*dir;
                    }
                    this.paths.length = 0;
                    this.paths[0] = this.v;
                }

            };
            extendPrototype([DynamicPropertyContainer], StarShapeProperty);

            return StarShapeProperty;
        }());

        var RectShapeProperty = (function() {

             function RectShapeProperty(elem,data) {
                this.v = shape_pool.newElement();
                this.v.c = true;
                this.localShapeCollection = shapeCollection_pool.newShapeCollection();
                this.localShapeCollection.addShape(this.v);
                this.paths = this.localShapeCollection;
                this.elem = elem;
                this.comp = elem.comp;
                this.frameId = -1;
                this.d = data.d;
                this.initDynamicPropertyContainer(elem);
                this.p = PropertyFactory.getProp(elem,data.p,1,0,this);
                this.s = PropertyFactory.getProp(elem,data.s,1,0,this);
                this.r = PropertyFactory.getProp(elem,data.r,0,0,this);
                if(this.dynamicProperties.length){
                    this.k = true;
                }else {
                    this.k = false;
                    this.convertRectToPath();
                }
            }
            RectShapeProperty.prototype = {
                convertRectToPath: function (){
                    var p0 = this.p.v[0], p1 = this.p.v[1], v0 = this.s.v[0]/2, v1 = this.s.v[1]/2;
                    var round = bm_min(v0,v1,this.r.v);
                    var cPoint = round*(1-roundCorner);
                    this.v._length = 0;

                    if(this.d === 2 || this.d === 1) {
                        this.v.setTripleAt(p0+v0, p1-v1+round,p0+v0, p1-v1+round,p0+v0,p1-v1+cPoint,0, true);
                        this.v.setTripleAt(p0+v0, p1+v1-round,p0+v0, p1+v1-cPoint,p0+v0, p1+v1-round,1, true);
                        if(round!== 0){
                            this.v.setTripleAt(p0+v0-round, p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2, true);
                            this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3, true);
                            this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4, true);
                            this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5, true);
                            this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6, true);
                            this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7, true);
                        } else {
                            this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);
                            this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);
                        }
                    }else {
                        this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0, true);
                        if(round!== 0){
                            this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1, true);
                            this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2, true);
                            this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3, true);
                            this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4, true);
                            this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5, true);
                            this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6, true);
                            this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7, true);
                        } else {
                            this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1, true);
                            this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2, true);
                            this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3, true);

                        }
                    }
                },
                getValue: function(frameNum){
                    if(this.elem.globalData.frameId === this.frameId){
                        return;
                    }
                    this.frameId = this.elem.globalData.frameId;
                    this.iterateDynamicProperties();
                    if(this._mdf){
                        this.convertRectToPath();
                    }

                },
                reset: resetShape
            };
            extendPrototype([DynamicPropertyContainer], RectShapeProperty);

            return RectShapeProperty;
        }());

        function getShapeProp(elem,data,type){
            var prop;
            if(type === 3 || type === 4){
                var dataProp = type === 3 ? data.pt : data.ks;
                var keys = dataProp.k;
                if(keys.length){
                    prop = new KeyframedShapeProperty(elem, data, type);
                }else {
                    prop = new ShapeProperty(elem, data, type);
                }
            }else if(type === 5){
                prop = new RectShapeProperty(elem, data);
            }else if(type === 6){
                prop = new EllShapeProperty(elem, data);
            }else if(type === 7){
                prop = new StarShapeProperty(elem, data);
            }
            if(prop.k){
                elem.addDynamicProperty(prop);
            }
            return prop;
        }

        function getConstructorFunction() {
            return ShapeProperty;
        }

        function getKeyframedConstructorFunction() {
            return KeyframedShapeProperty;
        }

        var ob = {};
        ob.getShapeProp = getShapeProp;
        ob.getConstructorFunction = getConstructorFunction;
        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob;
    }());
    var ShapeModifiers = (function(){
        var ob = {};
        var modifiers = {};
        ob.registerModifier = registerModifier;
        ob.getModifier = getModifier;

        function registerModifier(nm,factory){
            if(!modifiers[nm]){
                modifiers[nm] = factory;
            }
        }

        function getModifier(nm,elem, data){
            return new modifiers[nm](elem, data);
        }

        return ob;
    }());

    function ShapeModifier(){}
    ShapeModifier.prototype.initModifierProperties = function(){};
    ShapeModifier.prototype.addShapeToModifier = function(){};
    ShapeModifier.prototype.addShape = function(data){
        if (!this.closed) {
            // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
            data.sh.container.addDynamicProperty(data.sh);
            var shapeData = {shape:data.sh, data: data, localShapeCollection:shapeCollection_pool.newShapeCollection()};
            this.shapes.push(shapeData);
            this.addShapeToModifier(shapeData);
            if (this._isAnimated) {
                data.setAsAnimated();
            }
        }
    };
    ShapeModifier.prototype.init = function(elem,data){
        this.shapes = [];
        this.elem = elem;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem,data);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;
        if(this.dynamicProperties.length){
            this.k = true;
        }else {
            this.getValue(true);
        }
    };
    ShapeModifier.prototype.processKeys = function(){
        if(this.elem.globalData.frameId === this.frameId){
            return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
    };

    extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier(){
    }
    extendPrototype([ShapeModifier], TrimModifier);
    TrimModifier.prototype.initModifierProperties = function(elem, data) {
        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    };

    TrimModifier.prototype.addShapeToModifier = function(shapeData){
        shapeData.pathsData = [];
    };

    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {
        var segments = [];
        if (e <= 1) {
            segments.push({
                s: s,
                e: e
            });
        } else if (s >= 1) {
            segments.push({
                s: s - 1,
                e: e - 1
            });
        } else {
            segments.push({
                s: s,
                e: 1
            });
            segments.push({
                s: 0,
                e: e - 1
            });
        }
        var shapeSegments = [];
        var i, len = segments.length, segmentOb;
        for (i = 0; i < len; i += 1) {
            segmentOb = segments[i];
            if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) ; else {
                var shapeS, shapeE;
                if (segmentOb.s * totalModifierLength <= addedLength) {
                    shapeS = 0;
                } else {
                    shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
                }
                if(segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                    shapeE = 1;
                } else {
                    shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
                }
                shapeSegments.push([shapeS, shapeE]);
            }
        }
        if (!shapeSegments.length) {
            shapeSegments.push([0, 0]);
        }
        return shapeSegments;
    };

    TrimModifier.prototype.releasePathsData = function(pathsData) {
        var i, len = pathsData.length;
        for (i = 0; i < len; i += 1) {
            segments_length_pool.release(pathsData[i]);
        }
        pathsData.length = 0;
        return pathsData;
    };

    TrimModifier.prototype.processShapes = function(_isFirstFrame) {
        var s, e;
        if (this._mdf || _isFirstFrame) {
            var o = (this.o.v % 360) / 360;
            if (o < 0) {
                o += 1;
            }
            s = (this.s.v > 1 ? 1 : this.s.v < 0 ? 0 : this.s.v) + o;
            e = (this.e.v > 1 ? 1 : this.e.v < 0 ? 0 : this.e.v) + o;
            if (s > e) {
                var _s = s;
                s = e;
                e = _s;
            }
            s = Math.round(s * 10000) * 0.0001;
            e = Math.round(e * 10000) * 0.0001;
            this.sValue = s;
            this.eValue = e;
        } else {
            s = this.sValue;
            e = this.eValue;
        }
        var shapePaths;
        var i, len = this.shapes.length, j, jLen;
        var pathsData, pathData, totalShapeLength, totalModifierLength = 0;

        if (e === s) {
            for (i = 0; i < len; i += 1) {
                this.shapes[i].localShapeCollection.releaseShapes();
                this.shapes[i].shape._mdf = true;
                this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
                if (this._mdf) {
                    this.shapes[i].pathsData.length = 0;
                }
            }
        } else if (!((e === 1 && s === 0) || (e===0 && s === 1))){
            var segments = [], shapeData, localShapeCollection;
            for (i = 0; i < len; i += 1) {
                shapeData = this.shapes[i];
                // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                    shapeData.shape.paths = shapeData.localShapeCollection;
                } else {
                    shapePaths = shapeData.shape.paths;
                    jLen = shapePaths._length;
                    totalShapeLength = 0;
                    if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                        totalShapeLength = shapeData.totalShapeLength;
                    } else {
                        pathsData = this.releasePathsData(shapeData.pathsData);
                        for (j = 0; j < jLen; j += 1) {
                            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                            pathsData.push(pathData);
                            totalShapeLength += pathData.totalLength;
                        }
                        shapeData.totalShapeLength = totalShapeLength;
                        shapeData.pathsData = pathsData;
                    }

                    totalModifierLength += totalShapeLength;
                    shapeData.shape._mdf = true;
                }
            }
            var shapeS = s, shapeE = e, addedLength = 0, edges;
            for (i = len - 1; i >= 0; i -= 1) {
                shapeData = this.shapes[i];
                if (shapeData.shape._mdf) {
                    localShapeCollection = shapeData.localShapeCollection;
                    localShapeCollection.releaseShapes();
                    //if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
                    if (this.m === 2 && len > 1) {
                        edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                        addedLength += shapeData.totalShapeLength;
                    } else {
                        edges = [[shapeS, shapeE]];
                    }
                    jLen = edges.length;
                    for (j = 0; j < jLen; j += 1) {
                        shapeS = edges[j][0];
                        shapeE = edges[j][1];
                        segments.length = 0;
                        if (shapeE <= 1) {
                            segments.push({
                                s:shapeData.totalShapeLength * shapeS,
                                e:shapeData.totalShapeLength * shapeE
                            });
                        } else if (shapeS >= 1) {
                            segments.push({
                                s:shapeData.totalShapeLength * (shapeS - 1),
                                e:shapeData.totalShapeLength * (shapeE - 1)
                            });
                        } else {
                            segments.push({
                                s:shapeData.totalShapeLength * shapeS,
                                e:shapeData.totalShapeLength
                            });
                            segments.push({
                                s:0,
                                e:shapeData.totalShapeLength * (shapeE - 1)
                            });
                        }
                        var newShapesData = this.addShapes(shapeData,segments[0]);
                        if (segments[0].s !== segments[0].e) {
                            if (segments.length > 1) {
                                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                                if (lastShapeInCollection.c) {
                                    var lastShape = newShapesData.pop();
                                    this.addPaths(newShapesData, localShapeCollection);
                                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                                } else {
                                    this.addPaths(newShapesData, localShapeCollection);
                                    newShapesData = this.addShapes(shapeData, segments[1]);
                                }
                            } 
                            this.addPaths(newShapesData, localShapeCollection);
                        }
                        
                    }
                    shapeData.shape.paths = localShapeCollection;
                }
            }
        } else if (this._mdf) {
            for (i = 0; i < len; i += 1) {
                //Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
                //Don't remove this even if it's losing cached info.
                this.shapes[i].pathsData.length = 0;
                this.shapes[i].shape._mdf = true;
            }
        }
    };

    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
        var i, len = newPaths.length;
        for (i = 0; i < len; i += 1) {
            localShapeCollection.addShape(newPaths[i]);
        }
    };

    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
        shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
        if(newShape){
            shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
        }
        shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
    };

    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], 'o', pos);
        shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
        if(newShape){
            shapePath.setXYAt(points[0], points[4], 'v', pos);
        }
        shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
    };

    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i, len = shapeData.shape.paths._length, j, jLen;
        var addedLength = 0;
        var currentLengthData,segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;
        if (!shapePath) {
            shapePath = shape_pool.newElement();
            segmentCount = 0;
            initPos = 0;
        } else {
            segmentCount = shapePath._length;
            initPos = shapePath._length;
        }
        shapes.push(shapePath);
        for (i = 0; i < len; i += 1) {
            lengths = pathsData[i].lengths;
            shapePath.c = shapePaths[i].c;
            jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
            for (j = 1; j < jLen; j +=1) {
                currentLengthData = lengths[j-1];
                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                    addedLength += currentLengthData.addedLength;
                    shapePath.c = false;
                } else if(addedLength > shapeSegment.e) {
                    shapePath.c = false;
                    break;
                } else {
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                        newShape = false;
                    } else {
                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength)/currentLengthData.addedLength,(shapeSegment.e - addedLength)/currentLengthData.addedLength, lengths[j-1]);
                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                        // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
                        newShape = false;
                        shapePath.c = false;
                    }
                    addedLength += currentLengthData.addedLength;
                    segmentCount += 1;
                }
            }
            if (shapePaths[i].c && lengths.length) {
                currentLengthData = lengths[j - 1];
                if (addedLength <= shapeSegment.e) {
                    var segmentLength = lengths[j - 1].addedLength;
                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                        newShape = false;
                    } else {
                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                        // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
                        newShape = false;
                        shapePath.c = false;
                    }
                } else {
                    shapePath.c = false;
                }
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
            }
            if (shapePath._length) {
                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1],'o', shapePath._length - 1);
            }
            if (addedLength > shapeSegment.e) {
                break;
            }
            if (i < len - 1) {
                shapePath = shape_pool.newElement();
                newShape = true;
                shapes.push(shapePath);
                segmentCount = 0;
            }
        }
        return shapes;
    };


    ShapeModifiers.registerModifier('tm', TrimModifier);
    function RoundCornersModifier(){}
    extendPrototype([ShapeModifier],RoundCornersModifier);
    RoundCornersModifier.prototype.initModifierProperties = function(elem,data){
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem,data.r,0,null,this);
        this._isAnimated = !!this.rd.effectsSequence.length;
    };

    RoundCornersModifier.prototype.processPath = function(path, round){
        var cloned_path = shape_pool.newElement();
        cloned_path.c = path.c;
        var i, len = path._length;
        var currentV,currentI,currentO,closerV, distance,newPosPerc,index = 0;
        var vX,vY,oX,oY,iX,iY;
        for(i=0;i<len;i+=1){
            currentV = path.v[i];
            currentO = path.o[i];
            currentI = path.i[i];
            if(currentV[0]===currentO[0] && currentV[1]===currentO[1] && currentV[0]===currentI[0] && currentV[1]===currentI[1]){
                if((i===0 || i === len - 1) && !path.c){
                    cloned_path.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);
                    /*cloned_path.v[index] = currentV;
                    cloned_path.o[index] = currentO;
                    cloned_path.i[index] = currentI;*/
                    index += 1;
                } else {
                    if(i===0){
                        closerV = path.v[len-1];
                    } else {
                        closerV = path.v[i-1];
                    }
                    distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
                    newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
                    vX = iX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
                    vY = iY = currentV[1]-(currentV[1]-closerV[1])*newPosPerc;
                    oX = vX-(vX-currentV[0])*roundCorner;
                    oY = vY-(vY-currentV[1])*roundCorner;
                    cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
                    index += 1;

                    if(i === len - 1){
                        closerV = path.v[0];
                    } else {
                        closerV = path.v[i+1];
                    }
                    distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));
                    newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;
                    vX = oX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;
                    vY = oY = currentV[1]+(closerV[1]-currentV[1])*newPosPerc;
                    iX = vX-(vX-currentV[0])*roundCorner;
                    iY = vY-(vY-currentV[1])*roundCorner;
                    cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);
                    index += 1;
                }
            } else {
                cloned_path.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);
                index += 1;
            }
        }
        return cloned_path;
    };

    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame){
        var shapePaths;
        var i, len = this.shapes.length;
        var j, jLen;
        var rd = this.rd.v;

        if(rd !== 0){
            var shapeData, newPaths, localShapeCollection;
            for(i=0;i<len;i+=1){
                shapeData = this.shapes[i];
                newPaths = shapeData.shape.paths;
                localShapeCollection = shapeData.localShapeCollection;
                if(!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)){
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for(j=0;j<jLen;j+=1){
                        localShapeCollection.addShape(this.processPath(shapePaths[j],rd));
                    }
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
            }

        }
        if(!this.dynamicProperties.length){
            this._mdf = false;
        }
    };

    ShapeModifiers.registerModifier('rd',RoundCornersModifier);
    function PuckerAndBloatModifier(){}
    extendPrototype([ShapeModifier],PuckerAndBloatModifier);
    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem,data){
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem,data.a,0,null,this);
        this._isAnimated = !!this.amount.effectsSequence.length;
    };

    PuckerAndBloatModifier.prototype.processPath = function(path, amount){
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length, i = 0;
        for (i = 0; i < pathLength; i += 1) {
            centerPoint[0] += path.v[i][0];
            centerPoint[1] += path.v[i][1];
        }
        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var cloned_path = shape_pool.newElement();
        cloned_path.c = path.c;
        var vX, vY, oX, oY, iX, iY;
        for(i = 0; i < pathLength; i += 1) {
            vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
            vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
            oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
            oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
            iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
            iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
            cloned_path.setTripleAt(vX, vY, oX, oY, iX, iY, i);
        }
        return cloned_path;
    };

    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame){
        var shapePaths;
        var i, len = this.shapes.length;
        var j, jLen;
        var amount = this.amount.v;

        if(amount !== 0){
            var shapeData, newPaths, localShapeCollection;
            for(i=0;i<len;i+=1){
                shapeData = this.shapes[i];
                newPaths = shapeData.shape.paths;
                localShapeCollection = shapeData.localShapeCollection;
                if(!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)){
                    localShapeCollection.releaseShapes();
                    shapeData.shape._mdf = true;
                    shapePaths = shapeData.shape.paths.shapes;
                    jLen = shapeData.shape.paths._length;
                    for(j=0;j<jLen;j+=1){
                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                    }
                }
                shapeData.shape.paths = shapeData.localShapeCollection;
            }
        }
        if(!this.dynamicProperties.length){
            this._mdf = false;
        }
    };
    ShapeModifiers.registerModifier('pb',PuckerAndBloatModifier);
    function RepeaterModifier(){}
    extendPrototype([ShapeModifier], RepeaterModifier);

    RepeaterModifier.prototype.initModifierProperties = function(elem,data){
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem,data.c,0,null,this);
        this.o = PropertyFactory.getProp(elem,data.o,0,null,this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem,data.tr,this);
        this.so = PropertyFactory.getProp(elem,data.tr.so,0,0.01,this);
        this.eo = PropertyFactory.getProp(elem,data.tr.eo,0,0.01,this);
        this.data = data;
        if(!this.dynamicProperties.length){
            this.getValue(true);
        }
        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
    };

    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv){
        var dir = inv ? -1 : 1;
        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        rMatrix.rotate(-transform.r.v * dir * perc);
        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        sMatrix.scale(inv ? 1/scaleX : scaleX, inv ? 1/scaleY : scaleY);
        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
    };

    RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
        this.elem = elem;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem,arr[pos]);
        while(pos>0){
            pos -= 1;
            //this._elements.unshift(arr.splice(pos,1)[0]);
            this._elements.unshift(arr[pos]);
        }
        if(this.dynamicProperties.length){
            this.k = true;
        }else {
            this.getValue(true);
        }
    };

    RepeaterModifier.prototype.resetElements = function(elements){
        var i, len = elements.length;
        for(i = 0; i < len; i += 1) {
            elements[i]._processed = false;
            if(elements[i].ty === 'gr'){
                this.resetElements(elements[i].it);
            }
        }
    };

    RepeaterModifier.prototype.cloneElements = function(elements){
        var len = elements.length;
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
    };

    RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
        var i, len = elements.length;
        for(i = 0; i < len; i += 1) {
            elements[i]._render = renderFlag;
            if(elements[i].ty === 'gr') {
                this.changeGroupRender(elements[i].it, renderFlag);
            }
        }
    };

    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
        var items, itemsTransform, i, dir, cont;
        if(this._mdf || _isFirstFrame){
            var copies = Math.ceil(this.c.v);
            if(this._groups.length < copies){
                while(this._groups.length < copies){
                    var group = {
                        it:this.cloneElements(this._elements),
                        ty:'gr'
                    };
                    group.it.push({"a":{"a":0,"ix":1,"k":[0,0]},"nm":"Transform","o":{"a":0,"ix":7,"k":100},"p":{"a":0,"ix":2,"k":[0,0]},"r":{"a":1,"ix":6,"k":[{s:0,e:0,t:0},{s:0,e:0,t:1}]},"s":{"a":0,"ix":3,"k":[100,100]},"sa":{"a":0,"ix":5,"k":0},"sk":{"a":0,"ix":4,"k":0},"ty":"tr"});
                    
                    this.arr.splice(0,0,group);
                    this._groups.splice(0,0,group);
                    this._currentCopies += 1;
                }
                this.elem.reloadShapes();
            }
            cont = 0;
            var renderFlag;
            for(i = 0; i  <= this._groups.length - 1; i += 1){
                renderFlag = cont < copies;
                this._groups[i]._render = renderFlag;
                this.changeGroupRender(this._groups[i].it, renderFlag);
                cont += 1;
            }
            
            this._currentCopies = copies;
            ////

            var offset = this.o.v;
            var offsetModulo = offset%1;
            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
            var tMat = this.tr.v.props;
            var pProps = this.pMatrix.props;
            var rProps = this.rMatrix.props;
            var sProps = this.sMatrix.props;
            this.pMatrix.reset();
            this.rMatrix.reset();
            this.sMatrix.reset();
            this.tMatrix.reset();
            this.matrix.reset();
            var iteration = 0;

            if(offset > 0) {
                while(iteration<roundOffset){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    iteration += 1;
                }
                if(offsetModulo){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                    iteration += offsetModulo;
                }
            } else if(offset < 0) {
                while(iteration>roundOffset){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                    iteration -= 1;
                }
                if(offsetModulo){
                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, - offsetModulo, true);
                    iteration -= offsetModulo;
                }
            }
            i = this.data.m === 1 ? 0 : this._currentCopies - 1;
            dir = this.data.m === 1 ? 1 : -1;
            cont = this._currentCopies;
            var j, jLen;
            while(cont){
                items = this.elemsData[i].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                jLen = itemsTransform.length;
                items[items.length - 1].transform.mProps._mdf = true;
                items[items.length - 1].transform.op._mdf = true;
                items[items.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
                if(iteration !== 0){
                    if((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)){
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                    }
                    this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);
                    this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);
                    this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);
                    
                    for(j=0;j<jLen;j+=1) {
                        itemsTransform[j] = this.matrix.props[j];
                    }
                    this.matrix.reset();
                } else {
                    this.matrix.reset();
                    for(j=0;j<jLen;j+=1) {
                        itemsTransform[j] = this.matrix.props[j];
                    }
                }
                iteration += 1;
                cont -= 1;
                i += dir;
            }
        } else {
            cont = this._currentCopies;
            i = 0;
            dir = 1;
            while(cont){
                items = this.elemsData[i].it;
                itemsTransform = items[items.length - 1].transform.mProps.v.props;
                items[items.length - 1].transform.mProps._mdf = false;
                items[items.length - 1].transform.op._mdf = false;
                cont -= 1;
                i += dir;
            }
        }
    };

    RepeaterModifier.prototype.addShape = function(){};

    ShapeModifiers.registerModifier('rp',RepeaterModifier);
    function ShapeCollection(){
    	this._length = 0;
    	this._maxLength = 4;
    	this.shapes = createSizedArray(this._maxLength);
    }

    ShapeCollection.prototype.addShape = function(shapeData){
    	if(this._length === this._maxLength){
    		this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
    		this._maxLength *= 2;
    	}
    	this.shapes[this._length] = shapeData;
    	this._length += 1;
    };

    ShapeCollection.prototype.releaseShapes = function(){
    	var i;
    	for(i = 0; i < this._length; i += 1) {
    		shape_pool.release(this.shapes[i]);
    	}
    	this._length = 0;
    };
    function DashProperty(elem, data, renderer, container) {
        this.elem = elem;
        this.frameId = -1;
        this.dataProps = createSizedArray(data.length);
        this.renderer = renderer;
        this.k = false;
        this.dashStr = '';
        this.dashArray = createTypedArray('float32',  data.length ? data.length - 1 : 0);
        this.dashoffset = createTypedArray('float32',  1);
        this.initDynamicPropertyContainer(container);
        var i, len = data.length || 0, prop;
        for(i = 0; i < len; i += 1) {
            prop = PropertyFactory.getProp(elem,data[i].v,0, 0, this);
            this.k = prop.k || this.k;
            this.dataProps[i] = {n:data[i].n,p:prop};
        }
        if(!this.k){
            this.getValue(true);
        }
        this._isAnimated = this.k;
    }

    DashProperty.prototype.getValue = function(forceRender) {
        if(this.elem.globalData.frameId === this.frameId && !forceRender){
            return;
        }
        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;
        if (this._mdf) {
            var i = 0, len = this.dataProps.length;
            if(this.renderer === 'svg') {
                this.dashStr = '';
            }
            for(i=0;i<len;i+=1){
                if(this.dataProps[i].n != 'o'){
                    if(this.renderer === 'svg') {
                        this.dashStr += ' ' + this.dataProps[i].p.v;
                    }else {
                        this.dashArray[i] = this.dataProps[i].p.v;
                    }
                }else {
                    this.dashoffset[0] = this.dataProps[i].p.v;
                }
            }
        }
    };
    extendPrototype([DynamicPropertyContainer], DashProperty);
    function GradientProperty(elem,data,container){
        this.data = data;
        this.c = createTypedArray('uint8c', data.p*4);
        var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p*4) : data.k.k.length - data.p*4;
        this.o = createTypedArray('float32', cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem,data.k,1,null,this);
        this.k = this.prop.k;
        this.getValue(true);
    }

    GradientProperty.prototype.comparePoints = function(values, points) {
        var i = 0, len = this.o.length/2, diff;
        while(i < len) {
            diff = Math.abs(values[i*4] - values[points*4 + i*2]);
            if(diff > 0.01){
                return false;
            }
            i += 1;
        }
        return true;
    };

    GradientProperty.prototype.checkCollapsable = function() {
        if (this.o.length/2 !== this.c.length/4) {
            return false;
        }
        if (this.data.k.k[0].s) {
            var i = 0, len = this.data.k.k.length;
            while (i < len) {
                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
                    return false;
                }
                i += 1;
            }
        } else if(!this.comparePoints(this.data.k.k, this.data.p)) {
            return false;
        }
        return true;
    };

    GradientProperty.prototype.getValue = function(forceRender){
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;
        if(this.prop._mdf || forceRender){
            var i, len = this.data.p*4;
            var mult, val;
            for(i=0;i<len;i+=1){
                mult = i%4 === 0 ? 100 : 255;
                val = Math.round(this.prop.v[i]*mult);
                if(this.c[i] !== val){
                    this.c[i] = val;
                    this._cmdf = !forceRender;
                }
            }
            if(this.o.length){
                len = this.prop.v.length;
                for(i=this.data.p*4;i<len;i+=1){
                    mult = i%2 === 0 ? 100 : 1;
                    val = i%2 === 0 ?  Math.round(this.prop.v[i]*100):this.prop.v[i];
                    if(this.o[i-this.data.p*4] !== val){
                        this.o[i-this.data.p*4] = val;
                        this._omdf = !forceRender;
                    }
                }
            }
            this._mdf = !forceRender;
        }
    };

    extendPrototype([DynamicPropertyContainer], GradientProperty);
    var buildShapeString = function(pathNodes, length, closed, mat) {
    	if(length === 0) {
                return '';
            }
            var _o = pathNodes.o;
            var _i = pathNodes.i;
            var _v = pathNodes.v;
            var i, shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            for(i = 1; i < length; i += 1) {
                shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[i][0], _i[i][1]) + " " + mat.applyToPointStringified(_v[i][0], _v[i][1]);
            }
            if (closed && length) {
                shapeString += " C" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
                shapeString += 'z';
            }
            return shapeString;
    };
    var ImagePreloader = (function(){

        var proxyImage = (function(){
            var canvas = createTag('canvas');
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 1, 1);
            return canvas;
        }());

        function imageLoaded(){
            this.loadedAssets += 1;
            if(this.loadedAssets === this.totalImages){
                if(this.imagesLoadedCb) {
                    this.imagesLoadedCb(null);
                }
            }
        }

        function getAssetsPath(assetData, assetsPath, original_path) {
            var path = '';
            if (assetData.e) {
                path = assetData.p;
            } else if(assetsPath) {
                var imagePath = assetData.p;
                if (imagePath.indexOf('images/') !== -1) {
                    imagePath = imagePath.split('/')[1];
                }
                path = assetsPath + imagePath;
            } else {
                path = original_path;
                path += assetData.u ? assetData.u : '';
                path += assetData.p;
            }
            return path;
        }

        function createImageData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createNS('image');
            img.addEventListener('load', this._imageLoaded, false);
            img.addEventListener('error', function() {
                ob.img = proxyImage;
                this._imageLoaded();
            }.bind(this), false);
            img.setAttributeNS('http://www.w3.org/1999/xlink','href', path);
            var ob = {
                img: img,
                assetData: assetData
            };
            return ob;
        }

        function createImgData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createTag('img');
            img.crossOrigin = 'anonymous';
            img.addEventListener('load', this._imageLoaded, false);
            img.addEventListener('error', function() {
                ob.img = proxyImage;
                this._imageLoaded();
            }.bind(this), false);
            img.src = path;
            var ob = {
                img: img,
                assetData: assetData
            };
            return ob;
        }

        function loadAssets(assets, cb){
            this.imagesLoadedCb = cb;
            var i, len = assets.length;
            for (i = 0; i < len; i += 1) {
                if(!assets[i].layers){
                    this.totalImages += 1;
                    this.images.push(this._createImageData(assets[i]));
                }
            }
        }

        function setPath(path){
            this.path = path || '';
        }

        function setAssetsPath(path){
            this.assetsPath = path || '';
        }

        function getImage(assetData) {
            var i = 0, len = this.images.length;
            while (i < len) {
                if (this.images[i].assetData === assetData) {
                    return this.images[i].img;
                }
                i += 1;
            }
        }

        function destroy() {
            this.imagesLoadedCb = null;
            this.images.length = 0;
        }

        function loaded() {
            return this.totalImages === this.loadedAssets;
        }

        function setCacheType(type) {
            if (type === 'svg') {
                this._createImageData = this.createImageData.bind(this);
            } else {
                this._createImageData = this.createImgData.bind(this);
            }
        }

        function ImagePreloader(type){
            this._imageLoaded = imageLoaded.bind(this);
            this.assetsPath = '';
            this.path = '';
            this.totalImages = 0;
            this.loadedAssets = 0;
            this.imagesLoadedCb = null;
            this.images = [];
        }
        ImagePreloader.prototype = {
            loadAssets: loadAssets,
            setAssetsPath: setAssetsPath,
            setPath: setPath,
            loaded: loaded,
            destroy: destroy,
            getImage: getImage,
            createImgData: createImgData,
            createImageData: createImageData,
            imageLoaded: imageLoaded,
            setCacheType: setCacheType,
        };

        return ImagePreloader;
    }());
    var featureSupport = (function(){
    	var ob = {
    		maskType: true
    	};
    	if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
    	   ob.maskType = false;
    	}
    	return ob;
    }());
    var filtersFactory = (function(){
    	var ob = {};
    	ob.createFilter = createFilter;
    	ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

    	function createFilter(filId){
            	var fil = createNS('filter');
            	fil.setAttribute('id',filId);
                    fil.setAttribute('filterUnits','objectBoundingBox');
                    fil.setAttribute('x','0%');
                    fil.setAttribute('y','0%');
                    fil.setAttribute('width','100%');
                    fil.setAttribute('height','100%');
                    return fil;
    	}

    	function createAlphaToLuminanceFilter(){
                    var feColorMatrix = createNS('feColorMatrix');
                    feColorMatrix.setAttribute('type','matrix');
                    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
                    feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
                    return feColorMatrix;
    	}

    	return ob;
    }());
    var assetLoader = (function(){

    	function formatResponse(xhr) {
    		if(xhr.response && typeof xhr.response === 'object') {
    			return xhr.response;
    		} else if(xhr.response && typeof xhr.response === 'string') {
    			return JSON.parse(xhr.response);
    		} else if(xhr.responseText) {
    			return JSON.parse(xhr.responseText);
    		}
    	}

    	function loadAsset(path, callback, errorCallback) {
    		var response;
    		var xhr = new XMLHttpRequest();
    		xhr.open('GET', path, true);
    		// set responseType after calling open or IE will break.
    		try {
    		    // This crashes on Android WebView prior to KitKat
    		    xhr.responseType = "json";
    		} catch (err) {}
    	    xhr.send();
    	    xhr.onreadystatechange = function () {
    	        if (xhr.readyState == 4) {
    	            if(xhr.status == 200){
    	            	response = formatResponse(xhr);
    	            	callback(response);
    	            }else {
    	                try{
    	            		response = formatResponse(xhr);
    	            		callback(response);
    	                }catch(err){
    	                	if(errorCallback) {
    	                		errorCallback(err);
    	                	}
    	                }
    	            }
    	        }
    	    };
    	}
    	return {
    		load: loadAsset
    	}
    }());

    function TextAnimatorProperty(textData, renderType, elem){
        this._isFirstFrame = true;
    	this._hasMaskedPath = false;
    	this._frameId = -1;
    	this._textData = textData;
    	this._renderType = renderType;
        this._elem = elem;
    	this._animatorsData = createSizedArray(this._textData.a.length);
    	this._pathData = {};
    	this._moreOptions = {
    		alignment: {}
    	};
    	this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem);

    }

    TextAnimatorProperty.prototype.searchProperties = function(){
        var i, len = this._textData.a.length, animatorProps;
        var getProp = PropertyFactory.getProp;
        for(i=0;i<len;i+=1){
            animatorProps = this._textData.a[i];
            this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }
        if(this._textData.p && 'm' in this._textData.p){
            this._pathData = {
                f: getProp(this._elem,this._textData.p.f,0,0,this),
                l: getProp(this._elem,this._textData.p.l,0,0,this),
                r: this._textData.p.r,
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            };
            this._hasMaskedPath = true;
        } else {
            this._hasMaskedPath = false;
        }
        this._moreOptions.alignment = getProp(this._elem,this._textData.m.a,1,0,this);
    };

    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag){
        this.lettersChangedFlag = lettersChangedFlag;
        if(!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
            return;
        }
        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var data = this.data;
        var xPos,yPos;
        var i, len;
        var letters = documentData.l, pathInfo, currentLength, currentPoint, segmentLength, flag, pointInd, segmentInd, prevPoint, points, segments, partialLength, totalLength, perc, tanAngle, mask;
        if(this._hasMaskedPath) {
            mask = this._pathData.m;
            if(!this._pathData.n || this._pathData._mdf){
                var paths = mask.v;
                if(this._pathData.r){
                    paths = paths.reverse();
                }
                // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
                pathInfo = {
                    tLength: 0,
                    segments: []
                };
                len = paths._length - 1;
                var bezierData;
                totalLength = 0;
                for (i = 0; i < len; i += 1) {
                    bezierData = bez.buildBezierData(paths.v[i]
                        , paths.v[i + 1]
                        , [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]]
                        , [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                }
                i = len;
                if (mask.v.c) {
                    bezierData = bez.buildBezierData(paths.v[i]
                        , paths.v[0]
                        , [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]]
                        , [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
                    pathInfo.tLength += bezierData.segmentLength;
                    pathInfo.segments.push(bezierData);
                    totalLength += bezierData.segmentLength;
                }
                this._pathData.pi = pathInfo;
            }
            pathInfo = this._pathData.pi;

            currentLength = this._pathData.f.v;
            segmentInd = 0;
            pointInd = 1;
            segmentLength = 0;
            flag = true;
            segments = pathInfo.segments;
            if (currentLength < 0 && mask.v.c) {
                if (pathInfo.tLength < Math.abs(currentLength)) {
                    currentLength = -Math.abs(currentLength) % pathInfo.tLength;
                }
                segmentInd = segments.length - 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
                while (currentLength < 0) {
                    currentLength += points[pointInd].partialLength;
                    pointInd -= 1;
                    if (pointInd < 0) {
                        segmentInd -= 1;
                        points = segments[segmentInd].points;
                        pointInd = points.length - 1;
                    }
                }

            }
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
        }


        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps, animatorSelector;
        var j, jLen;
        var letterValue;

        jLen = animators.length;

        var mult, ind = -1, offf, xPathPos, yPathPos;
        var initPathPos = currentLength,initSegmentInd = segmentInd, initPointInd = pointInd, currentLine = -1;
        var elemOpacity;
        var sc,sw,fc,k;
        var lineLength = 0;
        var letterSw, letterSc, letterFc, letterM = '', letterP = this.defaultPropsArray, letterO;

        //
        if(documentData.j === 2 || documentData.j === 1) {
            var animatorJustifyOffset = 0;
            var animatorFirstCharOffset = 0;
            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
            var lastIndex = 0;
            var isNewLine = true;

            for (i = 0; i < len; i += 1) {
                if (letters[i].n) {
                    if(animatorJustifyOffset) {
                        animatorJustifyOffset += animatorFirstCharOffset;
                    }
                    while (lastIndex < i) {
                        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                        lastIndex += 1;
                    }
                    animatorJustifyOffset = 0;
                    isNewLine = true;
                } else {
                    for (j = 0; j < jLen; j += 1) {
                        animatorProps = animators[j].a;
                        if (animatorProps.t.propType) {
                            if (isNewLine && documentData.j === 2) {
                                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                            }
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                            if (mult.length) {
                                animatorJustifyOffset += animatorProps.t.v*mult[0] * justifyOffsetMult;
                            } else {
                                animatorJustifyOffset += animatorProps.t.v*mult * justifyOffsetMult;
                            }
                        }
                    }
                    isNewLine = false;
                }
            }
            if(animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
            }
            while(lastIndex < i) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
            }
        }
        //

        for( i = 0; i < len; i += 1) {

            matrixHelper.reset();
            elemOpacity = 1;
            if(letters[i].n) {
                xPos = 0;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                currentLength = initPathPos ;
                firstLine = false;
                lineLength = 0;
                if(this._hasMaskedPath) {
                    segmentInd = initSegmentInd;
                    pointInd = initPointInd;
                    points = segments[segmentInd].points;
                    prevPoint = points[pointInd - 1];
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                    segmentLength = 0;
                }
                letterO = letterSw = letterFc = letterM = '';
                letterP = this.defaultPropsArray;
            }else {
                if(this._hasMaskedPath) {
                    if(currentLine !== letters[i].line){
                        switch(documentData.j){
                            case 1:
                                currentLength += totalLength - documentData.lineWidths[letters[i].line];
                                break;
                            case 2:
                                currentLength += (totalLength - documentData.lineWidths[letters[i].line])/2;
                                break;
                        }
                        currentLine = letters[i].line;
                    }
                    if (ind !== letters[i].ind) {
                        if (letters[ind]) {
                            currentLength += letters[ind].extra;
                        }
                        currentLength += letters[i].an / 2;
                        ind = letters[i].ind;
                    }
                    currentLength += alignment[0] * letters[i].an / 200;
                    var animatorOffset = 0;
                    for (j = 0; j < jLen; j += 1) {
                        animatorProps = animators[j].a;
                        if (animatorProps.p.propType) {
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                            if(mult.length){
                                animatorOffset += animatorProps.p.v[0] * mult[0];
                            } else {
                                animatorOffset += animatorProps.p.v[0] * mult;
                            }

                        }
                        if (animatorProps.a.propType) {
                            animatorSelector = animators[j].s;
                            mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                            if(mult.length){
                                animatorOffset += animatorProps.a.v[0] * mult[0];
                            } else {
                                animatorOffset += animatorProps.a.v[0] * mult;
                            }

                        }
                    }
                    flag = true;
                    while (flag) {
                        if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                            matrixHelper.translate(-alignment[0]*letters[i].an/200, -(alignment[1] * yOff / 100));
                            flag = false;
                        } else if (points) {
                            segmentLength += currentPoint.partialLength;
                            pointInd += 1;
                            if (pointInd >= points.length) {
                                pointInd = 0;
                                segmentInd += 1;
                                if (!segments[segmentInd]) {
                                    if (mask.v.c) {
                                        pointInd = 0;
                                        segmentInd = 0;
                                        points = segments[segmentInd].points;
                                    } else {
                                        segmentLength -= currentPoint.partialLength;
                                        points = null;
                                    }
                                } else {
                                    points = segments[segmentInd].points;
                                }
                            }
                            if (points) {
                                prevPoint = currentPoint;
                                currentPoint = points[pointInd];
                                partialLength = currentPoint.partialLength;
                            }
                        }
                    }
                    offf = letters[i].an / 2 - letters[i].add;
                    matrixHelper.translate(-offf, 0, 0);
                } else {
                    offf = letters[i].an/2 - letters[i].add;
                    matrixHelper.translate(-offf,0,0);

                    // Grouping alignment
                    matrixHelper.translate(-alignment[0]*letters[i].an/200, -alignment[1]*yOff/100, 0);
                }

                lineLength += letters[i].l/2;
                for(j=0;j<jLen;j+=1){
                    animatorProps = animators[j].a;
                    if (animatorProps.t.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                        //This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
                        if(xPos !== 0 || documentData.j !== 0) {
                            if(this._hasMaskedPath) {
                                if(mult.length) {
                                    currentLength += animatorProps.t.v*mult[0];
                                } else {
                                    currentLength += animatorProps.t.v*mult;
                                }
                            }else {
                                if(mult.length) {
                                    xPos += animatorProps.t.v*mult[0];
                                } else {
                                    xPos += animatorProps.t.v*mult;
                                }
                            }
                        }
                    }
                }
                lineLength += letters[i].l/2;
                if(documentData.strokeWidthAnim) {
                    sw = documentData.sw || 0;
                }
                if(documentData.strokeColorAnim) {
                    if(documentData.sc){
                        sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                    }else {
                        sc = [0,0,0];
                    }
                }
                if(documentData.fillColorAnim && documentData.fc) {
                    fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
                }
                for(j=0;j<jLen;j+=1){
                    animatorProps = animators[j].a;
                    if (animatorProps.a.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);

                        if(mult.length){
                            matrixHelper.translate(-animatorProps.a.v[0]*mult[0], -animatorProps.a.v[1]*mult[1], animatorProps.a.v[2]*mult[2]);
                        } else {
                            matrixHelper.translate(-animatorProps.a.v[0]*mult, -animatorProps.a.v[1]*mult, animatorProps.a.v[2]*mult);
                        }
                    }
                }
                for(j=0;j<jLen;j+=1){
                    animatorProps = animators[j].a;
                    if (animatorProps.s.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                        if(mult.length){
                            matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult[0]),1+((animatorProps.s.v[1]-1)*mult[1]),1);
                        } else {
                            matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult),1+((animatorProps.s.v[1]-1)*mult),1);
                        }
                    }
                }
                for(j=0;j<jLen;j+=1) {
                    animatorProps = animators[j].a;
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                    if (animatorProps.sk.propType) {
                        if(mult.length) {
                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                        } else {
                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                        }
                    }
                    if (animatorProps.r.propType) {
                        if(mult.length) {
                            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                        } else {
                            matrixHelper.rotateZ(-animatorProps.r.v * mult);
                        }
                    }
                    if (animatorProps.ry.propType) {

                        if(mult.length) {
                            matrixHelper.rotateY(animatorProps.ry.v*mult[1]);
                        }else {
                            matrixHelper.rotateY(animatorProps.ry.v*mult);
                        }
                    }
                    if (animatorProps.rx.propType) {
                        if(mult.length) {
                            matrixHelper.rotateX(animatorProps.rx.v*mult[0]);
                        } else {
                            matrixHelper.rotateX(animatorProps.rx.v*mult);
                        }
                    }
                    if (animatorProps.o.propType) {
                        if(mult.length) {
                            elemOpacity += ((animatorProps.o.v)*mult[0] - elemOpacity)*mult[0];
                        } else {
                            elemOpacity += ((animatorProps.o.v)*mult - elemOpacity)*mult;
                        }
                    }
                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                        if(mult.length) {
                            sw += animatorProps.sw.v*mult[0];
                        } else {
                            sw += animatorProps.sw.v*mult;
                        }
                    }
                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                        for(k=0;k<3;k+=1){
                            if(mult.length) {
                                sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult[0];
                            } else {
                                sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult;
                            }
                        }
                    }
                    if (documentData.fillColorAnim && documentData.fc) {
                        if(animatorProps.fc.propType){
                            for(k=0;k<3;k+=1){
                                if(mult.length) {
                                    fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult[0];
                                } else {
                                    fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult;
                                }
                            }
                        }
                        if(animatorProps.fh.propType){
                            if(mult.length) {
                                fc = addHueToRGB(fc,animatorProps.fh.v*mult[0]);
                            } else {
                                fc = addHueToRGB(fc,animatorProps.fh.v*mult);
                            }
                        }
                        if(animatorProps.fs.propType){
                            if(mult.length) {
                                fc = addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);
                            } else {
                                fc = addSaturationToRGB(fc,animatorProps.fs.v*mult);
                            }
                        }
                        if(animatorProps.fb.propType){
                            if(mult.length) {
                                fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);
                            } else {
                                fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult);
                            }
                        }
                    }
                }

                for(j=0;j<jLen;j+=1){
                    animatorProps = animators[j].a;

                    if (animatorProps.p.propType) {
                        animatorSelector = animators[j].s;
                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);
                        if(this._hasMaskedPath) {
                            if(mult.length) {
                                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                            } else {
                                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                            }
                        }else {
                            if(mult.length) {
                                matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                            } else {
                                matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                            
                            }
                        }
                    }
                }
                if(documentData.strokeWidthAnim){
                    letterSw = sw < 0 ? 0 : sw;
                }
                if(documentData.strokeColorAnim){
                    letterSc = 'rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';
                }
                if(documentData.fillColorAnim && documentData.fc){
                    letterFc = 'rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';
                }

                if(this._hasMaskedPath) {
                    matrixHelper.translate(0,-documentData.ls);

                    matrixHelper.translate(0, alignment[1]*yOff/100 + yPos,0);
                    if (textData.p.p) {
                        tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                        var rot = Math.atan(tanAngle) * 180 / Math.PI;
                        if (currentPoint.point[0] < prevPoint.point[0]) {
                            rot += 180;
                        }
                        matrixHelper.rotate(-rot * Math.PI / 180);
                    }
                    matrixHelper.translate(xPathPos, yPathPos, 0);
                    currentLength -= alignment[0]*letters[i].an/200;
                    if(letters[i+1] && ind !== letters[i+1].ind){
                        currentLength += letters[i].an / 2;
                        currentLength += documentData.tr/1000*documentData.finalSize;
                    }
                }else {

                    matrixHelper.translate(xPos,yPos,0);

                    if(documentData.ps){
                        //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
                        matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
                    }
                    switch(documentData.j){
                        case 1:
                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]),0,0);
                            break;
                        case 2:
                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line])/2,0,0);
                            break;
                    }
                    matrixHelper.translate(0,-documentData.ls);
                    matrixHelper.translate(offf,0,0);
                    matrixHelper.translate(alignment[0]*letters[i].an/200,alignment[1]*yOff/100,0);
                    xPos += letters[i].l + documentData.tr/1000*documentData.finalSize;
                }
                if(renderType === 'html'){
                    letterM = matrixHelper.toCSS();
                }else if(renderType === 'svg'){
                    letterM = matrixHelper.to2dCSS();
                }else {
                    letterP = [matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];
                }
                letterO = elemOpacity;
            }

            if(renderedLettersCount <= i) {
                letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);
                this.renderedLetters.push(letterValue);
                renderedLettersCount += 1;
                this.lettersChangedFlag = true;
            } else {
                letterValue = this.renderedLetters[i];
                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
            }
        }
    };

    TextAnimatorProperty.prototype.getValue = function(){
    	if(this._elem.globalData.frameId === this._frameId){
            return;
        }
        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
    };

    TextAnimatorProperty.prototype.mHelper = new Matrix();
    TextAnimatorProperty.prototype.defaultPropsArray = [];
    extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function TextAnimatorDataProperty(elem, animatorProps, container) {
    	var defaultData = {propType:false};
    	var getProp = PropertyFactory.getProp;
    	var textAnimator_animatables = animatorProps.a;
    	this.a = {
    		r: textAnimator_animatables.r ? getProp(elem, textAnimator_animatables.r, 0, degToRads, container) : defaultData,
    		rx: textAnimator_animatables.rx ? getProp(elem, textAnimator_animatables.rx, 0, degToRads, container) : defaultData,
    		ry: textAnimator_animatables.ry ? getProp(elem, textAnimator_animatables.ry, 0, degToRads, container) : defaultData,
    		sk: textAnimator_animatables.sk ? getProp(elem, textAnimator_animatables.sk, 0, degToRads, container) : defaultData,
    		sa: textAnimator_animatables.sa ? getProp(elem, textAnimator_animatables.sa, 0, degToRads, container) : defaultData,
    		s: textAnimator_animatables.s ? getProp(elem, textAnimator_animatables.s, 1, 0.01, container) : defaultData,
    		a: textAnimator_animatables.a ? getProp(elem, textAnimator_animatables.a, 1, 0, container) : defaultData,
    		o: textAnimator_animatables.o ? getProp(elem, textAnimator_animatables.o, 0, 0.01, container) : defaultData,
    		p: textAnimator_animatables.p ? getProp(elem,textAnimator_animatables.p, 1, 0, container) : defaultData,
    		sw: textAnimator_animatables.sw ? getProp(elem, textAnimator_animatables.sw, 0, 0, container) : defaultData,
    		sc: textAnimator_animatables.sc ? getProp(elem, textAnimator_animatables.sc, 1, 0, container) : defaultData,
    		fc: textAnimator_animatables.fc ? getProp(elem, textAnimator_animatables.fc, 1, 0, container) : defaultData,
    		fh: textAnimator_animatables.fh ? getProp(elem, textAnimator_animatables.fh, 0, 0, container) : defaultData,
    		fs: textAnimator_animatables.fs ? getProp(elem, textAnimator_animatables.fs, 0, 0.01, container) : defaultData,
    		fb: textAnimator_animatables.fb ? getProp(elem, textAnimator_animatables.fb, 0, 0.01, container) : defaultData,
    		t: textAnimator_animatables.t ? getProp(elem, textAnimator_animatables.t, 0, 0, container) : defaultData
    	};

    	this.s = TextSelectorProp.getTextSelectorProp(elem,animatorProps.s, container);
        this.s.t = animatorProps.s.t;
    }
    function LetterProps(o, sw, sc, fc, m, p){
        this.o = o;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m;
        this.p = p;
        this._mdf = {
        	o: true,
        	sw: !!sw,
        	sc: !!sc,
        	fc: !!fc,
        	m: true,
        	p: true
        };
    }

    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {
    	this._mdf.o = false;
    	this._mdf.sw = false;
    	this._mdf.sc = false;
    	this._mdf.fc = false;
    	this._mdf.m = false;
    	this._mdf.p = false;
    	var updated = false;

    	if(this.o !== o) {
    		this.o = o;
    		this._mdf.o = true;
    		updated = true;
    	}
    	if(this.sw !== sw) {
    		this.sw = sw;
    		this._mdf.sw = true;
    		updated = true;
    	}
    	if(this.sc !== sc) {
    		this.sc = sc;
    		this._mdf.sc = true;
    		updated = true;
    	}
    	if(this.fc !== fc) {
    		this.fc = fc;
    		this._mdf.fc = true;
    		updated = true;
    	}
    	if(this.m !== m) {
    		this.m = m;
    		this._mdf.m = true;
    		updated = true;
    	}
    	if(p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
    		this.p = p;
    		this._mdf.p = true;
    		updated = true;
    	}
    	return updated;
    };
    function TextProperty(elem, data){
    	this._frameId = initialDefaultFrame;
    	this.pv = '';
    	this.v = '';
    	this.kf = false;
    	this._isFirstFrame = true;
    	this._mdf = false;
        this.data = data;
    	this.elem = elem;
        this.comp = this.elem.comp;
    	this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
    	this.currentData = {
    		ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: '',
            fStyle: '',
            fWeight: '',
            fc: '',
            j: '',
            justifyOffset: '',
            l: [],
            lh: 0,
            lineWidths: [],
            ls: '',
            of: '',
            s: '',
            sc: '',
            sw: 0,
            t: 0,
            tr: 0,
            sz:0,
            ps:null,
            fillColorAnim: false,
            strokeColorAnim: false,
            strokeWidthAnim: false,
            yOffset: 0,
            finalSize:0,
            finalText:[],
            finalLineHeight: 0,
            __complete: false

    	};
        this.copyData(this.currentData, this.data.d.k[0].s);

        if(!this.searchProperty()) {
            this.completeTextData(this.currentData);
        }
    }

    TextProperty.prototype.defaultBoxWidth = [0,0];

    TextProperty.prototype.copyData = function(obj, data) {
        for(var s in data) {
            if(data.hasOwnProperty(s)) {
                obj[s] = data[s];
            }
        }
        return obj;
    };

    TextProperty.prototype.setCurrentData = function(data){
        if(!data.__complete) {
            this.completeTextData(data);
        }
        this.currentData = data;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
    };

    TextProperty.prototype.searchProperty = function() {
        return this.searchKeyframes();
    };

    TextProperty.prototype.searchKeyframes = function() {
        this.kf = this.data.d.k.length > 1;
        if(this.kf) {
            this.addEffect(this.getKeyframeValue.bind(this));
        }
        return this.kf;
    };

    TextProperty.prototype.addEffect = function(effectFunction) {
    	this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.getValue = function(_finalValue) {
        if((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
            return;
        }
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;
        if(this.lock) {
            this.setCurrentData(this.currentData);
            return;
        }
        this.lock = true;
        this._mdf = false;
        var i, len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
        for(i = 0; i < len; i += 1) {
            //Checking if index changed to prevent creating a new object every time the expression updates.
            if(currentIndex !== this.keysIndex) {
                finalValue = this.effectsSequence[i](finalValue, finalValue.t);
            } else {
                finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
            }
        }
        if(currentValue !== finalValue) {
            this.setCurrentData(finalValue);
        }
        this.pv = this.v = this.currentData;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
    };

    TextProperty.prototype.getKeyframeValue = function() {
        var textKeys = this.data.d.k, textDocumentData;
        var frameNum = this.elem.comp.renderedFrame;
        var i = 0, len = textKeys.length;
        while(i <= len - 1) {
            textDocumentData = textKeys[i].s;
            if(i === len - 1 || textKeys[i+1].t > frameNum){
                break;
            }
            i += 1;
        }
        if(this.keysIndex !== i) {
            this.keysIndex = i;
        }
        return this.data.d.k[this.keysIndex].s;
    };

    TextProperty.prototype.buildFinalText = function(text) {
        var combinedCharacters = FontManager.getCombinedCharacterCodes();
        var charactersArray = [];
        var i = 0, len = text.length;
        var charCode;
        while (i < len) {
            charCode = text.charCodeAt(i);
            if (combinedCharacters.indexOf(charCode) !== -1) {
                charactersArray[charactersArray.length - 1] += text.charAt(i);
            } else {
                if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                    charCode = text.charCodeAt(i + 1);
                    if (charCode >= 0xDC00 && charCode <= 0xDFFF) {
                        charactersArray.push(text.substr(i, 2));
                        ++i;
                    } else {
                        charactersArray.push(text.charAt(i));
                    }
                } else {
                    charactersArray.push(text.charAt(i));
                }
            }
            i += 1;
        }
        return charactersArray;
    };

    TextProperty.prototype.completeTextData = function(documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data = this.data;
        var letters = [];
        var i, len;
        var newLineFlag, index = 0, val;
        var anchorGrouping = data.m.g;
        var currentSize = 0, currentPos = 0, currentLine = 0, lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j, jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData, cLength = 0;
        var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];

        var fWeight = 'normal', fStyle = 'normal';
        len = styles.length;
        var styleName;
        for(i=0;i<len;i+=1){
            styleName = styles[i].toLowerCase();
            switch(styleName) {
                case 'italic':
                fStyle = 'italic';
                break;
                case 'bold':
                fWeight = '700';
                break;
                case 'black':
                fWeight = '900';
                break;
                case 'medium':
                fWeight = '500';
                break;
                case 'regular':
                case 'normal':
                fWeight = '400';
                break;
                case 'light':
                case 'thin':
                fWeight = '200';
                break;
            }
        }
        documentData.fWeight = fontData.fWeight || fWeight;
        documentData.fStyle = fStyle;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr/1000*documentData.finalSize;
        var charCode;
        if(documentData.sz){
            var flag = true;
            var boxWidth = documentData.sz[0];
            var boxHeight = documentData.sz[1];
            var currentHeight, finalText;
            while(flag) {
                finalText = this.buildFinalText(documentData.t);
                currentHeight = 0;
                lineWidth = 0;
                len = finalText.length;
                trackingOffset = documentData.tr/1000*documentData.finalSize;
                var lastSpaceIndex = -1;
                for(i=0;i<len;i+=1){
                    charCode = finalText[i].charCodeAt(0);
                    newLineFlag = false;
                    if(finalText[i] === ' '){
                        lastSpaceIndex = i;
                    }else if(charCode === 13 || charCode === 3){
                        lineWidth = 0;
                        newLineFlag = true;
                        currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;
                    }
                    if(fontManager.chars){
                        charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                        cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;
                    }else {
                        //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
                        cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
                    }
                    if(lineWidth + cLength > boxWidth && finalText[i] !== ' '){
                        if(lastSpaceIndex === -1){
                            len += 1;
                        } else {
                            i = lastSpaceIndex;
                        }
                        currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;
                        finalText.splice(i, lastSpaceIndex === i ? 1 : 0,"\r");
                        //finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
                        lastSpaceIndex = -1;
                        lineWidth = 0;
                    }else {
                        lineWidth += cLength;
                        lineWidth += trackingOffset;
                    }
                }
                currentHeight += fontData.ascent*documentData.finalSize/100;
                if(this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                    documentData.finalSize -= 1;
                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
                } else {
                    documentData.finalText = finalText;
                    len = documentData.finalText.length;
                    flag = false;
                }
            }

        }
        lineWidth = - trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;
        for (i = 0;i < len ;i += 1) {
            newLineFlag = false;
            currentChar = documentData.finalText[i];
            charCode = currentChar.charCodeAt(0);
            if (charCode === 13 || charCode === 3) {
                uncollapsedSpaces = 0;
                lineWidths.push(lineWidth);
                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
                lineWidth = - 2 * trackingOffset;
                val = '';
                newLineFlag = true;
                currentLine += 1;
            }else {
                val = currentChar;
            }
            if(fontManager.chars){
                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
                cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;
            }else {
                //var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
                //tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
                cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
            }

            //
            if(currentChar === ' '){
                uncollapsedSpaces += cLength + trackingOffset;
            } else {
                lineWidth += cLength + trackingOffset + uncollapsedSpaces;
                uncollapsedSpaces = 0;
            }
            letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag, anIndexes:[], val: val, line: currentLine, animatorJustifyOffset: 0});
            if(anchorGrouping == 2){
                currentSize += cLength;
                if(val === '' || val === ' ' || i === len - 1){
                    if(val === '' || val === ' '){
                        currentSize -= cLength;
                    }
                    while(currentPos<=i){
                        letters[currentPos].an = currentSize;
                        letters[currentPos].ind = index;
                        letters[currentPos].extra = cLength;
                        currentPos += 1;
                    }
                    index += 1;
                    currentSize = 0;
                }
            }else if(anchorGrouping == 3){
                currentSize += cLength;
                if(val === '' || i === len - 1){
                    if(val === ''){
                        currentSize -= cLength;
                    }
                    while(currentPos<=i){
                        letters[currentPos].an = currentSize;
                        letters[currentPos].ind = index;
                        letters[currentPos].extra = cLength;
                        currentPos += 1;
                    }
                    currentSize = 0;
                    index += 1;
                }
            }else {
                letters[index].ind = index;
                letters[index].extra = 0;
                index += 1;
            }
        }
        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);
        if(documentData.sz){
            documentData.boxWidth = documentData.sz[0];
            documentData.justifyOffset = 0;
        }else {
            documentData.boxWidth = maxLineWidth;
            switch(documentData.j){
                case 1:
                    documentData.justifyOffset = - documentData.boxWidth;
                    break;
                case 2:
                    documentData.justifyOffset = - documentData.boxWidth/2;
                    break;
                default:
                    documentData.justifyOffset = 0;
            }
        }
        documentData.lineWidths = lineWidths;

        var animators = data.a, animatorData, letterData;
        jLen = animators.length;
        var based, ind, indexes = [];
        for(j=0;j<jLen;j+=1){
            animatorData = animators[j];
            if(animatorData.a.sc){
                documentData.strokeColorAnim = true;
            }
            if(animatorData.a.sw){
                documentData.strokeWidthAnim = true;
            }
            if(animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb){
                documentData.fillColorAnim = true;
            }
            ind = 0;
            based = animatorData.s.b;
            for(i=0;i<len;i+=1){
                letterData = letters[i];
                letterData.anIndexes[j] = ind;
                if((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== ' ') || (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))){
                    if(animatorData.s.rn === 1){
                        indexes.push(ind);
                    }
                    ind += 1;
                }
            }
            data.a[j].s.totalChars = ind;
            var currentInd = -1, newInd;
            if(animatorData.s.rn === 1){
                for(i = 0; i < len; i += 1){
                    letterData = letters[i];
                    if(currentInd != letterData.anIndexes[j]){
                        currentInd = letterData.anIndexes[j];
                        newInd = indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];
                    }
                    letterData.anIndexes[j] = newInd;
                }
            }
        }
        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize*1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent*documentData.finalSize/100;
    };

    TextProperty.prototype.updateDocumentData = function(newData, index) {
    	index = index === undefined ? this.keysIndex : index;
        var dData = this.copyData({}, this.data.d.k[index].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index].s = dData;
        this.recalculate(index);
        this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.recalculate = function(index) {
        var dData = this.data.d.k[index].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
    };

    TextProperty.prototype.canResizeFont = function(_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
    };

    var TextSelectorProp = (function(){
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;

        function TextSelectorProp(elem,data){
            this._currentTextLength = -1;
            this.k = false;
            this.data = data;
            this.elem = elem;
            this.comp = elem.comp;
            this.finalS = 0;
            this.finalE = 0;
            this.initDynamicPropertyContainer(elem);
            this.s = PropertyFactory.getProp(elem,data.s || {k:0},0,0,this);
            if('e' in data){
                this.e = PropertyFactory.getProp(elem,data.e,0,0,this);
            }else {
                this.e = {v:100};
            }
            this.o = PropertyFactory.getProp(elem,data.o || {k:0},0,0,this);
            this.xe = PropertyFactory.getProp(elem,data.xe || {k:0},0,0,this);
            this.ne = PropertyFactory.getProp(elem,data.ne || {k:0},0,0,this);
            this.a = PropertyFactory.getProp(elem,data.a,0,0.01,this);
            if(!this.dynamicProperties.length){
                this.getValue();
            }
        }

        TextSelectorProp.prototype = {
            getMult: function(ind) {
                if(this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                    this.getValue();
                }
                //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
                var x1 = 0;
                var y1 = 0;
                var x2 = 1;
                var y2 = 1;
                if(this.ne.v > 0) {
                    x1 = this.ne.v / 100.0;
                }
                else {
                    y1 = -this.ne.v / 100.0;
                }
                if(this.xe.v > 0) {
                    x2 = 1.0 - this.xe.v / 100.0;
                }
                else {
                    y2 = 1.0 + this.xe.v / 100.0;
                }
                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;

                var mult = 0;
                var s = this.finalS;
                var e = this.finalE;
                var type = this.data.sh;
                if (type === 2){
                    if (e === s) {
                        mult = ind >= e ? 1 : 0;
                    } else {
                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                    }
                    mult = easer(mult);
                } else if(type === 3) {
                    if (e === s) {
                        mult = ind >= e ? 0 : 1;
                    }else {
                        mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s),1));
                    }

                    mult = easer(mult);
                } else if (type === 4) {
                    if (e === s) {
                        mult = 0;
                    } else {
                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
                        if (mult < 0.5) {
                            mult *= 2;
                        } else {
                            mult = 1 - 2 * (mult - 0.5);
                        }
                    }
                    mult = easer(mult);
                } else if (type === 5) {
                    if (e === s){
                        mult = 0;
                    } else {
                        var tot = e - s;
                        /*ind += 0.5;
                        mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/
                        ind = min(max(0, ind + 0.5 - s), e - s);
                        var x = -tot/2+ind;
                        var a = tot/2;
                        mult = Math.sqrt(1 - (x * x) / (a * a));
                    }
                    mult = easer(mult);
                } else if (type === 6) {
                    if (e === s){
                        mult = 0;
                    } else {
                        ind = min(max(0, ind + 0.5 - s), e - s);
                        mult = (1 + (Math.cos((Math.PI + Math.PI * 2 * (ind) / (e - s))))) / 2;
                    }
                    mult = easer(mult);
                } else {
                    if (ind >= floor(s)) {
                        if (ind - s < 0) {
                            mult = max(0, min(min(e, 1) - (s - ind), 1));
                        } else {
                            mult = max(0, min(e - ind, 1));
                        }
                    }
                    mult = easer(mult);
                }
                return mult*this.a.v;
            },
            getValue: function(newCharsFlag) {
                this.iterateDynamicProperties();
                this._mdf = newCharsFlag || this._mdf;
                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
                if(newCharsFlag && this.data.r === 2) {
                    this.e.v = this._currentTextLength;
                }
                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
                var o = this.o.v/divisor;
                var s = this.s.v/divisor + o;
                var e = (this.e.v/divisor) + o;
                if(s>e){
                    var _s = s;
                    s = e;
                    e = _s;
                }
                this.finalS = s;
                this.finalE = e;
            }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorProp);

        function getTextSelectorProp(elem, data,arr) {
            return new TextSelectorProp(elem, data, arr);
        }

        return {
            getTextSelectorProp: getTextSelectorProp
        };
    }());

        
    var pool_factory = (function() {
    	return function(initialLength, _create, _release, _clone) {

    		var _length = 0;
    		var _maxLength = initialLength;
    		var pool = createSizedArray(_maxLength);

    		var ob = {
    			newElement: newElement,
    			release: release
    		};

    		function newElement(){
    			var element;
    			if(_length){
    				_length -= 1;
    				element = pool[_length];
    			} else {
    				element = _create();
    			}
    			return element;
    		}

    		function release(element) {
    			if(_length === _maxLength) {
    				pool = pooling.double(pool);
    				_maxLength = _maxLength*2;
    			}
    			if (_release) {
    				_release(element);
    			}
    			pool[_length] = element;
    			_length += 1;
    		}

    		return ob;
    	};
    }());

    var pooling = (function(){

    	function double(arr){
    		return arr.concat(createSizedArray(arr.length));
    	}

    	return {
    		double: double
    	};
    }());
    var point_pool = (function(){

    	function create() {
    		return createTypedArray('float32', 2);
    	}
    	return pool_factory(8, create);
    }());
    var shape_pool = (function(){

    	function create() {
    		return new ShapePath();
    	}

    	function release(shapePath) {
    		var len = shapePath._length, i;
    		for(i = 0; i < len; i += 1) {
    			point_pool.release(shapePath.v[i]);
    			point_pool.release(shapePath.i[i]);
    			point_pool.release(shapePath.o[i]);
    			shapePath.v[i] = null;
    			shapePath.i[i] = null;
    			shapePath.o[i] = null;
    		}
    		shapePath._length = 0;
    		shapePath.c = false;
    	}

    	function clone(shape) {
    		var cloned = factory.newElement();
    		var i, len = shape._length === undefined ? shape.v.length : shape._length;
    		cloned.setLength(len);
    		cloned.c = shape.c;
    		
    		for(i = 0; i < len; i += 1) {
    			cloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1], i);
    		}
    		return cloned;
    	}

    	var factory = pool_factory(4, create, release);
    	factory.clone = clone;

    	return factory;
    }());
    var shapeCollection_pool = (function(){
    	var ob = {
    		newShapeCollection: newShapeCollection,
    		release: release
    	};

    	var _length = 0;
    	var _maxLength = 4;
    	var pool = createSizedArray(_maxLength);

    	function newShapeCollection(){
    		var shapeCollection;
    		if(_length){
    			_length -= 1;
    			shapeCollection = pool[_length];
    		} else {
    			shapeCollection = new ShapeCollection();
    		}
    		return shapeCollection;
    	}

    	function release(shapeCollection) {
    		var i, len = shapeCollection._length;
    		for(i = 0; i < len; i += 1) {
    			shape_pool.release(shapeCollection.shapes[i]);
    		}
    		shapeCollection._length = 0;

    		if(_length === _maxLength) {
    			pool = pooling.double(pool);
    			_maxLength = _maxLength*2;
    		}
    		pool[_length] = shapeCollection;
    		_length += 1;
    	}

    	return ob;
    }());
    var segments_length_pool = (function(){

    	function create() {
    		return {
    			lengths: [],
    			totalLength: 0
    		};
    	}

    	function release(element) {
    		var i, len = element.lengths.length;
    		for(i=0;i<len;i+=1) {
    			bezier_length_pool.release(element.lengths[i]);
    		}
    		element.lengths.length = 0;
    	}

    	return pool_factory(8, create, release);
    }());
    var bezier_length_pool = (function(){

    	function create() {
    		return {
                addedLength: 0,
                percents: createTypedArray('float32', defaultCurveSegments),
                lengths: createTypedArray('float32', defaultCurveSegments),
            };
    	}
    	return pool_factory(8, create);
    }());
    function BaseRenderer(){}
    BaseRenderer.prototype.checkLayers = function(num){
        var i, len = this.layers.length, data;
        this.completeLayers = true;
        for (i = len - 1; i >= 0; i--) {
            if (!this.elements[i]) {
                data = this.layers[i];
                if(data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st))
                {
                    this.buildItem(i);
                }
            }
            this.completeLayers = this.elements[i] ? this.completeLayers:false;
        }
        this.checkPendingElements();
    };

    BaseRenderer.prototype.createItem = function(layer){
        switch(layer.ty){
            case 2:
                return this.createImage(layer);
            case 0:
                return this.createComp(layer);
            case 1:
                return this.createSolid(layer);
            case 3:
                return this.createNull(layer);
            case 4:
                return this.createShape(layer);
            case 5:
                return this.createText(layer);
            case 13:
                return this.createCamera(layer);
        }
        return this.createNull(layer);
    };

    BaseRenderer.prototype.createCamera = function(){
        throw new Error('You\'re using a 3d camera. Try the html renderer.');
    };

    BaseRenderer.prototype.buildAllItems = function(){
        var i, len = this.layers.length;
        for(i=0;i<len;i+=1){
            this.buildItem(i);
        }
        this.checkPendingElements();
    };

    BaseRenderer.prototype.includeLayers = function(newLayers){
        this.completeLayers = false;
        var i, len = newLayers.length;
        var j, jLen = this.layers.length;
        for(i=0;i<len;i+=1){
            j = 0;
            while(j<jLen){
                if(this.layers[j].id == newLayers[i].id){
                    this.layers[j] = newLayers[i];
                    break;
                }
                j += 1;
            }
        }
    };

    BaseRenderer.prototype.setProjectInterface = function(pInterface){
        this.globalData.projectInterface = pInterface;
    };

    BaseRenderer.prototype.initItems = function(){
        if(!this.globalData.progressiveLoad){
            this.buildAllItems();
        }
    };
    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i=0, len = layers.length;
        while (i < len) {
            if (layers[i].ind == parentName) {
                if (!elements[i] || elements[i] === true) {
                    this.buildItem(i);
                    this.addPendingElement(element);
                } else {
                    hierarchy.push(elements[i]);
                    elements[i].setAsParent();
                    if(layers[i].parent !== undefined) {
                        this.buildElementParenting(element, layers[i].parent, hierarchy);
                    } else {
                        element.setHierarchy(hierarchy);
                    }
                }
            }
            i += 1;
        }
    };

    BaseRenderer.prototype.addPendingElement = function(element){
        this.pendingElements.push(element);
    };

    BaseRenderer.prototype.searchExtraCompositions = function(assets){
        var i, len = assets.length;
        for(i=0;i<len;i+=1){
            if(assets[i].xt){
                var comp = this.createComp(assets[i]);
                comp.initExpressions();
                this.globalData.projectInterface.registerComposition(comp);
            }
        }
    };

    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
            w: animData.w,
            h: animData.h
        };
    };
    function SVGRenderer(animationItem, config){
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS('svg');
        var ariaLabel = '';
        if (config && config.title) {
            var titleElement = createNS('title');
            var titleId = createElementID();
            titleElement.setAttribute('id', titleId);
            titleElement.textContent = config.title;
            this.svgElement.appendChild(titleElement);
            ariaLabel += titleId;
        }
        if (config && config.description) {
            var descElement = createNS('desc');
            var descId = createElementID();
            descElement.setAttribute('id', descId);
            descElement.textContent = config.description;
            this.svgElement.appendChild(descElement);
            ariaLabel += ' ' + descId;
        }
        if (ariaLabel) {
            this.svgElement.setAttribute('aria-labelledby', ariaLabel);
        }
        var defs = createNS( 'defs');
        this.svgElement.appendChild(defs);
        var maskElement = createNS('g');
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
            preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
            imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
            progressiveLoad: (config && config.progressiveLoad) || false,
            hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true,
            viewBoxOnly: (config && config.viewBoxOnly) || false,
            viewBoxSize: (config && config.viewBoxSize) || false,
            className: (config && config.className) || '',
            id: (config && config.id) || '',
            focusable: config && config.focusable,
            filterSize: {
                width: config && config.filterSize && config.filterSize.width || '100%',
                height: config && config.filterSize && config.filterSize.height || '100%',
                x: config && config.filterSize && config.filterSize.x || '0%',
                y: config && config.filterSize && config.filterSize.y || '0%',
            }
        };

        this.globalData = {
            _mdf: false,
            frameNum: -1,
            defs: defs,
            renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = 'svg';

    }

    extendPrototype([BaseRenderer],SVGRenderer);

    SVGRenderer.prototype.createNull = function (data) {
        return new NullElement(data,this.globalData,this);
    };

    SVGRenderer.prototype.createShape = function (data) {
        return new SVGShapeElement(data,this.globalData,this);
    };

    SVGRenderer.prototype.createText = function (data) {
        return new SVGTextElement(data,this.globalData,this);

    };

    SVGRenderer.prototype.createImage = function (data) {
        return new IImageElement(data,this.globalData,this);
    };

    SVGRenderer.prototype.createComp = function (data) {
        return new SVGCompElement(data,this.globalData,this);

    };

    SVGRenderer.prototype.createSolid = function (data) {
        return new ISolidElement(data,this.globalData,this);
    };

    SVGRenderer.prototype.configAnimation = function(animData){
        this.svgElement.setAttribute('xmlns','http://www.w3.org/2000/svg');
        if(this.renderConfig.viewBoxSize) {
            this.svgElement.setAttribute('viewBox',this.renderConfig.viewBoxSize);
        } else {
            this.svgElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);
        }

        if(!this.renderConfig.viewBoxOnly) {
            this.svgElement.setAttribute('width',animData.w);
            this.svgElement.setAttribute('height',animData.h);
            this.svgElement.style.width = '100%';
            this.svgElement.style.height = '100%';
            this.svgElement.style.transform = 'translate3d(0,0,0)';
        }
        if (this.renderConfig.className) {
            this.svgElement.setAttribute('class', this.renderConfig.className);
        }
        if (this.renderConfig.id) {
            this.svgElement.setAttribute('id', this.renderConfig.id);
        }
        if (this.renderConfig.focusable !== undefined) {
            this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
        }
        this.svgElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);
        //this.layerElement.style.transform = 'translate3d(0,0,0)';
        //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
        this.animationItem.wrapper.appendChild(this.svgElement);
        //Mask animation
        var defs = this.globalData.defs;

        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;

        var maskElement = createNS( 'clipPath');
        var rect = createNS('rect');
        rect.setAttribute('width',animData.w);
        rect.setAttribute('height',animData.h);
        rect.setAttribute('x',0);
        rect.setAttribute('y',0);
        var maskId = createElementID();
        maskElement.setAttribute('id', maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#"+maskId+")");

        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
    };


    SVGRenderer.prototype.destroy = function () {
        this.animationItem.wrapper.innerHTML = '';
        this.layerElement = null;
        this.globalData.defs = null;
        var i, len = this.layers ? this.layers.length : 0;
        for (i = 0; i < len; i++) {
            if(this.elements[i]){
                this.elements[i].destroy();
            }
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
    };

    SVGRenderer.prototype.updateContainerSize = function () {
    };

    SVGRenderer.prototype.buildItem  = function(pos){
        var elements = this.elements;
        if(elements[pos] || this.layers[pos].ty == 99){
            return;
        }
        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);

        elements[pos] = element;
        if(expressionsPlugin){
            if(this.layers[pos].ty === 0){
                this.globalData.projectInterface.registerComposition(element);
            }
            element.initExpressions();
        }
        this.appendElementInPos(element,pos);
        if(this.layers[pos].tt){
            if(!this.elements[pos - 1] || this.elements[pos - 1] === true){
                this.buildItem(pos - 1);
                this.addPendingElement(element);
            } else {
                element.setMatte(elements[pos - 1].layerId);
            }
        }
    };

    SVGRenderer.prototype.checkPendingElements  = function(){
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
            if(element.data.tt){
                var i = 0, len = this.elements.length;
                while(i<len){
                    if(this.elements[i] === element){
                        element.setMatte(this.elements[i - 1].layerId);
                        break;
                    }
                    i += 1;
                }
            }
        }
    };

    SVGRenderer.prototype.renderFrame = function(num){
        if(this.renderedFrame === num || this.destroyed){
            return;
        }
        if(num === null){
            num = this.renderedFrame;
        }else {
            this.renderedFrame = num;
        }
        // console.log('-------');
        // console.log('FRAME ',num);
        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i, len = this.layers.length;
        if(!this.completeLayers){
            this.checkLayers(num);
        }
        for (i = len - 1; i >= 0; i--) {
            if(this.completeLayers || this.elements[i]){
                this.elements[i].prepareFrame(num - this.layers[i].st);
            }
        }
        if(this.globalData._mdf) {
            for (i = 0; i < len; i += 1) {
                if(this.completeLayers || this.elements[i]){
                    this.elements[i].renderFrame();
                }
            }
        }
    };

    SVGRenderer.prototype.appendElementInPos = function(element, pos){
        var newElement = element.getBaseElement();
        if(!newElement){
            return;
        }
        var i = 0;
        var nextElement;
        while(i<pos){
            if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement()){
                nextElement = this.elements[i].getBaseElement();
            }
            i += 1;
        }
        if(nextElement){
            this.layerElement.insertBefore(newElement, nextElement);
        } else {
            this.layerElement.appendChild(newElement);
        }
    };

    SVGRenderer.prototype.hide = function(){
        this.layerElement.style.display = 'none';
    };

    SVGRenderer.prototype.show = function(){
        this.layerElement.style.display = 'block';
    };

    function CanvasRenderer(animationItem, config){
        this.animationItem = animationItem;
        this.renderConfig = {
            clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
            context: (config && config.context) || null,
            progressiveLoad: (config && config.progressiveLoad) || false,
            preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
            imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
            className: (config && config.className) || '',
            id: (config && config.id) || '',
        };
        this.renderConfig.dpr = (config && config.dpr) || 1;
        if (this.animationItem.wrapper) {
            this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
        }
        this.renderedFrame = -1;
        this.globalData = {
            frameNum: -1,
            _mdf: false,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = 'canvas';
    }
    extendPrototype([BaseRenderer],CanvasRenderer);

    CanvasRenderer.prototype.createShape = function (data) {
        return new CVShapeElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createText = function (data) {
        return new CVTextElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createImage = function (data) {
        return new CVImageElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createComp = function (data) {
        return new CVCompElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createSolid = function (data) {
        return new CVSolidElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

    CanvasRenderer.prototype.ctxTransform = function(props){
        if(props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0){
            return;
        }
        if(!this.renderConfig.clearCanvas){
            this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);
            return;
        }
        this.transformMat.cloneFromProps(props);
        var cProps = this.contextData.cTr.props;
        this.transformMat.transform(cProps[0],cProps[1],cProps[2],cProps[3],cProps[4],cProps[5],cProps[6],cProps[7],cProps[8],cProps[9],cProps[10],cProps[11],cProps[12],cProps[13],cProps[14],cProps[15]);
        //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
        this.contextData.cTr.cloneFromProps(this.transformMat.props);
        var trProps = this.contextData.cTr.props;
        this.canvasContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);
    };

    CanvasRenderer.prototype.ctxOpacity = function(op){
        /*if(op === 1){
            return;
        }*/
        if(!this.renderConfig.clearCanvas){
            this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
            this.globalData.currentGlobalAlpha = this.contextData.cO;
            return;
        }
        this.contextData.cO *= op < 0 ? 0 : op;
        if(this.globalData.currentGlobalAlpha !== this.contextData.cO) {
            this.canvasContext.globalAlpha = this.contextData.cO;
            this.globalData.currentGlobalAlpha = this.contextData.cO;
        }
    };

    CanvasRenderer.prototype.reset = function(){
        if(!this.renderConfig.clearCanvas){
            this.canvasContext.restore();
            return;
        }
        this.contextData.reset();
    };

    CanvasRenderer.prototype.save = function(actionFlag){
        if(!this.renderConfig.clearCanvas){
            this.canvasContext.save();
            return;
        }
        if(actionFlag){
            this.canvasContext.save();
        }
        var props = this.contextData.cTr.props;
        if(this.contextData._length <= this.contextData.cArrPos) {
            this.contextData.duplicate();
        }
        var i, arr = this.contextData.saved[this.contextData.cArrPos];
        for (i = 0; i < 16; i += 1) {
            arr[i] = props[i];
        }
        this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
        this.contextData.cArrPos += 1;
    };

    CanvasRenderer.prototype.restore = function(actionFlag){
        if(!this.renderConfig.clearCanvas){
            this.canvasContext.restore();
            return;
        }
        if(actionFlag){
            this.canvasContext.restore();
            this.globalData.blendMode = 'source-over';
        }
        this.contextData.cArrPos -= 1;
        var popped = this.contextData.saved[this.contextData.cArrPos];
        var i,arr = this.contextData.cTr.props;
        for(i=0;i<16;i+=1){
            arr[i] = popped[i];
        }
        this.canvasContext.setTransform(popped[0],popped[1],popped[4],popped[5],popped[12],popped[13]);
        popped = this.contextData.savedOp[this.contextData.cArrPos];
        this.contextData.cO = popped;
        if(this.globalData.currentGlobalAlpha !== popped) {
            this.canvasContext.globalAlpha = popped;
            this.globalData.currentGlobalAlpha = popped;
        }
    };

    CanvasRenderer.prototype.configAnimation = function(animData){
        if(this.animationItem.wrapper){
            this.animationItem.container = createTag('canvas');
            this.animationItem.container.style.width = '100%';
            this.animationItem.container.style.height = '100%';
            //this.animationItem.container.style.transform = 'translate3d(0,0,0)';
            //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';
            this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = "0px 0px 0px";
            this.animationItem.wrapper.appendChild(this.animationItem.container);
            this.canvasContext = this.animationItem.container.getContext('2d');
            if(this.renderConfig.className) {
                this.animationItem.container.setAttribute('class', this.renderConfig.className);
            }
            if(this.renderConfig.id) {
                this.animationItem.container.setAttribute('id', this.renderConfig.id);
            }
        }else {
            this.canvasContext = this.renderConfig.context;
        }
        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
            w: animData.w,
            h:animData.h,
            sx:0,
            sy:0,
            tx:0,
            ty:0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);

        this.updateContainerSize();
    };

    CanvasRenderer.prototype.updateContainerSize = function () {
        this.reset();
        var elementWidth,elementHeight;
        if(this.animationItem.wrapper && this.animationItem.container){
            elementWidth = this.animationItem.wrapper.offsetWidth;
            elementHeight = this.animationItem.wrapper.offsetHeight;
            this.animationItem.container.setAttribute('width',elementWidth * this.renderConfig.dpr );
            this.animationItem.container.setAttribute('height',elementHeight * this.renderConfig.dpr);
        }else {
            elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
            elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
        }
        var elementRel,animationRel;
        if(this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1){
            var par = this.renderConfig.preserveAspectRatio.split(' ');
            var fillType = par[1] || 'meet';
            var pos = par[0] || 'xMidYMid';
            var xPos = pos.substr(0,4);
            var yPos = pos.substr(4);
            elementRel = elementWidth/elementHeight;
            animationRel = this.transformCanvas.w/this.transformCanvas.h;
            if(animationRel>elementRel && fillType === 'meet' || animationRel<elementRel && fillType === 'slice'){
                this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
                this.transformCanvas.sy = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
            }else {
                this.transformCanvas.sx = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
                this.transformCanvas.sy = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);
            }

            if(xPos === 'xMid' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
                this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;
            } else if(xPos === 'xMax' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){
                this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;
            } else {
                this.transformCanvas.tx = 0;
            }
            if(yPos === 'YMid' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
                this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2)*this.renderConfig.dpr;
            } else if(yPos === 'YMax' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){
                this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w)))*this.renderConfig.dpr;
            } else {
                this.transformCanvas.ty = 0;
            }

        }else if(this.renderConfig.preserveAspectRatio == 'none'){
            this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
        }else {
            this.transformCanvas.sx = this.renderConfig.dpr;
            this.transformCanvas.sy = this.renderConfig.dpr;
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
        }
        this.transformCanvas.props = [this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];
        /*var i, len = this.elements.length;
        for(i=0;i<len;i+=1){
            if(this.elements[i] && this.elements[i].data.ty === 0){
                this.elements[i].resize(this.globalData.transformCanvas);
            }
        }*/
        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();

        this.renderFrame(this.renderedFrame, true);
    };

    CanvasRenderer.prototype.destroy = function () {
        if(this.renderConfig.clearCanvas) {
            this.animationItem.wrapper.innerHTML = '';
        }
        var i, len = this.layers ? this.layers.length : 0;
        for (i = len - 1; i >= 0; i-=1) {
            if(this.elements[i]) {
                this.elements[i].destroy();
            }
        }
        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
    };

    CanvasRenderer.prototype.renderFrame = function(num, forceRender){
        if((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1){
            return;
        }
        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num;

         // console.log('--------');
         // console.log('NEW: ',num);
        var i, len = this.layers.length;
        if(!this.completeLayers){
            this.checkLayers(num);
        }

        for (i = 0; i < len; i++) {
            if(this.completeLayers || this.elements[i]){
                this.elements[i].prepareFrame(num - this.layers[i].st);
            }
        }
        if(this.globalData._mdf) {
            if(this.renderConfig.clearCanvas === true){
                this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
            }else {
                this.save();
            }
            for (i = len - 1; i >= 0; i-=1) {
                if(this.completeLayers || this.elements[i]){
                    this.elements[i].renderFrame();
                }
            }
            if(this.renderConfig.clearCanvas !== true){
                this.restore();
            }
        }
    };

    CanvasRenderer.prototype.buildItem = function(pos){
        var elements = this.elements;
        if(elements[pos] || this.layers[pos].ty == 99){
            return;
        }
        var element = this.createItem(this.layers[pos], this,this.globalData);
        elements[pos] = element;
        element.initExpressions();
        /*if(this.layers[pos].ty === 0){
            element.resize(this.globalData.transformCanvas);
        }*/
    };

    CanvasRenderer.prototype.checkPendingElements  = function(){
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
        }
    };

    CanvasRenderer.prototype.hide = function(){
        this.animationItem.container.style.display = 'none';
    };

    CanvasRenderer.prototype.show = function(){
        this.animationItem.container.style.display = 'block';
    };

    function HybridRenderer(animationItem, config){
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
            className: (config && config.className) || '',
            imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
            hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true,
            filterSize: {
                width: config && config.filterSize && config.filterSize.width || '400%',
                height: config && config.filterSize && config.filterSize.height || '400%',
                x: config && config.filterSize && config.filterSize.x || '-100%',
                y: config && config.filterSize && config.filterSize.y || '-100%',
            }
        };
        this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = 'html';

    }

    extendPrototype([BaseRenderer],HybridRenderer);

    HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

    HybridRenderer.prototype.checkPendingElements  = function(){
        while(this.pendingElements.length){
            var element = this.pendingElements.pop();
            element.checkParenting();
        }
    };

    HybridRenderer.prototype.appendElementInPos = function(element, pos){
        var newDOMElement = element.getBaseElement();
        if(!newDOMElement){
            return;
        }
        var layer = this.layers[pos];
        if(!layer.ddd || !this.supports3d){
            if(this.threeDElements) {
                this.addTo3dContainer(newDOMElement,pos);
            } else {
                var i = 0;
                var nextDOMElement, nextLayer, tmpDOMElement;
                while(i<pos){
                    if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement){
                        nextLayer = this.elements[i];
                        tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                        nextDOMElement = tmpDOMElement || nextDOMElement;
                    }
                    i += 1;
                }
                if(nextDOMElement){
                    if(!layer.ddd || !this.supports3d){
                        this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                    }
                } else {
                    if(!layer.ddd || !this.supports3d){
                        this.layerElement.appendChild(newDOMElement);
                    }
                }
            }
            
        } else {
            this.addTo3dContainer(newDOMElement,pos);
        }
    };

    HybridRenderer.prototype.createShape = function (data) {
        if(!this.supports3d){
            return new SVGShapeElement(data, this.globalData, this);
        }
        return new HShapeElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createText = function (data) {
        if(!this.supports3d){
            return new SVGTextElement(data, this.globalData, this);
        }
        return new HTextElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createCamera = function (data) {
        this.camera = new HCameraElement(data, this.globalData, this);
        return this.camera;
    };

    HybridRenderer.prototype.createImage = function (data) {
        if(!this.supports3d){
            return new IImageElement(data, this.globalData, this);
        }
        return new HImageElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createComp = function (data) {
        if(!this.supports3d){
            return new SVGCompElement(data, this.globalData, this);
        }
        return new HCompElement(data, this.globalData, this);

    };

    HybridRenderer.prototype.createSolid = function (data) {
        if(!this.supports3d){
            return new ISolidElement(data, this.globalData, this);
        }
        return new HSolidElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

    HybridRenderer.prototype.getThreeDContainerByPos = function(pos){
        var i = 0, len = this.threeDElements.length;
        while(i<len) {
            if(this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
                return this.threeDElements[i].perspectiveElem;
            }
            i += 1;
        }
    };

    HybridRenderer.prototype.createThreeDContainer = function(pos, type){
        var perspectiveElem = createTag('div');
        styleDiv(perspectiveElem);
        var container = createTag('div');
        styleDiv(container);
        if(type === '3d') {
            perspectiveElem.style.width = this.globalData.compSize.w+'px';
            perspectiveElem.style.height = this.globalData.compSize.h+'px';
            perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = "50% 50%";
            container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
        }
        
        perspectiveElem.appendChild(container);
        //this.resizerElem.appendChild(perspectiveElem);
        var threeDContainerData = {
            container:container,
            perspectiveElem:perspectiveElem,
            startPos: pos,
            endPos: pos,
            type: type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
    };

    HybridRenderer.prototype.build3dContainers = function(){
        var i, len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = '';
        for(i=0;i<len;i+=1){
            if(this.layers[i].ddd && this.layers[i].ty !== 3){
                if(currentContainer !== '3d'){
                    currentContainer = '3d';
                    lastThreeDContainerData = this.createThreeDContainer(i,'3d');
                }
                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
            } else {
                if(currentContainer !== '2d'){
                    currentContainer = '2d';
                    lastThreeDContainerData = this.createThreeDContainer(i,'2d');
                }
                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);
            }
        }
        len = this.threeDElements.length;
        for(i = len - 1; i >= 0; i --) {
            this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
        }
    };

    HybridRenderer.prototype.addTo3dContainer = function(elem,pos){
        var i = 0, len = this.threeDElements.length;
        while(i<len){
            if(pos <= this.threeDElements[i].endPos){
                var j = this.threeDElements[i].startPos;
                var nextElement;
                while(j<pos){
                    if(this.elements[j] && this.elements[j].getBaseElement){
                        nextElement = this.elements[j].getBaseElement();
                    }
                    j += 1;
                }
                if(nextElement){
                    this.threeDElements[i].container.insertBefore(elem, nextElement);
                } else {
                    this.threeDElements[i].container.appendChild(elem);
                }
                break;
            }
            i += 1;
        }
    };

    HybridRenderer.prototype.configAnimation = function(animData){
        var resizerElem = createTag('div');
        var wrapper = this.animationItem.wrapper;
        resizerElem.style.width = animData.w+'px';
        resizerElem.style.height = animData.h+'px';
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = "flat";
        if(this.renderConfig.className) {
          resizerElem.setAttribute('class', this.renderConfig.className);
        }
        wrapper.appendChild(resizerElem);

        resizerElem.style.overflow = 'hidden';
        var svg = createNS('svg');
        svg.setAttribute('width','1');
        svg.setAttribute('height','1');
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS('defs');
        svg.appendChild(defs);
        this.data = animData;
        //Mask animation
        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
    };

    HybridRenderer.prototype.destroy = function () {
        this.animationItem.wrapper.innerHTML = '';
        this.animationItem.container = null;
        this.globalData.defs = null;
        var i, len = this.layers ? this.layers.length : 0;
        for (i = 0; i < len; i++) {
            this.elements[i].destroy();
        }
        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
    };

    HybridRenderer.prototype.updateContainerSize = function () {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth/elementHeight;
        var animationRel = this.globalData.compSize.w/this.globalData.compSize.h;
        var sx,sy,tx,ty;
        if(animationRel>elementRel){
            sx = elementWidth/(this.globalData.compSize.w);
            sy = elementWidth/(this.globalData.compSize.w);
            tx = 0;
            ty = ((elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2);
        }else {
            sx = elementHeight/(this.globalData.compSize.h);
            sy = elementHeight/(this.globalData.compSize.h);
            tx = (elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;
            ty = 0;
        }
        this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';
    };

    HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

    HybridRenderer.prototype.hide = function(){
        this.resizerElem.style.display = 'none';
    };

    HybridRenderer.prototype.show = function(){
        this.resizerElem.style.display = 'block';
    };

    HybridRenderer.prototype.initItems = function(){
        this.buildAllItems();
        if(this.camera){
            this.camera.setup();
        } else {
            var cWidth = this.globalData.compSize.w;
            var cHeight = this.globalData.compSize.h;
            var i, len = this.threeDElements.length;
            for(i=0;i<len;i+=1){
                this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth,2) + Math.pow(cHeight,2)) + 'px';
            }
        }
    };

    HybridRenderer.prototype.searchExtraCompositions = function(assets){
        var i, len = assets.length;
        var floatingContainer = createTag('div');
        for(i=0;i<len;i+=1){
            if(assets[i].xt){
                var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);
                comp.initExpressions();
                this.globalData.projectInterface.registerComposition(comp);
            }
        }
    };

    function MaskElement(data,element,globalData) {
        this.data = data;
        this.element = element;
        this.globalData = globalData;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i, len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = '';


        var path, properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j, jLen;
        var layerId = createElementID();
        var rect, expansor, feMorph,x;
        var maskType = 'clipPath', maskRef = 'clip-path';
        for (i = 0; i < len; i++) {
            if((properties[i].mode !== 'a' && properties[i].mode !== 'n')|| properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x){
                maskType = 'mask';
                maskRef = 'mask';
            }

            if((properties[i].mode == 's' || properties[i].mode == 'i') && count === 0){
                rect = createNS( 'rect');
                rect.setAttribute('fill', '#ffffff');
                rect.setAttribute('width', this.element.comp.data.w || 0);
                rect.setAttribute('height', this.element.comp.data.h || 0);
                currentMasks.push(rect);
            } else {
                rect = null;
            }

            path = createNS( 'path');
            if(properties[i].mode == 'n') {
                // TODO move this to a factory or to a constructor
                this.viewData[i] = {
                    op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),
                    prop: ShapePropertyFactory.getShapeProp(this.element,properties[i],3),
                    elem: path,
                    lastPath: ''
                };
                defs.appendChild(path);
                continue;
            }
            count += 1;

            path.setAttribute('fill', properties[i].mode === 's' ? '#000000':'#ffffff');
            path.setAttribute('clip-rule','nonzero');
            var filterID;

            if (properties[i].x.k !== 0) {
                maskType = 'mask';
                maskRef = 'mask';
                x = PropertyFactory.getProp(this.element,properties[i].x,0,null,this.element);
                filterID = createElementID();
                expansor = createNS('filter');
                expansor.setAttribute('id',filterID);
                feMorph = createNS('feMorphology');
                feMorph.setAttribute('operator','erode');
                feMorph.setAttribute('in','SourceGraphic');
                feMorph.setAttribute('radius','0');
                expansor.appendChild(feMorph);
                defs.appendChild(expansor);
                path.setAttribute('stroke', properties[i].mode === 's' ? '#000000':'#ffffff');
            } else {
                feMorph = null;
                x = null;
            }

            // TODO move this to a factory or to a constructor
            this.storedData[i] = {
                 elem: path,
                 x: x,
                 expan: feMorph,
                lastPath: '',
                lastOperator:'',
                filterId:filterID,
                lastRadius:0
            };
            if(properties[i].mode == 'i'){
                jLen = currentMasks.length;
                var g = createNS('g');
                for(j=0;j<jLen;j+=1){
                    g.appendChild(currentMasks[j]);
                }
                var mask = createNS('mask');
                mask.setAttribute('mask-type','alpha');
                mask.setAttribute('id',layerId+'_'+count);
                mask.appendChild(path);
                defs.appendChild(mask);
                g.setAttribute('mask','url(' + locationHref + '#'+layerId+'_'+count+')');

                currentMasks.length = 0;
                currentMasks.push(g);
            }else {
                currentMasks.push(path);
            }
            if(properties[i].inv && !this.solidPath){
                this.solidPath = this.createLayerSolidPath();
            }
            // TODO move this to a factory or to a constructor
            this.viewData[i] = {
                elem: path,
                lastPath: '',
                op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),
                prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3),
                invRect: rect
            };
            if(!this.viewData[i].prop.k){
                this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);
            }
        }

        this.maskElement = createNS( maskType);

        len = currentMasks.length;
        for(i=0;i<len;i+=1){
            this.maskElement.appendChild(currentMasks[i]);
        }

        if(count > 0){
            this.maskElement.setAttribute('id', layerId);
            this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
            defs.appendChild(this.maskElement);
        }
        if (this.viewData.length) {
            this.element.addRenderableComponent(this);
        }

    }

    MaskElement.prototype.getMaskProperty = function(pos){
        return this.viewData[pos].prop;
    };

    MaskElement.prototype.renderFrame = function (isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i, len = this.masksProperties.length;
        for (i = 0; i < len; i++) {
            if(this.viewData[i].prop._mdf || isFirstFrame){
                this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);
            }
            if(this.viewData[i].op._mdf || isFirstFrame){
                this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);
            }
            if(this.masksProperties[i].mode !== 'n'){
                if(this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)){
                    this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
                }
                if(this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)){
                    var feMorph = this.storedData[i].expan;
                    if(this.storedData[i].x.v < 0){
                        if(this.storedData[i].lastOperator !== 'erode'){
                            this.storedData[i].lastOperator = 'erode';
                            this.storedData[i].elem.setAttribute('filter','url(' + locationHref + '#'+this.storedData[i].filterId+')');
                        }
                        feMorph.setAttribute('radius',-this.storedData[i].x.v);
                    }else {
                        if(this.storedData[i].lastOperator !== 'dilate'){
                            this.storedData[i].lastOperator = 'dilate';
                            this.storedData[i].elem.setAttribute('filter',null);
                        }
                        this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v*2);

                    }
                }
            }
        }
    };

    MaskElement.prototype.getMaskelement = function () {
        return this.maskElement;
    };

    MaskElement.prototype.createLayerSolidPath = function(){
        var path = 'M0,0 ';
        path += ' h' + this.globalData.compSize.w ;
        path += ' v' + this.globalData.compSize.h ;
        path += ' h-' + this.globalData.compSize.w ;
        path += ' v-' + this.globalData.compSize.h + ' ';
        return path;
    };

    MaskElement.prototype.drawPath = function(pathData,pathNodes,viewData){
        var pathString = " M"+pathNodes.v[0][0]+','+pathNodes.v[0][1];
        var i, len;
        len = pathNodes._length;
        for(i=1;i<len;i+=1){
            //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
            pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
        }
            //pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
        if(pathNodes.c && len > 1){
            pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
        }
        //pathNodes.__renderedString = pathString;

        if(viewData.lastPath !== pathString){
            var pathShapeValue = '';
            if(viewData.elem){
                if(pathNodes.c){
                    pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
                }
                viewData.elem.setAttribute('d',pathShapeValue);
            }
            viewData.lastPath = pathString;
        }
    };

    MaskElement.prototype.destroy = function(){
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
    };

    /**
     * @file 
     * Handles AE's layer parenting property.
     *
     */

    function HierarchyElement(){}

    HierarchyElement.prototype = {
    	/**
         * @function 
         * Initializes hierarchy properties
         *
         */
    	initHierarchy: function() {
    		//element's parent list
    	    this.hierarchy = [];
    	    //if element is parent of another layer _isParent will be true
    	    this._isParent = false;
    	    this.checkParenting();
    	},
    	/**
         * @function 
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */ 
    	setHierarchy: function(hierarchy){
    	    this.hierarchy = hierarchy;
    	},
    	/**
         * @function 
         * Sets layer as parent.
         *
         */ 
    	setAsParent: function() {
    	    this._isParent = true;
    	},
    	/**
         * @function 
         * Searches layer's parenting chain
         *
         */ 
    	checkParenting: function(){
    	    if (this.data.parent !== undefined){
    	        this.comp.buildElementParenting(this, this.data.parent, []);
    	    }
    	}
    };
    /**
     * @file 
     * Handles element's layer frame update.
     * Checks layer in point and out point
     *
     */

    function FrameElement(){}

    FrameElement.prototype = {
        /**
         * @function 
         * Initializes frame related properties.
         *
         */
        initFrame: function(){
            //set to true when inpoint is rendered
            this._isFirstFrame = false;
            //list of animated properties
            this.dynamicProperties = [];
            // If layer has been modified in current tick this will be true
            this._mdf = false;
        },
        /**
         * @function 
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         * 
         */
        prepareProperties: function(num, isVisible) {
            var i, len = this.dynamicProperties.length;
            for (i = 0;i < len; i += 1) {
                if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
                    this.dynamicProperties[i].getValue();
                    if (this.dynamicProperties[i]._mdf) {
                        this.globalData._mdf = true;
                        this._mdf = true;
                    }
                }
            }
        },
        addDynamicProperty: function(prop) {
            if(this.dynamicProperties.indexOf(prop) === -1) {
                this.dynamicProperties.push(prop);
            }
        }
    };
    function TransformElement(){}

    TransformElement.prototype = {
        initTransform: function() {
            this.finalTransform = {
                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {o:0},
                _matMdf: false,
                _opMdf: false,
                mat: new Matrix()
            };
            if (this.data.ao) {
                this.finalTransform.mProp.autoOriented = true;
            }

            //TODO: check TYPE 11: Guided elements
            if (this.data.ty !== 11) ;
        },
        renderTransform: function() {

            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

            if (this.hierarchy) {
                var mat;
                var finalMat = this.finalTransform.mat;
                var i = 0, len = this.hierarchy.length;
                //Checking if any of the transformation matrices in the hierarchy chain has changed.
                if (!this.finalTransform._matMdf) {
                    while (i < len) {
                        if (this.hierarchy[i].finalTransform.mProp._mdf) {
                            this.finalTransform._matMdf = true;
                            break;
                        }
                        i += 1;
                    }
                }
                
                if (this.finalTransform._matMdf) {
                    mat = this.finalTransform.mProp.v.props;
                    finalMat.cloneFromProps(mat);
                    for (i = 0; i < len; i += 1) {
                        mat = this.hierarchy[i].finalTransform.mProp.v.props;
                        finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
                    }
                }
            }
        },
        globalToLocal: function(pt) {
            var transforms = [];
            transforms.push(this.finalTransform);
            var flag = true;
            var comp = this.comp;
            while (flag) {
                if (comp.finalTransform) {
                    if (comp.data.hasMask) {
                        transforms.splice(0, 0, comp.finalTransform);
                    }
                    comp = comp.comp;
                } else {
                    flag = false;
                }
            }
            var i, len = transforms.length,ptNew;
            for (i = 0; i < len; i += 1) {
                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
                //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
                pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
            }
            return pt;
        },
        mHelper: new Matrix()
    };
    function RenderableElement(){

    }

    RenderableElement.prototype = {
        initRenderable: function() {
            //layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
            this.isInRange = false;
            //layer's display state
            this.hidden = false;
            // If layer's transparency equals 0, it can be hidden
            this.isTransparent = false;
            //list of animated components
            this.renderableComponents = [];
        },
        addRenderableComponent: function(component) {
            if(this.renderableComponents.indexOf(component) === -1) {
                this.renderableComponents.push(component);
            }
        },
        removeRenderableComponent: function(component) {
            if(this.renderableComponents.indexOf(component) !== -1) {
                this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
            }
        },
        prepareRenderableFrame: function(num) {
            this.checkLayerLimits(num);
        },
        checkTransparency: function(){
            if(this.finalTransform.mProp.o.v <= 0) {
                if(!this.isTransparent && this.globalData.renderConfig.hideOnTransparent){
                    this.isTransparent = true;
                    this.hide();
                }
            } else if(this.isTransparent) {
                this.isTransparent = false;
                this.show();
            }
        },
        /**
         * @function 
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         * 
         */
        checkLayerLimits: function(num) {
            if(this.data.ip - this.data.st <= num && this.data.op - this.data.st > num)
            {
                if(this.isInRange !== true){
                    this.globalData._mdf = true;
                    this._mdf = true;
                    this.isInRange = true;
                    this.show();
                }
            } else {
                if(this.isInRange !== false){
                    this.globalData._mdf = true;
                    this.isInRange = false;
                    this.hide();
                }
            }
        },
        renderRenderable: function() {
            var i, len = this.renderableComponents.length;
            for(i = 0; i < len; i += 1) {
                this.renderableComponents[i].renderFrame(this._isFirstFrame);
            }
            /*this.maskManager.renderFrame(this.finalTransform.mat);
            this.renderableEffectsManager.renderFrame(this._isFirstFrame);*/
        },
        sourceRectAtTime: function(){
            return {
                top:0,
                left:0,
                width:100,
                height:100
            };
        },
        getLayerSize: function(){
            if(this.data.ty === 5){
                return {w:this.data.textData.width,h:this.data.textData.height};
            }else {
                return {w:this.data.width,h:this.data.height};
            }
        }
    };
    function RenderableDOMElement() {}

    (function(){
        var _prototype = {
            initElement: function(data,globalData,comp) {
                this.initFrame();
                this.initBaseData(data, globalData, comp);
                this.initTransform(data, globalData, comp);
                this.initHierarchy();
                this.initRenderable();
                this.initRendererElement();
                this.createContainerElements();
                this.createRenderableComponents();
                this.createContent();
                this.hide();
            },
            hide: function(){
                if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                    var elem = this.baseElement || this.layerElement;
                    elem.style.display = 'none';
                    this.hidden = true;
                }
            },
            show: function(){
                if (this.isInRange && !this.isTransparent){
                    if (!this.data.hd) {
                        var elem = this.baseElement || this.layerElement;
                        elem.style.display = 'block';
                    }
                    this.hidden = false;
                    this._isFirstFrame = true;
                }
            },
            renderFrame: function() {
                //If it is exported as hidden (data.hd === true) no need to render
                //If it is not visible no need to render
                if (this.data.hd || this.hidden) {
                    return;
                }
                this.renderTransform();
                this.renderRenderable();
                this.renderElement();
                this.renderInnerContent();
                if (this._isFirstFrame) {
                    this._isFirstFrame = false;
                }
            },
            renderInnerContent: function() {},
            prepareFrame: function(num) {
                this._mdf = false;
                this.prepareRenderableFrame(num);
                this.prepareProperties(num, this.isInRange);
                this.checkTransparency();
            },
            destroy: function(){
                this.innerElem =  null;
                this.destroyBaseElement();
            }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
    }());
    function ProcessedElement(element, position) {
    	this.elem = element;
    	this.pos = position;
    }
    function SVGStyleData(data, level) {
    	this.data = data;
    	this.type = data.ty;
    	this.d = '';
    	this.lvl = level;
    	this._mdf = false;
    	this.closed = data.hd === true;
    	this.pElem = createNS('path');
    	this.msElem = null;
    }

    SVGStyleData.prototype.reset = function() {
    	this.d = '';
    	this._mdf = false;
    };
    function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = '';
        this.sh = shape;
        this.lvl = level;
        //TODO find if there are some cases where _isAnimated can be false. 
        // For now, since shapes add up with other shapes. They have to be calculated every time.
        // One way of finding out is checking if all styles associated to this shape depend only of this shape
        this._isAnimated = !!shape.k;
        // TODO: commenting this for now since all shapes are animated
        var i = 0, len = transformers.length;
        while(i < len) {
        	if(transformers[i].mProps.dynamicProperties.length) {
        		this._isAnimated = true;
        		break;
        	}
        	i += 1;
        }
    }

    SVGShapeData.prototype.setAsAnimated = function() {
        this._isAnimated = true;
    };
    function SVGTransformData(mProps, op, container) {
    	this.transform = {
    		mProps: mProps,
    		op: op,
    		container: container
    	};
    	this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    function SVGStrokeStyleData(elem, data, styleOb){
    	this.initDynamicPropertyContainer(elem);
    	this.getValue = this.iterateDynamicProperties;
    	this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
    	this.w = PropertyFactory.getProp(elem,data.w,0,null,this);
    	this.d = new DashProperty(elem,data.d||{},'svg',this);
    	this.c = PropertyFactory.getProp(elem,data.c,1,255,this);
    	this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
    }

    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(elem, data, styleOb){
    	this.initDynamicPropertyContainer(elem);
    	this.getValue = this.iterateDynamicProperties;
    	this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
    	this.c = PropertyFactory.getProp(elem,data.c,1,255,this);
    	this.style = styleOb;
    }

    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGGradientFillStyleData(elem, data, styleOb){
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem, data, styleOb);
    }

    SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb){
        this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);
        this.s = PropertyFactory.getProp(elem,data.s,1,null,this);
        this.e = PropertyFactory.getProp(elem,data.e,1,null,this);
        this.h = PropertyFactory.getProp(elem,data.h||{k:0},0,0.01,this);
        this.a = PropertyFactory.getProp(elem,data.a||{k:0},0,degToRads,this);
        this.g = new GradientProperty(elem,data.g,this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data);
        this.setGradientOpacity(data, styleOb);
        this._isAnimated = !!this._isAnimated;

    };

    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement,data){

        var gradientId = createElementID();
        var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
        gfill.setAttribute('id',gradientId);
        gfill.setAttribute('spreadMethod','pad');
        gfill.setAttribute('gradientUnits','userSpaceOnUse');
        var stops = [];
        var stop, j, jLen;
        jLen = data.g.p*4;
        for(j=0;j<jLen;j+=4){
            stop = createNS('stop');
            gfill.appendChild(stop);
            stops.push(stop);
        }
        pathElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(' + locationHref + '#'+gradientId+')');
        
        this.gf = gfill;
        this.cst = stops;
    };

    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb){
        if(this.g._hasOpacity && !this.g._collapsable){
            var stop, j, jLen;
            var mask = createNS("mask");
            var maskElement = createNS( 'path');
            mask.appendChild(maskElement);
            var opacityId = createElementID();
            var maskId = createElementID();
            mask.setAttribute('id',maskId);
            var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
            opFill.setAttribute('id',opacityId);
            opFill.setAttribute('spreadMethod','pad');
            opFill.setAttribute('gradientUnits','userSpaceOnUse');
            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
            var stops = this.stops;
            for(j=data.g.p*4;j<jLen;j+=2){
                stop = createNS('stop');
                stop.setAttribute('stop-color','rgb(255,255,255)');
                opFill.appendChild(stop);
                stops.push(stop);
            }
            maskElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(' + locationHref + '#'+opacityId+')');
            this.of = opFill;
            this.ms = mask;
            this.ost = stops;
            this.maskId = maskId;
            styleOb.msElem = maskElement;
        }
    };

    extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(elem, data, styleOb){
    	this.initDynamicPropertyContainer(elem);
    	this.getValue = this.iterateDynamicProperties;
    	this.w = PropertyFactory.getProp(elem,data.w,0,null,this);
    	this.d = new DashProperty(elem,data.d||{},'svg',this);
        this.initGradientData(elem, data, styleOb);
        this._isAnimated = !!this._isAnimated;
    }

    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
    	this.it = [];
        this.prevViewData = [];
        this.gr = createNS('g');
    }
    var SVGElementsRenderer = (function() {
    	var _identityMatrix = new Matrix();
    	var _matrixHelper = new Matrix();

    	var ob = {
    		createRenderFunction: createRenderFunction
    	};

    	function createRenderFunction(data) {
    	    var ty = data.ty;
    	    switch(data.ty) {
    	        case 'fl':
    	        return renderFill;
    	        case 'gf':
    	        return renderGradient;
    	        case 'gs':
    	        return renderGradientStroke;
    	        case 'st':
    	        return renderStroke;
    	        case 'sh':
    	        case 'el':
    	        case 'rc':
    	        case 'sr':
    	        return renderPath;
    	        case 'tr':
    	        return renderContentTransform;
    	    }
    	}

    	function renderContentTransform(styleData, itemData, isFirstFrame) {
    	    if(isFirstFrame || itemData.transform.op._mdf){
    	        itemData.transform.container.setAttribute('opacity',itemData.transform.op.v);
    	    }
    	    if(isFirstFrame || itemData.transform.mProps._mdf){
    	        itemData.transform.container.setAttribute('transform',itemData.transform.mProps.v.to2dCSS());
    	    }
    	}

    	function renderPath(styleData, itemData, isFirstFrame) {
    	    var j, jLen,pathStringTransformed,redraw,pathNodes,l, lLen = itemData.styles.length;
    	    var lvl = itemData.lvl;
    	    var paths, mat, props, iterations, k;
    	    for(l=0;l<lLen;l+=1){
    	        redraw = itemData.sh._mdf || isFirstFrame;
    	        if(itemData.styles[l].lvl < lvl){
    	            mat = _matrixHelper.reset();
    	            iterations = lvl - itemData.styles[l].lvl;
    	            k = itemData.transformers.length-1;
    	            while(!redraw && iterations > 0) {
    	                redraw = itemData.transformers[k].mProps._mdf || redraw;
    	                iterations --;
    	                k --;
    	            }
    	            if(redraw) {
    	                iterations = lvl - itemData.styles[l].lvl;
    	                k = itemData.transformers.length-1;
    	                while(iterations > 0) {
    	                    props = itemData.transformers[k].mProps.v.props;
    	                    mat.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
    	                    iterations --;
    	                    k --;
    	                }
    	            }
    	        } else {
    	            mat = _identityMatrix;
    	        }
    	        paths = itemData.sh.paths;
    	        jLen = paths._length;
    	        if(redraw){
    	            pathStringTransformed = '';
    	            for(j=0;j<jLen;j+=1){
    	                pathNodes = paths.shapes[j];
    	                if(pathNodes && pathNodes._length){
    	                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
    	                }
    	            }
    	            itemData.caches[l] = pathStringTransformed;
    	        } else {
    	            pathStringTransformed = itemData.caches[l];
    	        }
    	        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
    	        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
    	    }
    	}

    	function renderFill (styleData,itemData, isFirstFrame){
    	    var styleElem = itemData.style;

    	    if(itemData.c._mdf || isFirstFrame){
    	        styleElem.pElem.setAttribute('fill','rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')');
    	    }
    	    if(itemData.o._mdf || isFirstFrame){
    	        styleElem.pElem.setAttribute('fill-opacity',itemData.o.v);
    	    }
    	}
    	function renderGradientStroke (styleData, itemData, isFirstFrame) {
    	    renderGradient(styleData, itemData, isFirstFrame);
    	    renderStroke(styleData, itemData, isFirstFrame);
    	}

    	function renderGradient(styleData, itemData, isFirstFrame) {
    	    var gfill = itemData.gf;
    	    var hasOpacity = itemData.g._hasOpacity;
    	    var pt1 = itemData.s.v, pt2 = itemData.e.v;

    	    if (itemData.o._mdf || isFirstFrame) {
    	        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
    	        itemData.style.pElem.setAttribute(attr, itemData.o.v);
    	    }
    	    if (itemData.s._mdf || isFirstFrame) {
    	        var attr1 = styleData.t === 1 ? 'x1' : 'cx';
    	        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
    	        gfill.setAttribute(attr1, pt1[0]);
    	        gfill.setAttribute(attr2, pt1[1]);
    	        if (hasOpacity && !itemData.g._collapsable) {
    	            itemData.of.setAttribute(attr1, pt1[0]);
    	            itemData.of.setAttribute(attr2, pt1[1]);
    	        }
    	    }
    	    var stops, i, len, stop;
    	    if (itemData.g._cmdf || isFirstFrame) {
    	        stops = itemData.cst;
    	        var cValues = itemData.g.c;
    	        len = stops.length;
    	        for (i = 0; i < len; i += 1){
    	            stop = stops[i];
    	            stop.setAttribute('offset', cValues[i * 4] + '%');
    	            stop.setAttribute('stop-color','rgb('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ')');
    	        }
    	    }
    	    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
    	        var oValues = itemData.g.o;
    	        if(itemData.g._collapsable) {
    	            stops = itemData.cst;
    	        } else {
    	            stops = itemData.ost;
    	        }
    	        len = stops.length;
    	        for (i = 0; i < len; i += 1) {
    	            stop = stops[i];
    	            if(!itemData.g._collapsable) {
    	                stop.setAttribute('offset', oValues[i * 2] + '%');
    	            }
    	            stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
    	        }
    	    }
    	    if (styleData.t === 1) {
    	        if (itemData.e._mdf  || isFirstFrame) {
    	            gfill.setAttribute('x2', pt2[0]);
    	            gfill.setAttribute('y2', pt2[1]);
    	            if (hasOpacity && !itemData.g._collapsable) {
    	                itemData.of.setAttribute('x2', pt2[0]);
    	                itemData.of.setAttribute('y2', pt2[1]);
    	            }
    	        }
    	    } else {
    	        var rad;
    	        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
    	            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
    	            gfill.setAttribute('r', rad);
    	            if(hasOpacity && !itemData.g._collapsable){
    	                itemData.of.setAttribute('r', rad);
    	            }
    	        }
    	        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
    	            if (!rad) {
    	                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
    	            }
    	            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

    	            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;
    	            var dist = rad * percent;
    	            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
    	            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
    	            gfill.setAttribute('fx', x);
    	            gfill.setAttribute('fy', y);
    	            if (hasOpacity && !itemData.g._collapsable) {
    	                itemData.of.setAttribute('fx', x);
    	                itemData.of.setAttribute('fy', y);
    	            }
    	        }
    	        //gfill.setAttribute('fy','200');
    	    }
    	}
    	function renderStroke(styleData, itemData, isFirstFrame) {
    	    var styleElem = itemData.style;
    	    var d = itemData.d;
    	    if (d && (d._mdf || isFirstFrame) && d.dashStr) {
    	        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
    	        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
    	    }
    	    if(itemData.c && (itemData.c._mdf || isFirstFrame)){
    	        styleElem.pElem.setAttribute('stroke','rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')');
    	    }
    	    if(itemData.o._mdf || isFirstFrame){
    	        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
    	    }
    	    if(itemData.w._mdf || isFirstFrame){
    	        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
    	        if(styleElem.msElem){
    	            styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
    	        }
    	    }
    	}
    	return ob;
    }());
    function ShapeTransformManager() {
    	this.sequences = {};
    	this.sequenceList = [];
        this.transform_key_count = 0;
    }

    ShapeTransformManager.prototype = {
    	addTransformSequence: function(transforms) {
    		var i, len = transforms.length;
    		var key = '_';
    		for(i = 0; i < len; i += 1) {
    			key += transforms[i].transform.key + '_';
    		}
    		var sequence = this.sequences[key];
    		if(!sequence) {
    			sequence = {
    				transforms: [].concat(transforms),
    				finalTransform: new Matrix(),
    				_mdf: false
    			};
    			this.sequences[key] = sequence;
    			this.sequenceList.push(sequence);
    		}
    		return sequence;
    	},
    	processSequence: function(sequence, isFirstFrame) {
    		var i = 0, len = sequence.transforms.length, _mdf = isFirstFrame;
    		while (i < len && !isFirstFrame) {
    			if (sequence.transforms[i].transform.mProps._mdf) {
    				_mdf = true;
    				break;
    			}
    			i += 1;
    		}
    		if (_mdf) {
    			var props;
    			sequence.finalTransform.reset();
    			for (i = len - 1; i >= 0; i -= 1) {
    		        props = sequence.transforms[i].transform.mProps.v.props;
    		        sequence.finalTransform.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
    			}
    		}
    		sequence._mdf = _mdf;
    		
    	},
    	processSequences: function(isFirstFrame) {
    		var i, len = this.sequenceList.length;
    		for (i = 0; i < len; i += 1) {
    			this.processSequence(this.sequenceList[i], isFirstFrame);
    		}

    	},
    	getNewKey: function() {
    		return '_' + this.transform_key_count++;
    	}
    };
    function CVShapeData(element, data, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0,0,0,0,0,0];
        var ty = 4;
        if(data.ty == 'rc'){
            ty = 5;
        }else if(data.ty == 'el'){
            ty = 6;
        }else if(data.ty == 'sr'){
            ty = 7;
        }
        this.sh = ShapePropertyFactory.getShapeProp(element,data,ty,element);
        var i , len = styles.length,styledShape;
        for (i = 0; i < len; i += 1) {
            if (!styles[i].closed) {
                styledShape = {
                    transforms: transformsManager.addTransformSequence(styles[i].transforms),
                    trNodes: []
                };
                this.styledShapes.push(styledShape);
                styles[i].elements.push(styledShape);
            }
        }
    }

    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function BaseElement(){
    }

    BaseElement.prototype = {
        checkMasks: function(){
            if(!this.data.hasMask){
                return false;
            }
            var i = 0, len = this.data.masksProperties.length;
            while(i<len) {
                if((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
                    return true;
                }
                i += 1;
            }
            return false;
        },
        initExpressions: function(){
            this.layerInterface = LayerExpressionInterface(this);
            if(this.data.hasMask && this.maskManager) {
                this.layerInterface.registerMaskInterface(this.maskManager);
            }
            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);
            this.layerInterface.registerEffectsInterface(effectsInterface);

            if(this.data.ty === 0 || this.data.xt){
                this.compInterface = CompExpressionInterface(this);
            } else if(this.data.ty === 4){
                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData,this.itemsData,this.layerInterface);
                this.layerInterface.content = this.layerInterface.shapeInterface;
            } else if(this.data.ty === 5){
                this.layerInterface.textInterface = TextExpressionInterface(this);
                this.layerInterface.text = this.layerInterface.textInterface;
            }
        },
        setBlendMode: function(){
            var blendModeValue = getBlendMode(this.data.bm);
            var elem = this.baseElement || this.layerElement;

            elem.style['mix-blend-mode'] = blendModeValue;
        },
        initBaseData: function(data, globalData, comp){
            this.globalData = globalData;
            this.comp = comp;
            this.data = data;
            this.layerId = createElementID();
            
            //Stretch factor for old animations missing this property.
            if(!this.data.sr){
                this.data.sr = 1;
            }
            // effects manager
            this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties);
            
        },
        getType: function(){
            return this.type;
        }
        ,sourceRectAtTime: function(){}
    };
    function NullElement(data,globalData,comp){
        this.initFrame();
    	this.initBaseData(data, globalData, comp);
        this.initFrame();
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
    }

    NullElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
    };

    NullElement.prototype.renderFrame = function() {
    };

    NullElement.prototype.getBaseElement = function() {
    	return null;
    };

    NullElement.prototype.destroy = function() {
    };

    NullElement.prototype.sourceRectAtTime = function() {
    };

    NullElement.prototype.hide = function() {
    };

    extendPrototype([BaseElement,TransformElement,HierarchyElement,FrameElement], NullElement);

    function SVGBaseElement(){
    }

    SVGBaseElement.prototype = {
        initRendererElement: function() {
            this.layerElement = createNS('g');
        },
        createContainerElements: function(){
            this.matteElement = createNS('g');
            this.transformedElement = this.layerElement;
            this.maskedElement = this.layerElement;
            this._sizeChanged = false;
            var layerElementParent = null;
            //If this layer acts as a mask for the following layer
            var filId, fil, gg;
            if (this.data.td) {
                if (this.data.td == 3 || this.data.td == 1) {
                    var masker = createNS('mask');
                    masker.setAttribute('id', this.layerId);
                    masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha');
                    masker.appendChild(this.layerElement);
                    layerElementParent = masker;
                    this.globalData.defs.appendChild(masker);
                    // This is only for IE and Edge when mask if of type alpha
                    if (!featureSupport.maskType && this.data.td == 1) {
                        masker.setAttribute('mask-type', 'luminance');
                        filId = createElementID();
                        fil = filtersFactory.createFilter(filId);
                        this.globalData.defs.appendChild(fil);
                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                        gg = createNS('g');
                        gg.appendChild(this.layerElement);
                        layerElementParent = gg;
                        masker.appendChild(gg);
                        gg.setAttribute('filter','url(' + locationHref + '#' + filId + ')');
                    }
                } else if(this.data.td == 2) {
                    var maskGroup = createNS('mask');
                    maskGroup.setAttribute('id', this.layerId);
                    maskGroup.setAttribute('mask-type','alpha');
                    var maskGrouper = createNS('g');
                    maskGroup.appendChild(maskGrouper);
                    filId = createElementID();
                    fil = filtersFactory.createFilter(filId);
                    ////

                    // This solution doesn't work on Android when meta tag with viewport attribute is set
                    /*var feColorMatrix = createNS('feColorMatrix');
                    feColorMatrix.setAttribute('type', 'matrix');
                    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                    fil.appendChild(feColorMatrix);*/
                    ////
                    var feCTr = createNS('feComponentTransfer');
                    feCTr.setAttribute('in','SourceGraphic');
                    fil.appendChild(feCTr);
                    var feFunc = createNS('feFuncA');
                    feFunc.setAttribute('type','table');
                    feFunc.setAttribute('tableValues','1.0 0.0');
                    feCTr.appendChild(feFunc);
                    ////
                    this.globalData.defs.appendChild(fil);
                    var alphaRect = createNS('rect');
                    alphaRect.setAttribute('width',  this.comp.data.w);
                    alphaRect.setAttribute('height', this.comp.data.h);
                    alphaRect.setAttribute('x','0');
                    alphaRect.setAttribute('y','0');
                    alphaRect.setAttribute('fill','#ffffff');
                    alphaRect.setAttribute('opacity','0');
                    maskGrouper.setAttribute('filter', 'url(' + locationHref + '#'+filId+')');
                    maskGrouper.appendChild(alphaRect);
                    maskGrouper.appendChild(this.layerElement);
                    layerElementParent = maskGrouper;
                    if (!featureSupport.maskType) {
                        maskGroup.setAttribute('mask-type', 'luminance');
                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                        gg = createNS('g');
                        maskGrouper.appendChild(alphaRect);
                        gg.appendChild(this.layerElement);
                        layerElementParent = gg;
                        maskGrouper.appendChild(gg);
                    }
                    this.globalData.defs.appendChild(maskGroup);
                }
            } else if (this.data.tt) {
                this.matteElement.appendChild(this.layerElement);
                layerElementParent = this.matteElement;
                this.baseElement = this.matteElement;
            } else {
                this.baseElement = this.layerElement;
            }
            if (this.data.ln) {
                this.layerElement.setAttribute('id', this.data.ln);
            }
            if (this.data.cl) {
                this.layerElement.setAttribute('class', this.data.cl);
            }
            //Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
            if (this.data.ty === 0 && !this.data.hd) {
                var cp = createNS( 'clipPath');
                var pt = createNS('path');
                pt.setAttribute('d','M0,0 L' + this.data.w + ',0' + ' L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
                var clipId = createElementID();
                cp.setAttribute('id',clipId);
                cp.appendChild(pt);
                this.globalData.defs.appendChild(cp);

                if (this.checkMasks()) {
                    var cpGroup = createNS('g');
                    cpGroup.setAttribute('clip-path','url(' + locationHref + '#'+clipId + ')');
                    cpGroup.appendChild(this.layerElement);
                    this.transformedElement = cpGroup;
                    if (layerElementParent) {
                        layerElementParent.appendChild(this.transformedElement);
                    } else {
                        this.baseElement = this.transformedElement;
                    }
                } else {
                    this.layerElement.setAttribute('clip-path','url(' + locationHref + '#'+clipId+')');
                }
                
            }
            if (this.data.bm !== 0) {
                this.setBlendMode();
            }

        },
        renderElement: function() {
            if (this.finalTransform._matMdf) {
                this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
            }
            if (this.finalTransform._opMdf) {
                this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
            }
        },
        destroyBaseElement: function() {
            this.layerElement = null;
            this.matteElement = null;
            this.maskManager.destroy();
        },
        getBaseElement: function() {
            if (this.data.hd) {
                return null;
            }
            return this.baseElement;
        },
        createRenderableComponents: function() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
            this.renderableEffectsManager = new SVGEffects(this);
        },
        setMatte: function(id) {
            if (!this.matteElement) {
                return;
            }
            this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
        }
    };
    function IShapeElement(){
    }

    IShapeElement.prototype = {
        addShapeToModifiers: function(data) {
            var i, len = this.shapeModifiers.length;
            for(i=0;i<len;i+=1){
                this.shapeModifiers[i].addShape(data);
            }
        },
        isShapeInAnimatedModifiers: function(data) {
            var i = 0, len = this.shapeModifiers.length;
            while(i < len) {
                if(this.shapeModifiers[i].isAnimatedWithShape(data)) {
                    return true;
                }
            }
            return false;
        },
        renderModifiers: function() {
            if(!this.shapeModifiers.length){
                return;
            }
            var i, len = this.shapes.length;
            for(i=0;i<len;i+=1){
                this.shapes[i].sh.reset();
            }

            len = this.shapeModifiers.length;
            for(i=len-1;i>=0;i-=1){
                this.shapeModifiers[i].processShapes(this._isFirstFrame);
            }
        },
        lcEnum: {
            '1': 'butt',
            '2': 'round',
            '3': 'square'
        },
        ljEnum: {
            '1': 'miter',
            '2': 'round',
            '3': 'bevel'
        },
        searchProcessedElement: function(elem){
            var elements = this.processedElements;
            var i = 0, len = elements.length;
            while (i < len) {
                if (elements[i].elem === elem) {
                    return elements[i].pos;
                }
                i += 1;
            }
            return 0;
        },
        addProcessedElement: function(elem, pos){
            var elements = this.processedElements;
            var i = elements.length;
            while(i) {
                i -= 1;
                if (elements[i].elem === elem) {
                    elements[i].pos = pos;
                    return;
                }
            }
            elements.push(new ProcessedElement(elem, pos));
        },
        prepareFrame: function(num) {
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
        }
    };
    function ITextElement(){
    }

    ITextElement.prototype.initElement = function(data,globalData,comp){
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
    };

    ITextElement.prototype.prepareFrame = function(num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if(this.textProperty._mdf || this.textProperty._isFirstFrame) {
            this.buildNewText();
            this.textProperty._isFirstFrame = false;
            this.textProperty._mdf = false;
        }
    };

    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
        var j,jLen = shapes.length;
        var pathNodes;
        var shapeStr = '';
        for(j=0;j<jLen;j+=1){
            pathNodes = shapes[j].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
        }
        return shapeStr;
    };

    ITextElement.prototype.updateDocumentData = function(newData, index) {
        this.textProperty.updateDocumentData(newData, index);
    };

    ITextElement.prototype.canResizeFont = function(_canResize) {
        this.textProperty.canResizeFont(_canResize);
    };

    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
    };

    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
        if(documentData.ps){
            matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);
        }
        matrixHelper.translate(0,-documentData.ls,0);
        switch(documentData.j){
            case 1:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]),0,0);
                break;
            case 2:
                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber] )/2,0,0);
                break;
        }
        matrixHelper.translate(xPos, yPos, 0);
    };


    ITextElement.prototype.buildColor = function(colorData) {
        return 'rgb(' + Math.round(colorData[0]*255) + ',' + Math.round(colorData[1]*255) + ',' + Math.round(colorData[2]*255) + ')';
    };

    ITextElement.prototype.emptyProp = new LetterProps();

    ITextElement.prototype.destroy = function(){
        
    };
    function ICompElement(){}

    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

    ICompElement.prototype.initElement = function(data,globalData,comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initTransform(data, globalData, comp);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        if(this.data.xt || !globalData.progressiveLoad){
            this.buildAllItems();
        }
        this.hide();
    };

    /*ICompElement.prototype.hide = function(){
        if(!this.hidden){
            this.hideElement();
            var i,len = this.elements.length;
            for( i = 0; i < len; i+=1 ){
                if(this.elements[i]){
                    this.elements[i].hide();
                }
            }
        }
    };*/

    ICompElement.prototype.prepareFrame = function(num){
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
        if(!this.isInRange && !this.data.xt){
            return;
        }

        if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            if(timeRemapped === this.data.op){
                timeRemapped = this.data.op - 1;
            }
            this.renderedFrame = timeRemapped;
        } else {
            this.renderedFrame = num/this.data.sr;
        }
        var i,len = this.elements.length;
        if(!this.completeLayers){
            this.checkLayers(this.renderedFrame);
        }
        //This iteration needs to be backwards because of how expressions connect between each other
        for( i = len - 1; i >= 0; i -= 1 ){
            if(this.completeLayers || this.elements[i]){
                this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
                if(this.elements[i]._mdf) {
                    this._mdf = true;
                }
            }
        }
    };

    ICompElement.prototype.renderInnerContent = function() {
        var i,len = this.layers.length;
        for( i = 0; i < len; i += 1 ){
            if(this.completeLayers || this.elements[i]){
                this.elements[i].renderFrame();
            }
        }
    };

    ICompElement.prototype.setElements = function(elems){
        this.elements = elems;
    };

    ICompElement.prototype.getElements = function(){
        return this.elements;
    };

    ICompElement.prototype.destroyElements = function(){
        var i,len = this.layers.length;
        for( i = 0; i < len; i+=1 ){
            if(this.elements[i]){
                this.elements[i].destroy();
            }
        }
    };

    ICompElement.prototype.destroy = function(){
        this.destroyElements();
        this.destroyBaseElement();
    };

    function IImageElement(data,globalData,comp){
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data,globalData,comp);
        this.sourceRect = {top:0,left:0,width:this.assetData.w,height:this.assetData.h};
    }

    extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], IImageElement);

    IImageElement.prototype.createContent = function(){

        var assetPath = this.globalData.getAssetsPath(this.assetData);

        this.innerElem = createNS('image');
        this.innerElem.setAttribute('width',this.assetData.w+"px");
        this.innerElem.setAttribute('height',this.assetData.h+"px");
        this.innerElem.setAttribute('preserveAspectRatio',this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
        
        this.layerElement.appendChild(this.innerElem);
    };

    IImageElement.prototype.sourceRectAtTime = function() {
    	return this.sourceRect;
    };
    function ISolidElement(data,globalData,comp){
        this.initElement(data,globalData,comp);
    }
    extendPrototype([IImageElement], ISolidElement);

    ISolidElement.prototype.createContent = function(){

        var rect = createNS('rect');
        ////rect.style.width = this.data.sw;
        ////rect.style.height = this.data.sh;
        ////rect.style.fill = this.data.sc;
        rect.setAttribute('width',this.data.sw);
        rect.setAttribute('height',this.data.sh);
        rect.setAttribute('fill',this.data.sc);
        this.layerElement.appendChild(rect);
    };
    function SVGCompElement(data,globalData,comp){
        this.layers = data.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        //this.layerElement = createNS('g');
        this.initElement(data,globalData,comp);
        this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};
    }

    extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);
    function SVGTextElement(data,globalData,comp){
        this.textSpans = [];
        this.renderType = 'svg';
        this.initElement(data,globalData,comp);
    }

    extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], SVGTextElement);

    SVGTextElement.prototype.createContent = function(){

        if (this.data.singleShape && !this.globalData.fontManager.chars) {
            this.textContainer = createNS('text');
        }
    };

    SVGTextElement.prototype.buildTextContents = function(textArray) {
        var i = 0, len = textArray.length;
        var textContents = [], currentTextContent = '';
        while (i < len) {
            if(textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
                textContents.push(currentTextContent);
                currentTextContent = '';
            } else {
                currentTextContent += textArray[i];
            }
            i += 1;
        }
        textContents.push(currentTextContent);
        return textContents;
    };

    SVGTextElement.prototype.buildNewText = function(){
        var i, len;

        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
        if(documentData.fc) {
            this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
        }else {
            this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
        }
        if(documentData.sc){
            this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
            this.layerElement.setAttribute('stroke-width', documentData.sw);
        }
        this.layerElement.setAttribute('font-size', documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if(fontData.fClass){
            this.layerElement.setAttribute('class',fontData.fClass);
        } else {
            this.layerElement.setAttribute('font-family', fontData.fFamily);
            var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
            this.layerElement.setAttribute('font-style', fStyle);
            this.layerElement.setAttribute('font-weight', fWeight);
        }
        this.layerElement.setAttribute('aria-label', documentData.t);

        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;

        var tSpan;
        var matrixHelper = this.mHelper;
        var shapes, shapeStr = '', singleShape = this.data.singleShape;
        var xPos = 0, yPos = 0, firstLine = true;
        var trackingOffset = documentData.tr/1000*documentData.finalSize;
        if(singleShape && !usesGlyphs && !documentData.sz) {
            var tElement = this.textContainer;
            var justify = 'start';
            switch(documentData.j) {
                case 1:
                    justify = 'end';
                    break;
                case 2:
                    justify = 'middle';
                    break;
            }
            tElement.setAttribute('text-anchor',justify);
            tElement.setAttribute('letter-spacing',trackingOffset);
            var textContent = this.buildTextContents(documentData.finalText);
            len = textContent.length;
            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
            for ( i = 0; i < len; i += 1) {
                tSpan = this.textSpans[i] || createNS('tspan');
                tSpan.textContent = textContent[i];
                tSpan.setAttribute('x', 0);
                tSpan.setAttribute('y', yPos);
                tSpan.style.display = 'inherit';
                tElement.appendChild(tSpan);
                this.textSpans[i] = tSpan;
                yPos += documentData.finalLineHeight;
            }
            
            this.layerElement.appendChild(tElement);
        } else {
            var cachedSpansLength = this.textSpans.length;
            var shapeData, charData;
            for (i = 0; i < len; i += 1) {
                if(!usesGlyphs || !singleShape || i === 0){
                    tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs?'path':'text');
                    if (cachedSpansLength <= i) {
                        tSpan.setAttribute('stroke-linecap', 'butt');
                        tSpan.setAttribute('stroke-linejoin','round');
                        tSpan.setAttribute('stroke-miterlimit','4');
                        this.textSpans[i] = tSpan;
                        this.layerElement.appendChild(tSpan);
                    }
                    tSpan.style.display = 'inherit';
                }
                
                matrixHelper.reset();
                matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                if (singleShape) {
                    if(letters[i].n) {
                        xPos = -trackingOffset;
                        yPos += documentData.yOffset;
                        yPos += firstLine ? 1 : 0;
                        firstLine = false;
                    }
                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
                    xPos += letters[i].l || 0;
                    //xPos += letters[i].val === ' ' ? 0 : trackingOffset;
                    xPos += trackingOffset;
                }
                if(usesGlyphs) {
                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                    shapeData = charData && charData.data || {};
                    shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
                    if(!singleShape){
                        tSpan.setAttribute('d',this.createPathShape(matrixHelper,shapes));
                    } else {
                        shapeStr += this.createPathShape(matrixHelper,shapes);
                    }
                } else {
                    if(singleShape) {
                        tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                    }
                    tSpan.textContent = letters[i].val;
                    tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
                }
                //
            }
            if (singleShape && tSpan) {
                tSpan.setAttribute('d',shapeStr);
            }
        }
        while (i < this.textSpans.length){
            this.textSpans[i].style.display = 'none';
            i += 1;
        }
        
        this._sizeChanged = true;
    };

    SVGTextElement.prototype.sourceRectAtTime = function(time){
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();
        if(this._sizeChanged){
            this._sizeChanged = false;
            var textBox = this.layerElement.getBBox();
            this.bbox = {
                top: textBox.y,
                left: textBox.x,
                width: textBox.width,
                height: textBox.height
            };
        }
        return this.bbox;
    };

    SVGTextElement.prototype.renderInnerContent = function(){

        if(!this.data.singleShape){
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            if(this.lettersChangedFlag || this.textAnimator.lettersChangedFlag){
                this._sizeChanged = true;
                var  i,len;
                var renderedLetters = this.textAnimator.renderedLetters;

                var letters = this.textProperty.currentData.l;

                len = letters.length;
                var renderedLetter, textSpan;
                for(i=0;i<len;i+=1){
                    if(letters[i].n){
                        continue;
                    }
                    renderedLetter = renderedLetters[i];
                    textSpan = this.textSpans[i];
                    if(renderedLetter._mdf.m) {
                        textSpan.setAttribute('transform',renderedLetter.m);
                    }
                    if(renderedLetter._mdf.o) {
                        textSpan.setAttribute('opacity',renderedLetter.o);
                    }
                    if(renderedLetter._mdf.sw){
                        textSpan.setAttribute('stroke-width',renderedLetter.sw);
                    }
                    if(renderedLetter._mdf.sc){
                        textSpan.setAttribute('stroke',renderedLetter.sc);
                    }
                    if(renderedLetter._mdf.fc){
                        textSpan.setAttribute('fill',renderedLetter.fc);
                    }
                }
            }
        }
    };

    function SVGShapeElement(data,globalData,comp){
        //List of drawable elements
        this.shapes = [];
        // Full shape data
        this.shapesData = data.shapes;
        //List of styles that will be applied to shapes
        this.stylesList = [];
        //List of modifiers that will be applied to shapes
        this.shapeModifiers = [];
        //List of items in shape tree
        this.itemsData = [];
        //List of items in previous shape tree
        this.processedElements = [];
        // List of animated components
        this.animatedContents = [];
        this.initElement(data,globalData,comp);
        //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created
        this.prevViewData = [];
        //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    }

    extendPrototype([BaseElement,TransformElement,SVGBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableDOMElement], SVGShapeElement);

    SVGShapeElement.prototype.initSecondaryElement = function() {
    };

    SVGShapeElement.prototype.identityMatrix = new Matrix();

    SVGShapeElement.prototype.buildExpressionInterface = function(){};

    SVGShapeElement.prototype.createContent = function(){
        this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);
        this.filterUniqueShapes();
    };

    /*
    This method searches for multiple shapes that affect a single element and one of them is animated
    */
    SVGShapeElement.prototype.filterUniqueShapes = function(){
        var i, len = this.shapes.length, shape;
        var j, jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;
        for(j = 0; j < jLen; j += 1) {
            style = this.stylesList[j];
            areAnimated = false;
            tempShapes.length = 0;
            for(i = 0; i < len; i += 1) {
                shape = this.shapes[i];
                if(shape.styles.indexOf(style) !== -1) {
                    tempShapes.push(shape);
                    areAnimated = shape._isAnimated || areAnimated;
                }
            }
            if(tempShapes.length > 1 && areAnimated) {
                this.setShapesAsAnimated(tempShapes);
            }
        }
    };

    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes){
        var i, len = shapes.length;
        for(i = 0; i < len; i += 1) {
            shapes[i].setAsAnimated();
        }
    };

    SVGShapeElement.prototype.createStyleElement = function(data, level){
        //TODO: prevent drawing of hidden styles
        var elementData;
        var styleOb = new SVGStyleData(data, level);

        var pathElement = styleOb.pElem;
        if(data.ty === 'st') {
            elementData = new SVGStrokeStyleData(this, data, styleOb);
        } else if(data.ty === 'fl') {
            elementData = new SVGFillStyleData(this, data, styleOb);
        } else if(data.ty === 'gf' || data.ty === 'gs') {
            var gradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
            elementData = new gradientConstructor(this, data, styleOb);
            this.globalData.defs.appendChild(elementData.gf);
            if (elementData.maskId) {
                this.globalData.defs.appendChild(elementData.ms);
                this.globalData.defs.appendChild(elementData.of);
                pathElement.setAttribute('mask','url(' + locationHref + '#' + elementData.maskId + ')');
            }
        }
        
        if(data.ty === 'st' || data.ty === 'gs') {
            pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');
            pathElement.setAttribute('stroke-linejoin',this.ljEnum[data.lj] || 'round');
            pathElement.setAttribute('fill-opacity','0');
            if(data.lj === 1) {
                pathElement.setAttribute('stroke-miterlimit',data.ml);
            }
        }

        if(data.r === 2) {
            pathElement.setAttribute('fill-rule', 'evenodd');
        }

        if(data.ln){
            pathElement.setAttribute('id',data.ln);
        }
        if(data.cl){
            pathElement.setAttribute('class',data.cl);
        }
        if(data.bm){
            pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
        }
        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };

    SVGShapeElement.prototype.createGroupElement = function(data) {
        var elementData = new ShapeGroupData();
        if(data.ln){
            elementData.gr.setAttribute('id',data.ln);
        }
        if(data.cl){
            elementData.gr.setAttribute('class',data.cl);
        }
        if(data.bm){
            elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
        }
        return elementData;
    };

    SVGShapeElement.prototype.createTransformElement = function(data, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this,data,this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };

    SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
        var ty = 4;
        if(data.ty === 'rc'){
            ty = 5;
        }else if(data.ty === 'el'){
            ty = 6;
        }else if(data.ty === 'sr'){
            ty = 7;
        }
        var shapeProperty = ShapePropertyFactory.getShapeProp(this,data,ty,this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data, elementData);
        return elementData;
    };

    SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
        var i = 0, len = this.animatedContents.length;
        while(i < len) {
            if(this.animatedContents[i].element === element) {
                return;
            }
            i += 1;
        }
        this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(data),
            element: element,
            data: data
        });
    };

    SVGShapeElement.prototype.setElementStyles = function(elementData){
        var arr = elementData.styles;
        var j, jLen = this.stylesList.length;
        for (j = 0; j < jLen; j += 1) {
            if (!this.stylesList[j].closed) {
                arr.push(this.stylesList[j]);
            }
        }
    };

    SVGShapeElement.prototype.reloadShapes = function(){
        this._isFirstFrame = true;
        var i, len = this.itemsData.length;
        for( i = 0; i < len; i += 1) {
            this.prevViewData[i] = this.itemsData[i];
        }
        this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;
        for(i = 0; i < len; i += 1) {
            this.dynamicProperties[i].getValue();
        }
        this.renderModifiers();
    };

    SVGShapeElement.prototype.searchShapes = function(arr,itemsData,prevViewData,container, level, transformers, render){
        var ownTransformers = [].concat(transformers);
        var i, len = arr.length - 1;
        var j, jLen;
        var ownStyles = [], ownModifiers = [], currentTransform, modifier, processedPos;
        for(i=len;i>=0;i-=1){
            processedPos = this.searchProcessedElement(arr[i]);
            if(!processedPos){
                arr[i]._render = render;
            } else {
                itemsData[i] = prevViewData[processedPos - 1];
            }
            if(arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs'){
                if(!processedPos){
                    itemsData[i] = this.createStyleElement(arr[i], level);
                } else {
                    itemsData[i].style.closed = false;
                }
                if(arr[i]._render){
                    container.appendChild(itemsData[i].style.pElem);
                }
                ownStyles.push(itemsData[i].style);
            }else if(arr[i].ty == 'gr'){
                if(!processedPos){
                    itemsData[i] = this.createGroupElement(arr[i]);
                } else {
                    jLen = itemsData[i].it.length;
                    for(j=0;j<jLen;j+=1){
                        itemsData[i].prevViewData[j] = itemsData[i].it[j];
                    }
                }
                this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,itemsData[i].gr, level + 1, ownTransformers, render);
                if(arr[i]._render){
                    container.appendChild(itemsData[i].gr);
                }
            }else if(arr[i].ty == 'tr'){
                if(!processedPos){
                    itemsData[i] = this.createTransformElement(arr[i], container);
                }
                currentTransform = itemsData[i].transform;
                ownTransformers.push(currentTransform);
            }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
                if(!processedPos){
                    itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
                }
                this.setElementStyles(itemsData[i]);

            }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms' || arr[i].ty == 'pb'){
                if(!processedPos){
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this,arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                }
                ownModifiers.push(modifier);
            }else if(arr[i].ty == 'rp'){
                if(!processedPos){
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this,arr,i,itemsData);
                    this.shapeModifiers.push(modifier);
                    render = false;
                }else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                }
                ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i], i + 1);
        }
        len = ownStyles.length;
        for(i=0;i<len;i+=1){
            ownStyles[i].closed = true;
        }
        len = ownModifiers.length;
        for(i=0;i<len;i+=1){
            ownModifiers[i].closed = true;
        }
    };

    SVGShapeElement.prototype.renderInnerContent = function() {
        this.renderModifiers();
        var i, len = this.stylesList.length;
        for(i=0;i<len;i+=1){
            this.stylesList[i].reset();
        }
        this.renderShape();

        for (i = 0; i < len; i += 1) {
            if (this.stylesList[i]._mdf || this._isFirstFrame) {
                if(this.stylesList[i].msElem){
                    this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
                    //Adding M0 0 fixes same mask bug on all browsers
                    this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
                }
                this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
            }
        }
    };

    SVGShapeElement.prototype.renderShape = function() {
        var i, len = this.animatedContents.length;
        var animatedContent;
        for(i = 0; i < len; i += 1) {
            animatedContent = this.animatedContents[i];
            if((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
                animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
            }
        }
    };

    SVGShapeElement.prototype.destroy = function(){
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
    };

    function SVGTintFilter(filter, filterManager){
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type','matrix');
        feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
        feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result','f1');
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type','matrix');
        feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
        feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result','f2');
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        if(filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k){
            var feMerge = createNS('feMerge');
            filter.appendChild(feMerge);
            var feMergeNode;
            feMergeNode = createNS('feMergeNode');
            feMergeNode.setAttribute('in','SourceGraphic');
            feMerge.appendChild(feMergeNode);
            feMergeNode = createNS('feMergeNode');
            feMergeNode.setAttribute('in','f2');
            feMerge.appendChild(feMergeNode);
        }
    }

    SVGTintFilter.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            var colorBlack = this.filterManager.effectElements[0].p.v;
            var colorWhite = this.filterManager.effectElements[1].p.v;
            var opacity = this.filterManager.effectElements[2].p.v/100;
            this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
        }
    };
    function SVGFillFilter(filter, filterManager){
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type','matrix');
        feColorMatrix.setAttribute('color-interpolation-filters','sRGB');
        feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
    }
    SVGFillFilter.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            var color = this.filterManager.effectElements[2].p.v;
            var opacity = this.filterManager.effectElements[6].p.v;
            this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');
        }
    };
    function SVGGaussianBlurEffect(filter, filterManager){
        // Outset the filter region by 100% on all sides to accommodate blur expansion.
        filter.setAttribute('x','-100%');
        filter.setAttribute('y','-100%');
        filter.setAttribute('width','300%');
        filter.setAttribute('height','300%');

        this.filterManager = filterManager;
        var feGaussianBlur = createNS('feGaussianBlur');
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
    }

    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            // Empirical value, matching AE's blur appearance.
            var kBlurrinessToSigma = 0.3;
            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

            // Dimensions mapping:
            //
            //   1 -> horizontal & vertical
            //   2 -> horizontal only
            //   3 -> vertical only
            //
            var dimensions = this.filterManager.effectElements[1].p.v;
            var sigmaX = (dimensions == 3) ? 0 : sigma;
            var sigmaY = (dimensions == 2) ? 0 : sigma;

            this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + " " + sigmaY);

            // Repeat edges mapping:
            //
            //   0 -> off -> duplicate
            //   1 -> on  -> wrap
            var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate';
            this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
        }
    };
    function SVGStrokeEffect(elem, filterManager){
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem;
        this.paths = [];
    }

    SVGStrokeEffect.prototype.initialize = function(){

        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path,groupPath, i, len;
        if(this.filterManager.effectElements[1].p.v === 1){
            len = this.elem.maskManager.masksProperties.length;
            i = 0;
        } else {
            i = this.filterManager.effectElements[0].p.v - 1;
            len = i + 1;
        }
        groupPath = createNS('g'); 
        groupPath.setAttribute('fill','none');
        groupPath.setAttribute('stroke-linecap','round');
        groupPath.setAttribute('stroke-dashoffset',1);
        for(i;i<len;i+=1){
            path = createNS('path');
            groupPath.appendChild(path);
            this.paths.push({p:path,m:i});
        }
        if(this.filterManager.effectElements[10].p.v === 3){
            var mask = createNS('mask');
            var id = createElementID();
            mask.setAttribute('id',id);
            mask.setAttribute('mask-type','alpha');
            mask.appendChild(groupPath);
            this.elem.globalData.defs.appendChild(mask);
            var g = createNS('g');
            g.setAttribute('mask','url(' + locationHref + '#'+id+')');
            while (elemChildren[0]) {
                g.appendChild(elemChildren[0]);
            }
            this.elem.layerElement.appendChild(g);
            this.masker = mask;
            groupPath.setAttribute('stroke','#fff');
        } else if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
            if(this.filterManager.effectElements[10].p.v === 2){
                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                while(elemChildren.length){
                    this.elem.layerElement.removeChild(elemChildren[0]);
                }
            }
            this.elem.layerElement.appendChild(groupPath);
            this.elem.layerElement.removeAttribute('mask');
            groupPath.setAttribute('stroke','#fff');
        }
        this.initialized = true;
        this.pathMasker = groupPath;
    };

    SVGStrokeEffect.prototype.renderFrame = function(forceRender){
        if(!this.initialized){
            this.initialize();
        }
        var i, len = this.paths.length;
        var mask, path;
        for(i=0;i<len;i+=1){
            if(this.paths[i].m === -1) {
                continue;
            }
            mask = this.elem.maskManager.viewData[this.paths[i].m];
            path = this.paths[i].p;
            if(forceRender || this.filterManager._mdf || mask.prop._mdf){
                path.setAttribute('d',mask.lastPath);
            }
            if(forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf){
                var dasharrayValue;
                if(this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100){
                    var s = Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
                    var e = Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;
                    var l = path.getTotalLength();
                    dasharrayValue = '0 0 0 ' + l*s + ' ';
                    var lineLength = l*(e-s);
                    var segment = 1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
                    var units = Math.floor(lineLength/segment);
                    var j;
                    for(j=0;j<units;j+=1){
                        dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100 + ' ';
                    }
                    dasharrayValue += '0 ' + l*10 + ' 0 0';
                } else {
                    dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;
                }
                path.setAttribute('stroke-dasharray',dasharrayValue);
            }
        }
        if(forceRender || this.filterManager.effectElements[4].p._mdf){
            this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);
        }
        
        if(forceRender || this.filterManager.effectElements[6].p._mdf){
            this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);
        }
        if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){
            if(forceRender || this.filterManager.effectElements[3].p._mdf){
                var color = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute('stroke','rgb('+bm_floor(color[0]*255)+','+bm_floor(color[1]*255)+','+bm_floor(color[2]*255)+')');
            }
        }
    };
    function SVGTritoneFilter(filter, filterManager){
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type','matrix');
        feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');
        feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result','f1');
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS('feComponentTransfer');
        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
        filter.appendChild(feComponentTransfer);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS('feFuncR');
        feFuncR.setAttribute('type','table');
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS('feFuncG');
        feFuncG.setAttribute('type','table');
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS('feFuncB');
        feFuncB.setAttribute('type','table');
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
    }

    SVGTritoneFilter.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            var color1 = this.filterManager.effectElements[0].p.v;
            var color2 = this.filterManager.effectElements[1].p.v;
            var color3 = this.filterManager.effectElements[2].p.v;
            var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
            var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
            var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
            this.feFuncR.setAttribute('tableValues', tableR);
            this.feFuncG.setAttribute('tableValues', tableG);
            this.feFuncB.setAttribute('tableValues', tableB);
            //var opacity = this.filterManager.effectElements[2].p.v/100;
            //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
        }
    };
    function SVGProLevelsFilter(filter, filterManager){
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS('feComponentTransfer');
        
        if(effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1){
            this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
        }
        if(effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1){
            this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
        }
        if(effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1){
            this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
        }
        if(effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1){
            this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
        }
        
        if(this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA){
            feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
            filter.appendChild(feComponentTransfer);
            feComponentTransfer = createNS('feComponentTransfer');
        }

        if(effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1){

            feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');
            filter.appendChild(feComponentTransfer);
            this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
            this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
            this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
        }
    }

    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute('type','table');
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
    };

    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null,{length:segments});
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack; 
        var inputDelta = inputWhite - inputBlack; 
        while(cnt <= 256) {
            perc = cnt/256;
            if(perc <= min){
                colorValue = inputDelta < 0 ? outputWhite : outputBlack;
            } else if(perc >= max){
                colorValue = inputDelta < 0 ? outputBlack : outputWhite;
            } else {
                colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
            }
            table[pos++] = colorValue;
            cnt += 256/(segments-1);
        }
        return table.join(' ');
    };

    SVGProLevelsFilter.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            var val;
            var effectElements = this.filterManager.effectElements;
            if(this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)){
                val = this.getTableValue(effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v,effectElements[7].p.v);
                this.feFuncRComposed.setAttribute('tableValues',val);
                this.feFuncGComposed.setAttribute('tableValues',val);
                this.feFuncBComposed.setAttribute('tableValues',val);
            }


            if(this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)){
                val = this.getTableValue(effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v,effectElements[14].p.v);
                this.feFuncR.setAttribute('tableValues',val);
            }

            if(this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)){
                val = this.getTableValue(effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v,effectElements[21].p.v);
                this.feFuncG.setAttribute('tableValues',val);
            }

            if(this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)){
                val = this.getTableValue(effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v,effectElements[28].p.v);
                this.feFuncB.setAttribute('tableValues',val);
            }

            if(this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)){
                val = this.getTableValue(effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v,effectElements[35].p.v);
                this.feFuncA.setAttribute('tableValues',val);
            }
            
        }
    };
    function SVGDropShadowEffect(filter, filterManager) {
        var filterSize = filterManager.container.globalData.renderConfig.filterSize;
        filter.setAttribute('x', filterSize.x);
        filter.setAttribute('y', filterSize.y);
        filter.setAttribute('width', filterSize.width);
        filter.setAttribute('height', filterSize.height);
        this.filterManager = filterManager;

        var feGaussianBlur = createNS('feGaussianBlur');
        feGaussianBlur.setAttribute('in','SourceAlpha');
        feGaussianBlur.setAttribute('result','drop_shadow_1');
        feGaussianBlur.setAttribute('stdDeviation','0');
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);

        var feOffset = createNS('feOffset');
        feOffset.setAttribute('dx','25');
        feOffset.setAttribute('dy','0');
        feOffset.setAttribute('in','drop_shadow_1');
        feOffset.setAttribute('result','drop_shadow_2');
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS('feFlood');
        feFlood.setAttribute('flood-color','#00ff00');
        feFlood.setAttribute('flood-opacity','1');
        feFlood.setAttribute('result','drop_shadow_3');
        this.feFlood = feFlood;
        filter.appendChild(feFlood);

        var feComposite = createNS('feComposite');
        feComposite.setAttribute('in','drop_shadow_3');
        feComposite.setAttribute('in2','drop_shadow_2');
        feComposite.setAttribute('operator','in');
        feComposite.setAttribute('result','drop_shadow_4');
        filter.appendChild(feComposite);


        var feMerge = createNS('feMerge');
        filter.appendChild(feMerge);
        var feMergeNode;
        feMergeNode = createNS('feMergeNode');
        feMerge.appendChild(feMergeNode);
        feMergeNode = createNS('feMergeNode');
        feMergeNode.setAttribute('in','SourceGraphic');
        this.feMergeNode = feMergeNode;
        this.feMerge = feMerge;
        this.originalNodeAdded = false;
        feMerge.appendChild(feMergeNode);
    }

    SVGDropShadowEffect.prototype.renderFrame = function(forceRender){
        if(forceRender || this.filterManager._mdf){
            if(forceRender || this.filterManager.effectElements[4].p._mdf){
                this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
            }
            if(forceRender || this.filterManager.effectElements[0].p._mdf){
                var col = this.filterManager.effectElements[0].p.v;
                this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));
            }
            if(forceRender || this.filterManager.effectElements[1].p._mdf){
                this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);
            }
            if(forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf){
                var distance = this.filterManager.effectElements[3].p.v;
                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
                var x = distance * Math.cos(angle);
                var y = distance * Math.sin(angle);
                this.feOffset.setAttribute('dx', x);
                this.feOffset.setAttribute('dy', y);
            }
            /*if(forceRender || this.filterManager.effectElements[5].p._mdf){
                if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
                    this.feMerge.removeChild(this.feMergeNode);
                    this.originalNodeAdded = false;
                } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
                    this.feMerge.appendChild(this.feMergeNode);
                    this.originalNodeAdded = true;
                }
            }*/
        }
    };
    var _svgMatteSymbols = [];

    function SVGMatte3Effect(filterElem, filterManager, elem){
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem;
        elem.matteElement = createNS('g');
        elem.matteElement.appendChild(elem.layerElement);
        elem.matteElement.appendChild(elem.transformedElement);
        elem.baseElement = elem.matteElement;
    }

    SVGMatte3Effect.prototype.findSymbol = function(mask) {
        var i = 0, len = _svgMatteSymbols.length;
        while(i < len) {
            if(_svgMatteSymbols[i] === mask) {
                return _svgMatteSymbols[i];
            }
            i += 1;
        }
        return null;
    };

    SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
        var parentNode = mask.layerElement.parentNode;
        if(!parentNode) {
            return;
        }
        var children = parentNode.children;
        var i = 0, len = children.length;
        while (i < len) {
            if (children[i] === mask.layerElement) {
                break;
            }
            i += 1;
        }
        var nextChild;
        if (i <= len - 2) {
            nextChild = children[i + 1];
        }
        var useElem = createNS('use');
        useElem.setAttribute('href', '#' + symbolId);
        if(nextChild) {
            parentNode.insertBefore(useElem, nextChild);
        } else {
            parentNode.appendChild(useElem);
        }
    };

    SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
        if(!this.findSymbol(mask)) {
            var symbolId = createElementID();
            var masker = createNS('mask');
            masker.setAttribute('id', mask.layerId);
            masker.setAttribute('mask-type', 'alpha');
            _svgMatteSymbols.push(mask);
            var defs = elem.globalData.defs;
            defs.appendChild(masker);
            var symbol = createNS('symbol');
            symbol.setAttribute('id', symbolId);
            this.replaceInParent(mask, symbolId);
            symbol.appendChild(mask.layerElement);
            defs.appendChild(symbol);
            var useElem = createNS('use');
            useElem.setAttribute('href', '#' + symbolId);
            masker.appendChild(useElem);
            mask.data.hd = false;
            mask.show();
        }
        elem.setMatte(mask.layerId);
    };

    SVGMatte3Effect.prototype.initialize = function() {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i = 0, len = elements.length;
        while (i < len) {
        	if (elements[i] && elements[i].data.ind === ind) {
        		this.setElementAsMask(this.elem, elements[i]);
        	}
        	i += 1;
        }
        this.initialized = true;
    };

    SVGMatte3Effect.prototype.renderFrame = function() {
    	if(!this.initialized) {
    		this.initialize();
    	}
    };
    function SVGEffects(elem){
        var i, len = elem.data.ef ? elem.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId);
        var count = 0;
        this.filters = [];
        var filterManager;
        for(i=0;i<len;i+=1){
            filterManager = null;
            if(elem.data.ef[i].ty === 20){
                count += 1;
                filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 21){
                count += 1;
                filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 22){
                filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 23){
                count += 1;
                filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 24){
                count += 1;
                filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 25){
                count += 1;
                filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
            }else if(elem.data.ef[i].ty === 28){
                //count += 1;
                filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
            }else if(elem.data.ef[i].ty === 29){
                count += 1;
                filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
            }
            if(filterManager) {
                this.filters.push(filterManager);
            }
        }
        if(count){
            elem.globalData.defs.appendChild(fil);
            elem.layerElement.setAttribute('filter','url(' + locationHref + '#'+filId+')');
        }
        if (this.filters.length) {
            elem.addRenderableComponent(this);
        }
    }

    SVGEffects.prototype.renderFrame = function(_isFirstFrame){
        var i, len = this.filters.length;
        for(i=0;i<len;i+=1){
            this.filters[i].renderFrame(_isFirstFrame);
        }
    };
    function CVContextData() {
    	this.saved = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        this.cO = 1;
        var i, len = 15;
        this.savedOp = createTypedArray('float32', len);
        for(i=0;i<len;i+=1){
            this.saved[i] = createTypedArray('float32', 16);
        }
        this._length = len;
    }

    CVContextData.prototype.duplicate = function() {
    	var newLength = this._length * 2;
    	var currentSavedOp = this.savedOp;
        this.savedOp = createTypedArray('float32', newLength);
        this.savedOp.set(currentSavedOp);
        var i = 0;
        for(i = this._length; i < newLength; i += 1) {
            this.saved[i] = createTypedArray('float32', 16);
        }
        this._length = newLength;
    };

    CVContextData.prototype.reset = function() {
    	this.cArrPos = 0;
    	this.cTr.reset();
        this.cO = 1;
    };
    function CVBaseElement(){
    }

    CVBaseElement.prototype = {
        createElements: function(){},
        initRendererElement: function(){},
        createContainerElements: function(){
            this.canvasContext = this.globalData.canvasContext;
            this.renderableEffectsManager = new CVEffects(this);
        },
        createContent: function(){},
        setBlendMode: function(){
            var globalData = this.globalData;
            if(globalData.blendMode !== this.data.bm) {
                globalData.blendMode = this.data.bm;
                var blendModeValue = getBlendMode(this.data.bm);
                globalData.canvasContext.globalCompositeOperation = blendModeValue;
            }
        },
        createRenderableComponents: function(){
            this.maskManager = new CVMaskElement(this.data, this);
        },
        hideElement: function(){
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                this.hidden = true;
            }
        },
        showElement: function(){
            if (this.isInRange && !this.isTransparent){
                this.hidden = false;
                this._isFirstFrame = true;
                this.maskManager._isFirstFrame = true;
            }
        },
        renderFrame: function() {
            if (this.hidden || this.data.hd) {
                return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.setBlendMode();
            var forceRealStack = this.data.ty === 0;
            this.globalData.renderer.save(forceRealStack);
            this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
            this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
            this.renderInnerContent();
            this.globalData.renderer.restore(forceRealStack);
            if(this.maskManager.hasMasks) {
                this.globalData.renderer.restore(true);
            }
            if (this._isFirstFrame) {
                this._isFirstFrame = false;
            }
        },
        destroy: function(){
            this.canvasContext = null;
            this.data = null;
            this.globalData = null;
            this.maskManager.destroy();
        },
        mHelper: new Matrix()
    };
    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

    function CVImageElement(data, globalData, comp){
        this.assetData = globalData.getAssetData(data.refId);
        this.img = globalData.imageLoader.getImage(this.assetData);
        this.initElement(data,globalData,comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);

    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

    CVImageElement.prototype.createContent = function(){

        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
            var canvas = createTag('canvas');
            canvas.width = this.assetData.w;
            canvas.height = this.assetData.h;
            var ctx = canvas.getContext('2d');

            var imgW = this.img.width;
            var imgH = this.img.height;
            var imgRel = imgW / imgH;
            var canvasRel = this.assetData.w/this.assetData.h;
            var widthCrop, heightCrop;
            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
            if((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
                heightCrop = imgH;
                widthCrop = heightCrop*canvasRel;
            } else {
                widthCrop = imgW;
                heightCrop = widthCrop/canvasRel;
            }
            ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);
            this.img = canvas;
        }

    };

    CVImageElement.prototype.renderInnerContent = function(parentMatrix){
        this.canvasContext.drawImage(this.img, 0, 0);
    };

    CVImageElement.prototype.destroy = function(){
        this.img = null;
    };
    function CVCompElement(data, globalData, comp) {
        this.completeLayers = false;
        this.layers = data.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate, this) : {_placeholder:true};
    }

    extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

    CVCompElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i,len = this.layers.length;
        for( i = len - 1; i >= 0; i -= 1 ){
            if(this.completeLayers || this.elements[i]){
                this.elements[i].renderFrame();
            }
        }
    };

    CVCompElement.prototype.destroy = function(){
        var i,len = this.layers.length;
        for( i = len - 1; i >= 0; i -= 1 ){
            if(this.elements[i]) {
                this.elements[i].destroy();
            }
        }
        this.layers = null;
        this.elements = null;
    };

    function CVMaskElement(data,element){
        this.data = data;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i, len = this.masksProperties.length, hasMasks = false;
        for (i = 0; i < len; i++) {
            if(this.masksProperties[i].mode !== 'n'){
                hasMasks = true;
            }
            this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3);
        }
        this.hasMasks = hasMasks;
        if(hasMasks) {
            this.element.addRenderableComponent(this);
        }
    }

    CVMaskElement.prototype.renderFrame = function () {
        if(!this.hasMasks){
            return;
        }
        var transform = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i, len = this.masksProperties.length;
        var pt,pts,data;
        ctx.beginPath();
        for (i = 0; i < len; i++) {
            if(this.masksProperties[i].mode !== 'n'){
                if (this.masksProperties[i].inv) {
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.element.globalData.compSize.w, 0);
                    ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                    ctx.lineTo(0, this.element.globalData.compSize.h);
                    ctx.lineTo(0, 0);
                }
                data = this.viewData[i].v;
                pt = transform.applyToPointArray(data.v[0][0],data.v[0][1],0);
                ctx.moveTo(pt[0], pt[1]);
                var j, jLen = data._length;
                for (j = 1; j < jLen; j++) {
                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
                }
                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
        }
        this.element.globalData.renderer.save(true);
        ctx.clip();
    };

    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

    CVMaskElement.prototype.destroy = function(){
        this.element = null;
    };
    function CVShapeElement(data, globalData, comp) {
        this.shapes = [];
        this.shapesData = data.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data, globalData, comp);
    }

    extendPrototype([BaseElement,TransformElement,CVBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableElement], CVShapeElement);

    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;

    CVShapeElement.prototype.transformHelper = {opacity:1,_opMdf:false};

    CVShapeElement.prototype.dashResetter = [];

    CVShapeElement.prototype.createContent = function(){
        this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);
    };

    CVShapeElement.prototype.createStyleElement = function(data, transforms) {
        var styleElem = {
            data: data,
            type: data.ty,
            preTransforms: this.transformsManager.addTransformSequence(transforms),
            transforms: [],
            elements: [],
            closed: data.hd === true
        };
        var elementData = {};
        if(data.ty == 'fl' || data.ty == 'st'){
            elementData.c = PropertyFactory.getProp(this,data.c,1,255,this);
            if(!elementData.c.k){
                styleElem.co = 'rgb('+bm_floor(elementData.c.v[0])+','+bm_floor(elementData.c.v[1])+','+bm_floor(elementData.c.v[2])+')';
            }
        } else if (data.ty === 'gf' || data.ty === 'gs') {
            elementData.s = PropertyFactory.getProp(this,data.s,1,null,this);
            elementData.e = PropertyFactory.getProp(this,data.e,1,null,this);
            elementData.h = PropertyFactory.getProp(this,data.h||{k:0},0,0.01,this);
            elementData.a = PropertyFactory.getProp(this,data.a||{k:0},0,degToRads,this);
            elementData.g = new GradientProperty(this,data.g,this);
        }
        elementData.o = PropertyFactory.getProp(this,data.o,0,0.01,this);
        if(data.ty == 'st' || data.ty == 'gs') {
            styleElem.lc = this.lcEnum[data.lc] || 'round';
            styleElem.lj = this.ljEnum[data.lj] || 'round';
            if(data.lj == 1) {
                styleElem.ml = data.ml;
            }
            elementData.w = PropertyFactory.getProp(this,data.w,0,null,this);
            if(!elementData.w.k){
                styleElem.wi = elementData.w.v;
            }
            if(data.d){
                var d = new DashProperty(this,data.d,'canvas', this);
                elementData.d = d;
                if(!elementData.d.k){
                    styleElem.da = elementData.d.dashArray;
                    styleElem.do = elementData.d.dashoffset[0];
                }
            }
        } else {
            styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
        }
        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
    };

    CVShapeElement.prototype.createGroupElement = function(data) {
        var elementData = {
            it: [],
            prevViewData: []
        };
        return elementData;
    };

    CVShapeElement.prototype.createTransformElement = function(data) {
        var elementData = {
            transform : {
                opacity: 1,
                _opMdf:false,
                key: this.transformsManager.getNewKey(),
                op: PropertyFactory.getProp(this,data.o,0,0.01,this),
                mProps: TransformPropertyFactory.getTransformProperty(this,data,this)
            }
        };
        return elementData;
    };

    CVShapeElement.prototype.createShapeElement = function(data) {
        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
        
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
    };

    CVShapeElement.prototype.reloadShapes = function() {
        this._isFirstFrame = true;
        var i, len = this.itemsData.length;
        for (i = 0; i < len; i += 1) {
            this.prevViewData[i] = this.itemsData[i];
        }
        this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);
        len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
            this.dynamicProperties[i].getValue();
        }
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
    };

    CVShapeElement.prototype.addTransformToStyleList = function(transform) {
        var i, len = this.stylesList.length;
        for (i = 0; i < len; i += 1) {
            if(!this.stylesList[i].closed) {
                this.stylesList[i].transforms.push(transform);
            }
        }
    };

    CVShapeElement.prototype.removeTransformFromStyleList = function() {
        var i, len = this.stylesList.length;
        for (i = 0; i < len; i += 1) {
            if(!this.stylesList[i].closed) {
                this.stylesList[i].transforms.pop();
            }
        }
    };

    CVShapeElement.prototype.closeStyles = function(styles) {
        var i, len = styles.length;
        for (i = 0; i < len; i += 1) {
            styles[i].closed = true;
        }
    };

    CVShapeElement.prototype.searchShapes = function(arr,itemsData, prevViewData, shouldRender, transforms){
        var i, len = arr.length - 1;
        var j, jLen;
        var ownStyles = [], ownModifiers = [], processedPos, modifier, currentTransform;
        var ownTransforms = [].concat(transforms);
        for(i=len;i>=0;i-=1){
            processedPos = this.searchProcessedElement(arr[i]);
            if(!processedPos){
                arr[i]._shouldRender = shouldRender;
            } else {
                itemsData[i] = prevViewData[processedPos - 1];
            }
            if(arr[i].ty == 'fl' || arr[i].ty == 'st'|| arr[i].ty == 'gf'|| arr[i].ty == 'gs'){
                if(!processedPos){
                    itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
                } else {
                    itemsData[i].style.closed = false;
                }
                
                ownStyles.push(itemsData[i].style);
            }else if(arr[i].ty == 'gr'){
                if(!processedPos){
                    itemsData[i] = this.createGroupElement(arr[i]);
                } else {
                    jLen = itemsData[i].it.length;
                    for(j=0;j<jLen;j+=1){
                        itemsData[i].prevViewData[j] = itemsData[i].it[j];
                    }
                }
                this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData, shouldRender, ownTransforms);
            }else if(arr[i].ty == 'tr'){
                if(!processedPos){
                    currentTransform = this.createTransformElement(arr[i]);
                    itemsData[i] = currentTransform;
                }
                ownTransforms.push(itemsData[i]);
                this.addTransformToStyleList(itemsData[i]);
            }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){
                if(!processedPos){
                    itemsData[i] = this.createShapeElement(arr[i]);
                }
                
            }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'pb'){
                if(!processedPos){
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    modifier.init(this,arr[i]);
                    itemsData[i] = modifier;
                    this.shapeModifiers.push(modifier);
                } else {
                    modifier = itemsData[i];
                    modifier.closed = false;
                }
                ownModifiers.push(modifier);
            } else if(arr[i].ty == 'rp'){
                if(!processedPos){
                    modifier = ShapeModifiers.getModifier(arr[i].ty);
                    itemsData[i] = modifier;
                    modifier.init(this,arr,i,itemsData);
                    this.shapeModifiers.push(modifier);
                    shouldRender = false;
                }else {
                    modifier = itemsData[i];
                    modifier.closed = true;
                }
                ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i], i + 1);
        }
        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;
        for(i=0;i<len;i+=1){
            ownModifiers[i].closed = true;
        }
    };

    CVShapeElement.prototype.renderInnerContent = function() {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper,this.shapesData,this.itemsData,true);
    };

    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
        if(parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
            groupTransform.opacity = parentTransform.opacity;
            groupTransform.opacity *= groupTransform.op.v;
            groupTransform._opMdf = true;
        }
    };

    CVShapeElement.prototype.drawLayer = function() {
        var i, len = this.stylesList.length;
        var j, jLen, k, kLen,elems,nodes, renderer = this.globalData.renderer, ctx = this.globalData.canvasContext, type, currentStyle;
        for(i=0;i<len;i+=1){
            currentStyle = this.stylesList[i];
            type = currentStyle.type;

            //Skipping style when
            //Stroke width equals 0
            //style should not be rendered (extra unused repeaters)
            //current opacity equals 0
            //global opacity equals 0
            if(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0){
                continue;
            }
            renderer.save();
            elems = currentStyle.elements;
            if(type === 'st' || type === 'gs'){
                ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
                ctx.lineWidth = currentStyle.wi;
                ctx.lineCap = currentStyle.lc;
                ctx.lineJoin = currentStyle.lj;
                ctx.miterLimit = currentStyle.ml || 0;
            } else {
                ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
            }
            renderer.ctxOpacity(currentStyle.coOp);
            if(type !== 'st' && type !== 'gs'){
                ctx.beginPath();
            }
            renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;
            for(j=0;j<jLen;j+=1){
                if(type === 'st' || type === 'gs'){
                    ctx.beginPath();
                    if(currentStyle.da){
                        ctx.setLineDash(currentStyle.da);
                        ctx.lineDashOffset = currentStyle.do;
                    }
                }
                nodes = elems[j].trNodes;
                kLen = nodes.length;

                for(k=0;k<kLen;k+=1){
                    if(nodes[k].t == 'm'){
                        ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);
                    }else if(nodes[k].t == 'c'){
                        ctx.bezierCurveTo(nodes[k].pts[0],nodes[k].pts[1],nodes[k].pts[2],nodes[k].pts[3],nodes[k].pts[4],nodes[k].pts[5]);
                    }else {
                        ctx.closePath();
                    }
                }
                if(type === 'st' || type === 'gs'){
                    ctx.stroke();
                    if(currentStyle.da){
                        ctx.setLineDash(this.dashResetter);
                    }
                }
            }
            if(type !== 'st' && type !== 'gs'){
                ctx.fill(currentStyle.r);
            }
            renderer.restore();
        }
    };

    CVShapeElement.prototype.renderShape = function(parentTransform,items,data,isMain){
        var i, len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;
        for(i=len;i>=0;i-=1){
            if(items[i].ty == 'tr'){
                groupTransform = data[i].transform;
                this.renderShapeTransform(parentTransform, groupTransform);
            }else if(items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr'){
                this.renderPath(items[i],data[i]);
            }else if(items[i].ty == 'fl'){
                this.renderFill(items[i],data[i],groupTransform);
            }else if(items[i].ty == 'st'){
                this.renderStroke(items[i],data[i],groupTransform);
            }else if(items[i].ty == 'gf' || items[i].ty == 'gs'){
                this.renderGradientFill(items[i],data[i],groupTransform);
            }else if(items[i].ty == 'gr'){
                this.renderShape(groupTransform,items[i].it,data[i].it);
            }else if(items[i].ty == 'tm');
        }
        if(isMain){
            this.drawLayer();
        }
        
    };

    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape){
        if(this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
            var shapeNodes = styledShape.trNodes;
            var paths = shape.paths;
            var i, len, j, jLen = paths._length;
            shapeNodes.length = 0;
            var groupTransformMat = styledShape.transforms.finalTransform;
            for (j = 0; j < jLen; j += 1) {
                var pathNodes = paths.shapes[j];
                if(pathNodes && pathNodes.v){
                    len = pathNodes._length;
                    for (i = 1; i < len; i += 1) {
                        if (i === 1) {
                            shapeNodes.push({
                                t: 'm',
                                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                            });
                        }
                        shapeNodes.push({
                            t: 'c',
                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                        });
                    }
                    if (len === 1) {
                        shapeNodes.push({
                            t: 'm',
                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                        });
                    }
                    if (pathNodes.c && len) {
                        shapeNodes.push({
                            t: 'c',
                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                        });
                        shapeNodes.push({
                            t: 'z'
                        });
                    }
                }
            }
            styledShape.trNodes = shapeNodes;
        }
    };

    CVShapeElement.prototype.renderPath = function(pathData,itemData){
        if(pathData.hd !== true && pathData._shouldRender) {
            var i, len = itemData.styledShapes.length;
            for (i = 0; i < len; i += 1) {
                this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
            }
        }
    };

    CVShapeElement.prototype.renderFill = function(styleData,itemData, groupTransform){
        var styleElem = itemData.style;

        if (itemData.c._mdf || this._isFirstFrame) {
            styleElem.co = 'rgb(' 
            + bm_floor(itemData.c.v[0]) + ',' 
            + bm_floor(itemData.c.v[1]) + ',' 
            + bm_floor(itemData.c.v[2]) + ')';
        }
        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
            styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
    };

    CVShapeElement.prototype.renderGradientFill = function(styleData,itemData, groupTransform){
        var styleElem = itemData.style;
        if(!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
            var ctx = this.globalData.canvasContext;
            var grd;
            var pt1 = itemData.s.v, pt2 = itemData.e.v;
            if (styleData.t === 1) {
                grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
            } else {
                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

                var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;
                var dist = rad * percent;
                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                var grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
            }

            var i, len = styleData.g.p;
            var cValues = itemData.g.c;
            var opacity = 1;

            for (i = 0; i < len; i += 1){
                if(itemData.g._hasOpacity && itemData.g._collapsable) {
                    opacity = itemData.g.o[i*2 + 1];
                }
                grd.addColorStop(cValues[i * 4] / 100,'rgba('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ',' + opacity + ')');
            }
            styleElem.grd = grd;
        }
        styleElem.coOp = itemData.o.v*groupTransform.opacity;
        
    };

    CVShapeElement.prototype.renderStroke = function(styleData,itemData, groupTransform){
        var styleElem = itemData.style;
        var d = itemData.d;
        if(d && (d._mdf  || this._isFirstFrame)){
            styleElem.da = d.dashArray;
            styleElem.do = d.dashoffset[0];
        }
        if(itemData.c._mdf || this._isFirstFrame){
            styleElem.co = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';
        }
        if(itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame){
            styleElem.coOp = itemData.o.v*groupTransform.opacity;
        }
        if(itemData.w._mdf || this._isFirstFrame){
            styleElem.wi = itemData.w.v;
        }
    };


    CVShapeElement.prototype.destroy = function(){
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
    };


    function CVSolidElement(data, globalData, comp) {
        this.initElement(data,globalData,comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);

    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

    CVSolidElement.prototype.renderInnerContent = function() {
        var ctx = this.canvasContext;
        ctx.fillStyle = this.data.sc;
        ctx.fillRect(0, 0, this.data.sw, this.data.sh);
        //
    };
    function CVTextElement(data, globalData, comp){
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = 'canvas';
        this.values = {
            fill: 'rgba(0,0,0,0)',
            stroke: 'rgba(0,0,0,0)',
            sWidth: 0,
            fValue: ''
        };
        this.initElement(data,globalData,comp);
    }
    extendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement,ITextElement], CVTextElement);

    CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

    CVTextElement.prototype.buildNewText = function(){
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);

        var hasFill = false;
        if(documentData.fc) {
            hasFill = true;
            this.values.fill = this.buildColor(documentData.fc);
        }else {
            this.values.fill = 'rgba(0,0,0,0)';
        }
        this.fill = hasFill;
        var hasStroke = false;
        if(documentData.sc){
            hasStroke = true;
            this.values.stroke = this.buildColor(documentData.sc);
            this.values.sWidth = documentData.sw;
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i, len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + 'px '+ this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length;
        //this.tHelper.font = this.values.fValue;
        var charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr/1000*documentData.finalSize;
        var xPos = 0, yPos = 0, firstLine = true;
        var cnt = 0;
        for (i = 0; i < len; i += 1) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            shapeData = charData && charData.data || {};
            matrixHelper.reset();
            if(singleShape && letters[i].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
            }

            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
            jLen = shapes.length;
            matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);
            if(singleShape){
                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
            }
            commands = createSizedArray(jLen);
            for(j=0;j<jLen;j+=1){
                kLen = shapes[j].ks.k.i.length;
                pathNodes = shapes[j].ks.k;
                pathArr = [];
                for(k=1;k<kLen;k+=1){
                    if(k==1){
                        pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
                    }
                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));
                commands[j] = pathArr;
            }
            if(singleShape){
                xPos += letters[i].l;
                xPos += trackingOffset;
            }
            if(this.textSpans[cnt]){
                this.textSpans[cnt].elem = commands;
            } else {
                this.textSpans[cnt] = {elem: commands};
            }
            cnt +=1;
        }
    };

    CVTextElement.prototype.renderInnerContent = function(){
        var ctx = this.canvasContext;
        var finalMat = this.finalTransform.mat.props;
        ctx.font = this.values.fValue;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4;

        if(!this.data.singleShape){
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }

        var  i,len, j, jLen, k, kLen;
        var renderedLetters = this.textAnimator.renderedLetters;

        var letters = this.textProperty.currentData.l;

        len = letters.length;
        var renderedLetter;
        var lastFill = null, lastStroke = null, lastStrokeW = null, commands, pathArr;
        for(i=0;i<len;i+=1){
            if(letters[i].n){
                continue;
            }
            renderedLetter = renderedLetters[i];
            if(renderedLetter){
                this.globalData.renderer.save();
                this.globalData.renderer.ctxTransform(renderedLetter.p);
                this.globalData.renderer.ctxOpacity(renderedLetter.o);
            }
            if(this.fill){
                if(renderedLetter && renderedLetter.fc){
                    if(lastFill !== renderedLetter.fc){
                        lastFill = renderedLetter.fc;
                        ctx.fillStyle = renderedLetter.fc;
                    }
                }else if(lastFill !== this.values.fill){
                    lastFill = this.values.fill;
                    ctx.fillStyle = this.values.fill;
                }
                commands = this.textSpans[i].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for(j=0;j<jLen;j+=1) {
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                    for (k = 2; k < kLen; k += 6) {
                        this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                    }
                }
                this.globalData.canvasContext.closePath();
                this.globalData.canvasContext.fill();
                ///ctx.fillText(this.textSpans[i].val,0,0);
            }
            if(this.stroke){
                if(renderedLetter && renderedLetter.sw){
                    if(lastStrokeW !== renderedLetter.sw){
                        lastStrokeW = renderedLetter.sw;
                        ctx.lineWidth = renderedLetter.sw;
                    }
                }else if(lastStrokeW !== this.values.sWidth){
                    lastStrokeW = this.values.sWidth;
                    ctx.lineWidth = this.values.sWidth;
                }
                if(renderedLetter && renderedLetter.sc){
                    if(lastStroke !== renderedLetter.sc){
                        lastStroke = renderedLetter.sc;
                        ctx.strokeStyle = renderedLetter.sc;
                    }
                }else if(lastStroke !== this.values.stroke){
                    lastStroke = this.values.stroke;
                    ctx.strokeStyle = this.values.stroke;
                }
                commands = this.textSpans[i].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for(j=0;j<jLen;j+=1) {
                    pathArr = commands[j];
                    kLen = pathArr.length;
                    this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                    for (k = 2; k < kLen; k += 6) {
                        this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                    }
                }
                this.globalData.canvasContext.closePath();
                this.globalData.canvasContext.stroke();
                ///ctx.strokeText(letters[i].val,0,0);
            }
            if(renderedLetter) {
                this.globalData.renderer.restore();
            }
        }
    };
    function CVEffects() {

    }
    CVEffects.prototype.renderFrame = function(){};
    function HBaseElement(data,globalData,comp){}
    HBaseElement.prototype = {
        checkBlendMode: function(){},
        initRendererElement: function(){
            this.baseElement = createTag(this.data.tg || 'div');
            if(this.data.hasMask) {
                this.svgElement = createNS('svg');
                this.layerElement = createNS('g');
                this.maskedElement = this.layerElement;
                this.svgElement.appendChild(this.layerElement);
                this.baseElement.appendChild(this.svgElement);
            } else {
                this.layerElement = this.baseElement;
            }
            styleDiv(this.baseElement);
        },
        createContainerElements: function(){
            this.renderableEffectsManager = new CVEffects(this);
            this.transformedElement = this.baseElement;
            this.maskedElement = this.layerElement;
            if (this.data.ln) {
                this.layerElement.setAttribute('id',this.data.ln);
            }
            if (this.data.cl) {
                this.layerElement.setAttribute('class', this.data.cl);
            }
            if (this.data.bm !== 0) {
                this.setBlendMode();
            }
        },
        renderElement: function() {
            if(this.finalTransform._matMdf){
                this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS();
            }
            if(this.finalTransform._opMdf){
                this.transformedElement.style.opacity = this.finalTransform.mProp.o.v;
            }
        },
        renderFrame: function() {
            //If it is exported as hidden (data.hd === true) no need to render
            //If it is not visible no need to render
            if (this.data.hd || this.hidden) {
                return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
                this._isFirstFrame = false;
            }
        },
        destroy: function(){
            this.layerElement = null;
            this.transformedElement = null;
            if(this.matteElement) {
                this.matteElement = null;
            }
            if(this.maskManager) {
                this.maskManager.destroy();
                this.maskManager = null;
            }
        },
        createRenderableComponents: function(){
            this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function(){
        },
        setMatte: function(){}
    };
    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
    HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;
    function HSolidElement(data,globalData,comp){
        this.initElement(data,globalData,comp);
    }
    extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], HSolidElement);

    HSolidElement.prototype.createContent = function(){
        var rect;
        if(this.data.hasMask){
            rect = createNS('rect');
            rect.setAttribute('width',this.data.sw);
            rect.setAttribute('height',this.data.sh);
            rect.setAttribute('fill',this.data.sc);
            this.svgElement.setAttribute('width',this.data.sw);
            this.svgElement.setAttribute('height',this.data.sh);
        } else {
            rect = createTag('div');
            rect.style.width = this.data.sw + 'px';
            rect.style.height = this.data.sh + 'px';
            rect.style.backgroundColor = this.data.sc;
        }
        this.layerElement.appendChild(rect);
    };

    function HCompElement(data,globalData,comp){
        this.layers = data.layers;
        this.supports3d = !data.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data,globalData,comp);
        this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};
    }

    extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

    HCompElement.prototype.createContainerElements = function(){
        this._createBaseContainerElements();
        //divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
        if(this.data.hasMask){
            this.svgElement.setAttribute('width',this.data.w);
            this.svgElement.setAttribute('height',this.data.h);
            this.transformedElement = this.baseElement;
        } else {
            this.transformedElement = this.layerElement;
        }
    };

    HCompElement.prototype.addTo3dContainer = function(elem,pos) {
        var j = 0;
        var nextElement;
        while(j<pos){
            if(this.elements[j] && this.elements[j].getBaseElement){
                nextElement = this.elements[j].getBaseElement();
            }
            j += 1;
        }
        if(nextElement){
            this.layerElement.insertBefore(elem, nextElement);
        } else {
            this.layerElement.appendChild(elem);
        }
    };

    function HShapeElement(data,globalData,comp){
        //List of drawable elements
        this.shapes = [];
        // Full shape data
        this.shapesData = data.shapes;
        //List of styles that will be applied to shapes
        this.stylesList = [];
        //List of modifiers that will be applied to shapes
        this.shapeModifiers = [];
        //List of items in shape tree
        this.itemsData = [];
        //List of items in previous shape tree
        this.processedElements = [];
        // List of animated components
        this.animatedContents = [];
        this.shapesContainer = createNS('g');
        this.initElement(data,globalData,comp);
        //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created
        this.prevViewData = [];
        this.currentBBox = {
            x:999999,
            y: -999999,
            h: 0,
            w: 0
        };
    }
    extendPrototype([BaseElement,TransformElement,HSolidElement,SVGShapeElement,HBaseElement,HierarchyElement,FrameElement,RenderableElement], HShapeElement);
    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

    HShapeElement.prototype.createContent = function(){
        var cont;
        this.baseElement.style.fontSize = 0;
        if (this.data.hasMask) {
            this.layerElement.appendChild(this.shapesContainer);
            cont = this.svgElement;
        } else {
            cont = createNS('svg');
            var size = this.comp.data ? this.comp.data : this.globalData.compSize;
            cont.setAttribute('width',size.w);
            cont.setAttribute('height',size.h);
            cont.appendChild(this.shapesContainer);
            this.layerElement.appendChild(cont);
        }

        this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.shapesContainer,0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
    };

    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
        var i, len = transformers.length;
        for(i = 0; i < len; i += 1) {
            point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
        }
        return point;
    };

    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i, len = shape._length, vPoint, oPoint, nextIPoint, nextVPoint;
        if (len <= 1) {
            return;
        }
        for (i = 0; i < len - 1; i += 1) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
        if(shape.c) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
    };

    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bm_min(bounds.left, boundingBox.x);
        boundingBox.xMax = bm_max(bounds.right, boundingBox.xMax);
        boundingBox.y = bm_min(bounds.top, boundingBox.y);
        boundingBox.yMax = bm_max(bounds.bottom, boundingBox.yMax);
    };

    HShapeElement.prototype.shapeBoundingBox = {
        left:0,
        right:0,
        top:0,
        bottom:0,
    };

    HShapeElement.prototype.tempBoundingBox = {
        x:0,
        xMax:0,
        y:0,
        yMax:0,
        width:0,
        height:0
    };

    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {

        var bounds = [[p0[0],p3[0]], [p0[1],p3[1]]];

        for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {

          b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
          a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
          c = 3 * p1[i] - 3 * p0[i];

          b = b | 0;
          a = a | 0;
          c = c | 0;

          if (a === 0) {

            if (b === 0) {
              continue;
            }

            t = -c / b;

            if (0 < t && t < 1) {
              bounds[i].push(this.calculateF(t,p0,p1,p2,p3,i));
            }
            continue;
          }

          b2ac = b * b - 4 * c * a;

          if (b2ac < 0) {
            continue;
          }

          t1 = (-b + bm_sqrt(b2ac))/(2 * a);
          if (0 < t1 && t1 < 1) bounds[i].push(this.calculateF(t1,p0,p1,p2,p3,i));

          t2 = (-b - bm_sqrt(b2ac))/(2 * a);
          if (0 < t2 && t2 < 1) bounds[i].push(this.calculateF(t2,p0,p1,p2,p3,i));

        }

        this.shapeBoundingBox.left = bm_min.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bm_min.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bm_max.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bm_max.apply(null, bounds[1]);
      };

      HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {
        return bm_pow(1-t, 3) * p0[i]
            + 3 * bm_pow(1-t, 2) * t * p1[i]
            + 3 * (1-t) * bm_pow(t, 2) * p2[i]
            + bm_pow(t, 3) * p3[i];
      };

    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
        var i, len = itemsData.length;
        for(i = 0; i < len; i += 1) {
            if(itemsData[i] && itemsData[i].sh) {
                this.calculateShapeBoundingBox(itemsData[i], boundingBox);
            } else if(itemsData[i] && itemsData[i].it) {
                this.calculateBoundingBox(itemsData[i].it, boundingBox);
            }
        }
    };

    HShapeElement.prototype.currentBoxContains = function(box) {
        return this.currentBBox.x <= box.x 
        && this.currentBBox.y <= box.y 
        && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
        && this.currentBBox.height + this.currentBBox.y >= box.y + box.height
    };

    HShapeElement.prototype.renderInnerContent = function() {
        this._renderShapeFrame();

        if(!this.hidden && (this._isFirstFrame || this._mdf)) {
            var tempBoundingBox = this.tempBoundingBox;
            var max = 999999;
            tempBoundingBox.x = max;
            tempBoundingBox.xMax = -max;
            tempBoundingBox.y = max;
            tempBoundingBox.yMax = -max;
            this.calculateBoundingBox(this.itemsData, tempBoundingBox);
            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
            //var tempBoundingBox = this.shapeCont.getBBox();
            if(this.currentBoxContains(tempBoundingBox)) {
                return;
            }
            var changed = false;
            if(this.currentBBox.w !== tempBoundingBox.width){
                this.currentBBox.w = tempBoundingBox.width;
                this.shapeCont.setAttribute('width',tempBoundingBox.width);
                changed = true;
            }
            if(this.currentBBox.h !== tempBoundingBox.height){
                this.currentBBox.h = tempBoundingBox.height;
                this.shapeCont.setAttribute('height',tempBoundingBox.height);
                changed = true;
            }
            if(changed  || this.currentBBox.x !== tempBoundingBox.x  || this.currentBBox.y !== tempBoundingBox.y){
                this.currentBBox.w = tempBoundingBox.width;
                this.currentBBox.h = tempBoundingBox.height;
                this.currentBBox.x = tempBoundingBox.x;
                this.currentBBox.y = tempBoundingBox.y;

                this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
                this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
            }
        }

    };
    function HTextElement(data,globalData,comp){
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
            x:999999,
            y: -999999,
            h: 0,
            w: 0
        };
        this.renderType = 'svg';
        this.isMasked = false;
        this.initElement(data,globalData,comp);

    }
    extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], HTextElement);

    HTextElement.prototype.createContent = function(){
        this.isMasked = this.checkMasks();
        if(this.isMasked){
            this.renderType = 'svg';
            this.compW = this.comp.data.w;
            this.compH = this.comp.data.h;
            this.svgElement.setAttribute('width',this.compW);
            this.svgElement.setAttribute('height',this.compH);
            var g = createNS('g');
            this.maskedElement.appendChild(g);
            this.innerElem = g;
        } else {
            this.renderType = 'html';
            this.innerElem = this.layerElement;
        }

        this.checkParenting();

    };

    HTextElement.prototype.buildNewText = function(){
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        innerElemStyle.color = innerElemStyle.fill = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
        if(documentData.sc){
            innerElemStyle.stroke = this.buildColor(documentData.sc);
            innerElemStyle.strokeWidth = documentData.sw+'px';
        }
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        if(!this.globalData.fontManager.chars){
            innerElemStyle.fontSize = documentData.finalSize+'px';
            innerElemStyle.lineHeight = documentData.finalSize+'px';
            if(fontData.fClass){
                this.innerElem.className = fontData.fClass;
            } else {
                innerElemStyle.fontFamily = fontData.fFamily;
                var fWeight = documentData.fWeight, fStyle = documentData.fStyle;
                innerElemStyle.fontStyle = fStyle;
                innerElemStyle.fontWeight = fWeight;
            }
        }
        var i, len;

        var letters = documentData.l;
        len = letters.length;
        var tSpan,tParent,tCont;
        var matrixHelper = this.mHelper;
        var shapes, shapeStr = '';
        var cnt = 0;
        for (i = 0;i < len ;i += 1) {
            if(this.globalData.fontManager.chars){
                if(!this.textPaths[cnt]){
                    tSpan = createNS('path');
                    tSpan.setAttribute('stroke-linecap', 'butt');
                    tSpan.setAttribute('stroke-linejoin','round');
                    tSpan.setAttribute('stroke-miterlimit','4');
                } else {
                    tSpan = this.textPaths[cnt];
                }
                if(!this.isMasked){
                    if(this.textSpans[cnt]){
                        tParent = this.textSpans[cnt];
                        tCont = tParent.children[0];
                    } else {

                        tParent = createTag('div');
                        tParent.style.lineHeight = 0;
                        tCont = createNS('svg');
                        tCont.appendChild(tSpan);
                        styleDiv(tParent);
                    }
                }
            }else {
                if(!this.isMasked){
                    if(this.textSpans[cnt]){
                        tParent = this.textSpans[cnt];
                        tSpan = this.textPaths[cnt];
                    } else {
                        tParent = createTag('span');
                        styleDiv(tParent);
                        tSpan = createTag('span');
                        styleDiv(tSpan);
                        tParent.appendChild(tSpan);
                    }
                } else {
                    tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
                }
            }
            //tSpan.setAttribute('visibility', 'hidden');
            if(this.globalData.fontManager.chars){
                var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                var shapeData;
                if(charData){
                    shapeData = charData.data;
                } else {
                    shapeData = null;
                }
                matrixHelper.reset();
                if(shapeData && shapeData.shapes){
                    shapes = shapeData.shapes[0].it;
                    matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);
                    shapeStr = this.createPathShape(matrixHelper,shapes);
                    tSpan.setAttribute('d',shapeStr);
                }
                if(!this.isMasked){
                    this.innerElem.appendChild(tParent);
                    if(shapeData && shapeData.shapes){

                        //document.body.appendChild is needed to get exact measure of shape
                        document.body.appendChild(tCont);
                        var boundingBox = tCont.getBBox();
                        tCont.setAttribute('width',boundingBox.width + 2);
                        tCont.setAttribute('height',boundingBox.height + 2);
                        tCont.setAttribute('viewBox',(boundingBox.x-1)+' '+ (boundingBox.y-1)+' '+ (boundingBox.width+2)+' '+ (boundingBox.height+2));
                        tCont.style.transform = tCont.style.webkitTransform = 'translate(' + (boundingBox.x-1) + 'px,' + (boundingBox.y-1) + 'px)';

                        letters[i].yOffset = boundingBox.y-1;

                    } else {
                        tCont.setAttribute('width',1);
                        tCont.setAttribute('height',1);
                    }
                        tParent.appendChild(tCont);
                }else {
                    this.innerElem.appendChild(tSpan);
                }
            }else {
                tSpan.textContent = letters[i].val;
                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space","preserve");
                if(!this.isMasked){
                    this.innerElem.appendChild(tParent);
                    //
                    tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,'+ -documentData.finalSize/1.2+'px,0)';
                } else {
                    this.innerElem.appendChild(tSpan);
                }
            }
            //
            if(!this.isMasked){
                this.textSpans[cnt] = tParent;
            }else {
                this.textSpans[cnt] = tSpan;
            }
            this.textSpans[cnt].style.display = 'block';
            this.textPaths[cnt] = tSpan;
            cnt += 1;
        }
        while(cnt < this.textSpans.length){
            this.textSpans[cnt].style.display = 'none';
            cnt += 1;
        }
    };

    HTextElement.prototype.renderInnerContent = function() {

        if(this.data.singleShape){
            if(!this._isFirstFrame && !this.lettersChangedFlag){
                return;
            } else {
                // Todo Benchmark if using this is better than getBBox
                 if(this.isMasked && this.finalTransform._matMdf){
                     this.svgElement.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+ -this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);
                    this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
                 }
            }
        }

        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag){
            return;
        }
        var  i,len, count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;

        var letters = this.textProperty.currentData.l;

        len = letters.length;
        var renderedLetter, textSpan, textPath;
        for(i=0;i<len;i+=1){
            if(letters[i].n){
                count += 1;
                continue;
            }
            textSpan = this.textSpans[i];
            textPath = this.textPaths[i];
            renderedLetter = renderedLetters[count];
            count += 1;
            if(renderedLetter._mdf.m) {
                if(!this.isMasked){
                    textSpan.style.transform = textSpan.style.webkitTransform = renderedLetter.m;
                }else {
                    textSpan.setAttribute('transform',renderedLetter.m);
                }
            }
            ////textSpan.setAttribute('opacity',renderedLetter.o);
            textSpan.style.opacity = renderedLetter.o;
            if(renderedLetter.sw && renderedLetter._mdf.sw){
                textPath.setAttribute('stroke-width',renderedLetter.sw);
            }
            if(renderedLetter.sc && renderedLetter._mdf.sc){
                textPath.setAttribute('stroke',renderedLetter.sc);
            }
            if(renderedLetter.fc && renderedLetter._mdf.fc){
                textPath.setAttribute('fill',renderedLetter.fc);
                textPath.style.color = renderedLetter.fc;
            }
        }

        if(this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)){
            var boundingBox = this.innerElem.getBBox();

            if(this.currentBBox.w !== boundingBox.width){
                this.currentBBox.w = boundingBox.width;
                this.svgElement.setAttribute('width',boundingBox.width);
            }
            if(this.currentBBox.h !== boundingBox.height){
                this.currentBBox.h = boundingBox.height;
                this.svgElement.setAttribute('height',boundingBox.height);
            }

            var margin = 1;
            if(this.currentBBox.w !== (boundingBox.width + margin*2) || this.currentBBox.h !== (boundingBox.height + margin*2)  || this.currentBBox.x !== (boundingBox.x - margin)  || this.currentBBox.y !== (boundingBox.y - margin)){
                this.currentBBox.w = boundingBox.width + margin*2;
                this.currentBBox.h = boundingBox.height + margin*2;
                this.currentBBox.x = boundingBox.x - margin;
                this.currentBBox.y = boundingBox.y - margin;

                this.svgElement.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);
                this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
            }
        }
    };
    function HImageElement(data,globalData,comp){
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data,globalData,comp);
    }

    extendPrototype([BaseElement,TransformElement,HBaseElement,HSolidElement,HierarchyElement,FrameElement,RenderableElement], HImageElement);


    HImageElement.prototype.createContent = function(){
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();

        if(this.data.hasMask){
            this.imageElem = createNS('image');
            this.imageElem.setAttribute('width',this.assetData.w+"px");
            this.imageElem.setAttribute('height',this.assetData.h+"px");
            this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);
            this.layerElement.appendChild(this.imageElem);
            this.baseElement.setAttribute('width',this.assetData.w);
            this.baseElement.setAttribute('height',this.assetData.h);
        } else {
            this.layerElement.appendChild(img);
        }
        img.src = assetPath;
        if(this.data.ln){
            this.baseElement.setAttribute('id',this.data.ln);
        }
    };
    function HCameraElement(data,globalData,comp){
        this.initFrame();
        this.initBaseData(data,globalData,comp);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this,data.pe,0,0,this);
        if(data.ks.p.s){
            this.px = getProp(this,data.ks.p.x,1,0,this);
            this.py = getProp(this,data.ks.p.y,1,0,this);
            this.pz = getProp(this,data.ks.p.z,1,0,this);
        }else {
            this.p = getProp(this,data.ks.p,1,0,this);
        }
        if(data.ks.a){
            this.a = getProp(this,data.ks.a,1,0,this);
        }
        if(data.ks.or.k.length && data.ks.or.k[0].to){
            var i,len = data.ks.or.k.length;
            for(i=0;i<len;i+=1){
                data.ks.or.k[i].to = null;
                data.ks.or.k[i].ti = null;
            }
        }
        this.or = getProp(this,data.ks.or,1,degToRads,this);
        this.or.sh = true;
        this.rx = getProp(this,data.ks.rx,0,degToRads,this);
        this.ry = getProp(this,data.ks.ry,0,degToRads,this);
        this.rz = getProp(this,data.ks.rz,0,degToRads,this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true;
        
        // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
        this.finalTransform = {
            mProp: this
        };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

    HCameraElement.prototype.setup = function() {
        var i, len = this.comp.threeDElements.length, comp;
        for(i=0;i<len;i+=1){
            //[perspectiveElem,container]
            comp = this.comp.threeDElements[i];
            if(comp.type === '3d') {
                comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
                comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = "0px 0px 0px";
                comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
            }
        }
    };

    HCameraElement.prototype.createElements = function(){
    };

    HCameraElement.prototype.hide = function(){
    };

    HCameraElement.prototype.renderFrame = function(){
        var _mdf = this._isFirstFrame;
        var i, len;
        if(this.hierarchy){
            len = this.hierarchy.length;
            for(i=0;i<len;i+=1){
                _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
            }
        }
        if(_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
            this.mat.reset();

            if(this.hierarchy){
                len = this.hierarchy.length - 1;
                for (i = len; i >= 0; i -= 1) {
                    var mTransf = this.hierarchy[i].finalTransform.mProp;
                    this.mat.translate(-mTransf.p.v[0],-mTransf.p.v[1],mTransf.p.v[2]);
                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                    this.mat.scale(1/mTransf.s.v[0],1/mTransf.s.v[1],1/mTransf.s.v[2]);
                    this.mat.translate(mTransf.a.v[0],mTransf.a.v[1],mTransf.a.v[2]);
                }
            }
            if (this.p) {
                this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);
            } else {
                this.mat.translate(-this.px.v,-this.py.v,this.pz.v);
            }
            if (this.a) {
                var diffVector;
                if (this.p) {
                    diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
                } else {
                    diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                }
                var mag = Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));
                //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
                var lookDir = [diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];
                var lookLengthOnXZ = Math.sqrt( lookDir[2]*lookDir[2] + lookDir[0]*lookDir[0] );
                var m_rotationX = (Math.atan2( lookDir[1], lookLengthOnXZ ));
                var m_rotationY = (Math.atan2( lookDir[0], -lookDir[2]));
                this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);

            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
            this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);
            this.mat.translate(0,0,this.pe.v);


            

            var hasMatrixChanged = !this._prevMat.equals(this.mat);
            if((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
                len = this.comp.threeDElements.length;
                var comp;
                for(i=0;i<len;i+=1){
                    comp = this.comp.threeDElements[i];
                    if(comp.type === '3d') {
                        if(hasMatrixChanged) {
                            comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();
                        }
                        if(this.pe._mdf) {
                            comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';
                        }
                    }
                }
                this.mat.clone(this._prevMat);
            }
        }
        this._isFirstFrame = false;
    };

    HCameraElement.prototype.prepareFrame = function(num) {
        this.prepareProperties(num, true);
    };

    HCameraElement.prototype.destroy = function(){
    };
    HCameraElement.prototype.getBaseElement = function(){return null;};
    var animationManager = (function(){
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;

        function removeElement(ev){
            var i = 0;
            var animItem = ev.target;
            while(i<len) {
                if (registeredAnimations[i].animation === animItem) {
                    registeredAnimations.splice(i, 1);
                    i -= 1;
                    len -= 1;
                    if(!animItem.isPaused){
                        subtractPlayingCount();
                    }
                }
                i += 1;
            }
        }

        function registerAnimation(element, animationData){
            if(!element){
                return null;
            }
            var i=0;
            while(i<len){
                if(registeredAnimations[i].elem == element && registeredAnimations[i].elem !== null ){
                    return registeredAnimations[i].animation;
                }
                i+=1;
            }
            var animItem = new AnimationItem();
            setupAnimation(animItem, element);
            animItem.setData(element, animationData);
            return animItem;
        }

        function getRegisteredAnimations() {
            var i, len = registeredAnimations.length;
            var animations = [];
            for(i = 0; i < len; i += 1) {
                animations.push(registeredAnimations[i].animation);
            }
            return animations;
        }

        function addPlayingCount(){
            playingAnimationsNum += 1;
            activate();
        }

        function subtractPlayingCount(){
            playingAnimationsNum -= 1;
        }

        function setupAnimation(animItem, element){
            animItem.addEventListener('destroy',removeElement);
            animItem.addEventListener('_active',addPlayingCount);
            animItem.addEventListener('_idle',subtractPlayingCount);
            registeredAnimations.push({elem: element,animation:animItem});
            len += 1;
        }

        function loadAnimation(params){
            var animItem = new AnimationItem();
            setupAnimation(animItem, null);
            animItem.setParams(params);
            return animItem;
        }


        function setSpeed(val,animation){
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.setSpeed(val, animation);
            }
        }

        function setDirection(val, animation){
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.setDirection(val, animation);
            }
        }

        function play(animation){
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.play(animation);
            }
        }
        function resume(nowTime) {
            var elapsedTime = nowTime - initTime;
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.advanceTime(elapsedTime);
            }
            initTime = nowTime;
            if(playingAnimationsNum && !_isFrozen) {
                window.requestAnimationFrame(resume);
            } else {
                _stopped = true;
            }
        }

        function first(nowTime){
            initTime = nowTime;
            window.requestAnimationFrame(resume);
        }

        function pause(animation) {
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.pause(animation);
            }
        }

        function goToAndStop(value,isFrame,animation) {
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);
            }
        }

        function stop(animation) {
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.stop(animation);
            }
        }

        function togglePause(animation) {
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.togglePause(animation);
            }
        }

        function destroy(animation) {
            var i;
            for(i=(len-1);i>=0;i-=1){
                registeredAnimations[i].animation.destroy(animation);
            }
        }

        function searchAnimations(animationData, standalone, renderer){
            var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
                      [].slice.call(document.getElementsByClassName('bodymovin')));
            var i, len = animElements.length;
            for(i=0;i<len;i+=1){
                if(renderer){
                    animElements[i].setAttribute('data-bm-type',renderer);
                }
                registerAnimation(animElements[i], animationData);
            }
            if(standalone && len === 0){
                if(!renderer){
                    renderer = 'svg';
                }
                var body = document.getElementsByTagName('body')[0];
                body.innerHTML = '';
                var div = createTag('div');
                div.style.width = '100%';
                div.style.height = '100%';
                div.setAttribute('data-bm-type',renderer);
                body.appendChild(div);
                registerAnimation(div, animationData);
            }
        }

        function resize(){
            var i;
            for(i=0;i<len;i+=1){
                registeredAnimations[i].animation.resize();
            }
        }

        function activate(){
            if(!_isFrozen && playingAnimationsNum){
                if(_stopped) {
                    window.requestAnimationFrame(first);
                    _stopped = false;
                }
            }
        }

        function freeze() {
            _isFrozen = true;
        }

        function unfreeze() {
            _isFrozen = false;
            activate();
        }

        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations;
        moduleOb.resize = resize;
        //moduleOb.start = start;
        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
    }());

    var AnimationItem = function () {
        this._cbs = [];
        this.name = '';
        this.path = '';
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = '';
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = subframeEnabled;
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
    };

    extendPrototype([BaseEvent], AnimationItem);

    AnimationItem.prototype.setParams = function(params) {
        if(params.wrapper || params.container){
            this.wrapper = params.wrapper || params.container;
        }
        var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';
        switch(animType){
            case 'canvas':
                this.renderer = new CanvasRenderer(this, params.rendererSettings);
                break;
            case 'svg':
                this.renderer = new SVGRenderer(this, params.rendererSettings);
                break;
            default:
                this.renderer = new HybridRenderer(this, params.rendererSettings);
                break;
        }
        this.imagePreloader.setCacheType(animType);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;
        if (params.loop === ''
            || params.loop === null
            || params.loop === undefined
            || params.loop === true)
        {
            this.loop = true;
        } else if (params.loop === false) {
            this.loop = false;
        } else {
            this.loop = parseInt(params.loop);
        }
        this.autoplay = 'autoplay' in params ? params.autoplay : true;
        this.name = params.name ? params.name :  '';
        this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments :  true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;
        if (params.animationData) {
            this.configAnimation(params.animationData);
        } else if(params.path){

            if( params.path.lastIndexOf('\\') !== -1){
                this.path = params.path.substr(0,params.path.lastIndexOf('\\')+1);
            } else {
                this.path = params.path.substr(0,params.path.lastIndexOf('/')+1);
            }
            this.fileName = params.path.substr(params.path.lastIndexOf('/')+1);
            this.fileName = this.fileName.substr(0,this.fileName.lastIndexOf('.json'));

            assetLoader.load(params.path, this.configAnimation.bind(this), function() {
                this.trigger('data_failed');
            }.bind(this));
        }

    };

    AnimationItem.prototype.setData = function (wrapper, animationData) {
        var params = {
            wrapper: wrapper,
            animationData: animationData ? (typeof animationData  === "object") ? animationData : JSON.parse(animationData) : null
        };
        var wrapperAttributes = wrapper.attributes;

        params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value :  wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
        params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value :  wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';

        var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value :  wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value :  wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
        if(loop === '');else if(loop === 'false'){
            params.loop = false;
        }else if(loop === 'true'){
            params.loop = true;
        }else {
            params.loop = parseInt(loop);
        }
        var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value :  wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value :  wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
        params.autoplay = autoplay !== "false";

        params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value :  wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value :  '';
        var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value :  wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value :  wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';

        if(prerender === 'false'){
            params.prerender = false;
        }
        this.setParams(params);
    };

    AnimationItem.prototype.includeLayers = function(data) {
        if(data.op > this.animationData.op){
            this.animationData.op = data.op;
            this.totalFrames = Math.floor(data.op - this.animationData.ip);
        }
        var layers = this.animationData.layers;
        var i, len = layers.length;
        var newLayers = data.layers;
        var j, jLen = newLayers.length;
        for(j=0;j<jLen;j+=1){
            i = 0;
            while(i<len){
                if(layers[i].id == newLayers[j].id){
                    layers[i] = newLayers[j];
                    break;
                }
                i += 1;
            }
        }
        if(data.chars || data.fonts){
            this.renderer.globalData.fontManager.addChars(data.chars);
            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
        }
        if(data.assets){
            len = data.assets.length;
            for(i = 0; i < len; i += 1){
                this.animationData.assets.push(data.assets[i]);
            }
        }
        this.animationData.__complete = false;
        dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);
        this.renderer.includeLayers(data.layers);
        if(expressionsPlugin){
            expressionsPlugin.initExpressions(this);
        }
        this.loadNextSegment();
    };

    AnimationItem.prototype.loadNextSegment = function() {
        var segments = this.animationData.segments;
        if(!segments || segments.length === 0 || !this.autoloadSegments){
            this.trigger('data_ready');
            this.timeCompleted = this.totalFrames;
            return;
        }
        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path+this.fileName+'_' + this.segmentPos + '.json';
        this.segmentPos += 1;
        assetLoader.load(segmentPath, this.includeLayers.bind(this), function() {
            this.trigger('data_failed');
        }.bind(this));
    };

    AnimationItem.prototype.loadSegments = function() {
        var segments = this.animationData.segments;
        if(!segments) {
            this.timeCompleted = this.totalFrames;
        }
        this.loadNextSegment();
    };

    AnimationItem.prototype.imagesLoaded = function() {
        this.trigger('loaded_images');
        this.checkLoaded();
    };

    AnimationItem.prototype.preloadImages = function() {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    };

    AnimationItem.prototype.configAnimation = function (animData) {
        if(!this.renderer){
            return;
        }
        try {
            this.animationData = animData;

            if (this.initialSegment) {
                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
                this.firstFrame = Math.round(this.initialSegment[0]);
            } else {
                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
                this.firstFrame = Math.round(this.animationData.ip);
            }
            this.renderer.configAnimation(animData);
            if(!animData.assets){
                animData.assets = [];
            }

            this.assets = this.animationData.assets;
            this.frameRate = this.animationData.fr;
            this.frameMult = this.animationData.fr / 1000;
            this.renderer.searchExtraCompositions(animData.assets);
            this.trigger('config_ready');
            this.preloadImages();
            this.loadSegments();
            this.updaFrameModifier();
            this.waitForFontsLoaded();
        } catch(error) {
            this.triggerConfigError(error);
        }
    };

    AnimationItem.prototype.waitForFontsLoaded = function(){
        if(!this.renderer) {
            return;
        }
        if(this.renderer.globalData.fontManager.isLoaded){
            this.checkLoaded();
        }else {
            setTimeout(this.waitForFontsLoaded.bind(this),20);
        }
    };

    AnimationItem.prototype.checkLoaded = function () {
        if (!this.isLoaded 
            && this.renderer.globalData.fontManager.isLoaded
            && (this.imagePreloader.loaded() || this.renderer.rendererType !== 'canvas')
        ) {
            this.isLoaded = true;
            dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);
            if(expressionsPlugin){
                expressionsPlugin.initExpressions(this);
            }
            this.renderer.initItems();
            setTimeout(function() {
                this.trigger('DOMLoaded');
            }.bind(this), 0);
            this.gotoFrame();
            if(this.autoplay){
                this.play();
            }
        }
    };

    AnimationItem.prototype.resize = function () {
        this.renderer.updateContainerSize();
    };

    AnimationItem.prototype.setSubframe = function(flag){
        this.isSubframeEnabled = !!flag;
    };

    AnimationItem.prototype.gotoFrame = function () {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;

        if(this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted){
            this.currentFrame = this.timeCompleted;
        }
        this.trigger('enterFrame');
        this.renderFrame();
    };

    AnimationItem.prototype.renderFrame = function () {
        if(this.isLoaded === false){
            return;
        }
        try {
            this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch(error) {
            this.triggerRenderFrameError(error);
        }
    };

    AnimationItem.prototype.play = function (name) {
        if(name && this.name != name){
            return;
        }
        if(this.isPaused === true){
            this.isPaused = false;
            if(this._idle){
                this._idle = false;
                this.trigger('_active');
            }
        }
    };

    AnimationItem.prototype.pause = function (name) {
        if(name && this.name != name){
            return;
        }
        if(this.isPaused === false){
            this.isPaused = true;
            this._idle = true;
            this.trigger('_idle');
        }
    };

    AnimationItem.prototype.togglePause = function (name) {
        if(name && this.name != name){
            return;
        }
        if(this.isPaused === true){
            this.play();
        }else {
            this.pause();
        }
    };

    AnimationItem.prototype.stop = function (name) {
        if(name && this.name != name){
            return;
        }
        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
    };

    AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
        if(name && this.name != name){
            return;
        }
        if(isFrame){
            this.setCurrentRawFrameValue(value);
        }else {
            this.setCurrentRawFrameValue(value * this.frameModifier);
        }
        this.pause();
    };

    AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
        this.goToAndStop(value, isFrame, name);
        this.play();
    };

    AnimationItem.prototype.advanceTime = function (value) {
        if (this.isPaused === true || this.isLoaded === false) {
            return;
        }
        var nextValue = this.currentRawFrame + value * this.frameModifier;
        var _isComplete = false;
        // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
            if (!this.loop || this.playCount === this.loop) {
                if (!this.checkSegments(nextValue >  this.totalFrames ? nextValue % this.totalFrames : 0)) {
                    _isComplete = true;
                    nextValue = this.totalFrames - 1;
                }
            } else if (nextValue >= this.totalFrames) {
                this.playCount += 1;
                if (!this.checkSegments(nextValue % this.totalFrames)) {
                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                    this._completedLoop = true;
                    this.trigger('loopComplete');
                }
            } else {
                this.setCurrentRawFrameValue(nextValue);
            }
        } else if(nextValue < 0) {
            if (!this.checkSegments(nextValue % this.totalFrames)) {
                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                    this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
                    if(!this._completedLoop) {
                        this._completedLoop = true;
                    } else {
                        this.trigger('loopComplete');
                    }
                } else {
                    _isComplete = true;
                    nextValue = 0;
                }
            }
        } else {
            this.setCurrentRawFrameValue(nextValue);
        }
        if (_isComplete) {
            this.setCurrentRawFrameValue(nextValue);
            this.pause();
            this.trigger('complete');
        }
    };

    AnimationItem.prototype.adjustSegment = function(arr, offset){
        this.playCount = 0;
        if(arr[1] < arr[0]){
            if(this.frameModifier > 0){
                if(this.playSpeed < 0){
                    this.setSpeed(-this.playSpeed);
                } else {
                    this.setDirection(-1);
                }
            }
            this.timeCompleted = this.totalFrames = arr[0] - arr[1];
            this.firstFrame = arr[1];
            this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
        } else if(arr[1] > arr[0]){
            if(this.frameModifier < 0){
                if(this.playSpeed < 0){
                    this.setSpeed(-this.playSpeed);
                } else {
                    this.setDirection(1);
                }
            }
            this.timeCompleted = this.totalFrames = arr[1] - arr[0];
            this.firstFrame = arr[0];
            this.setCurrentRawFrameValue(0.001 + offset);
        }
        this.trigger('segmentStart');
    };
    AnimationItem.prototype.setSegment = function (init,end) {
        var pendingFrame = -1;
        if(this.isPaused) {
            if (this.currentRawFrame + this.firstFrame < init) {
                pendingFrame = init;
            } else if (this.currentRawFrame + this.firstFrame > end) {
                pendingFrame = end - init;
            }
        }

        this.firstFrame = init;
        this.timeCompleted = this.totalFrames = end - init;
        if(pendingFrame !== -1) {
            this.goToAndStop(pendingFrame,true);
        }
    };

    AnimationItem.prototype.playSegments = function (arr, forceFlag) {
        if (forceFlag) {
            this.segments.length = 0;
        }
        if (typeof arr[0] === 'object') {
            var i, len = arr.length;
            for (i = 0; i < len; i += 1) {
                this.segments.push(arr[i]);
            }
        } else {
            this.segments.push(arr);
        }
        if (this.segments.length && forceFlag) {
            this.adjustSegment(this.segments.shift(), 0);
        }
        if (this.isPaused) {
            this.play();
        }
    };

    AnimationItem.prototype.resetSegments = function (forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip,this.animationData.op]);
        //this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);
        if (forceFlag) {
            this.checkSegments(0);
        }
    };
    AnimationItem.prototype.checkSegments = function(offset) {
        if (this.segments.length) {
            this.adjustSegment(this.segments.shift(), offset);
            return true;
        }
        return false;
    };

    AnimationItem.prototype.destroy = function (name) {
        if ((name && this.name != name) || !this.renderer) {
            return;
        }
        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger('destroy');
        this._cbs = null;
        this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;
        this.renderer = null;
    };

    AnimationItem.prototype.setCurrentRawFrameValue = function(value){
        this.currentRawFrame = value;
        this.gotoFrame();
    };

    AnimationItem.prototype.setSpeed = function (val) {
        this.playSpeed = val;
        this.updaFrameModifier();
    };

    AnimationItem.prototype.setDirection = function (val) {
        this.playDirection = val < 0 ? -1 : 1;
        this.updaFrameModifier();
    };

    AnimationItem.prototype.updaFrameModifier = function () {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
    };

    AnimationItem.prototype.getPath = function () {
        return this.path;
    };

    AnimationItem.prototype.getAssetsPath = function (assetData) {
        var path = '';
        if(assetData.e) {
            path = assetData.p;
        } else if(this.assetsPath){
            var imagePath = assetData.p;
            if(imagePath.indexOf('images/') !== -1){
                imagePath = imagePath.split('/')[1];
            }
            path = this.assetsPath + imagePath;
        } else {
            path = this.path;
            path += assetData.u ? assetData.u : '';
            path += assetData.p;
        }
        return path;
    };

    AnimationItem.prototype.getAssetData = function (id) {
        var i = 0, len = this.assets.length;
        while (i < len) {
            if(id == this.assets[i].id){
                return this.assets[i];
            }
            i += 1;
        }
    };

    AnimationItem.prototype.hide = function () {
        this.renderer.hide();
    };

    AnimationItem.prototype.show = function () {
        this.renderer.show();
    };

    AnimationItem.prototype.getDuration = function (isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
    };

    AnimationItem.prototype.trigger = function(name){
        if(this._cbs && this._cbs[name]){
            switch(name){
                case 'enterFrame':
                    this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                case 'loopComplete':
                    this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
                    break;
                case 'complete':
                    this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));
                    break;
                case 'segmentStart':
                    this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
                    break;
                case 'destroy':
                    this.triggerEvent(name,new BMDestroyEvent(name,this));
                    break;
                default:
                    this.triggerEvent(name);
            }
        }
        if(name === 'enterFrame' && this.onEnterFrame){
            this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));
        }
        if(name === 'loopComplete' && this.onLoopComplete){
            this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));
        }
        if(name === 'complete' && this.onComplete){
            this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));
        }
        if(name === 'segmentStart' && this.onSegmentStart){
            this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));
        }
        if(name === 'destroy' && this.onDestroy){
            this.onDestroy.call(this,new BMDestroyEvent(name,this));
        }
    };

    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {

        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent('error', error);

        if (this.onError) {
            this.onError.call(this, error);
        }
    };

    AnimationItem.prototype.triggerConfigError = function(nativeError) {

        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent('error', error);

        if (this.onError) {
            this.onError.call(this, error);
        }
    };
    var Expressions = (function(){
        var ob = {};
        ob.initExpressions = initExpressions;


        function initExpressions(animation){

        	var stackCount = 0;
        	var registers = [];

        	function pushExpression() {
    			stackCount += 1;
        	}

        	function popExpression() {
    			stackCount -= 1;
    			if (stackCount === 0) {
    				releaseInstances();
    			}
        	}

        	function registerExpressionProperty(expression) {
        		if (registers.indexOf(expression) === -1) {
    				registers.push(expression);
        		}
        	}

        	function releaseInstances() {
        		var i, len = registers.length;
        		for (i = 0; i < len; i += 1) {
    				registers[i].release();
        		}
        		registers.length = 0;
        	}

            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
            animation.renderer.globalData.pushExpression = pushExpression;
            animation.renderer.globalData.popExpression = popExpression;
            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }
       return ob;
    }());

    expressionsPlugin = Expressions;

    var ExpressionManager = (function(){
        var ob = {};
        var Math = BMMath;

        var easeInBez = BezierFactory.getBezierEasing(0.333,0,.833,.833, 'easeIn').get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167,0.167,.667,1, 'easeOut').get;
        var easeInOutBez = BezierFactory.getBezierEasing(.33,0,.667,1, 'easeInOut').get;

        function initiateExpression(elem,data,property){
            var val = data.x;
            var needsVelocity = /velocity(?![\w\d])/.test(val);
            var _needsRandom = val.indexOf('random') !== -1;
            var elemType = elem.data.ty;
            var transform,content,effect;
            var thisProperty = property;
            thisProperty.valueAtTime = thisProperty.getValueAtTime;
            Object.defineProperty(thisProperty, 'value', {
                get: function() {
                    return thisProperty.v
                }
            });
            elem.comp.frameDuration = 1/elem.comp.globalData.frameRate;
            elem.comp.displayStartTime = 0;
            var inPoint = elem.data.ip/elem.comp.globalData.frameRate;
            var outPoint = elem.data.op/elem.comp.globalData.frameRate;
            var width = elem.data.sw ? elem.data.sw : 0;
            var height = elem.data.sh ? elem.data.sh : 0;
            var name = elem.data.nm;
            var loopIn, loopOut, smooth;
            var toWorld,fromWorld,fromComp,toComp,anchorPoint, thisLayer, thisComp,mask,valueAtTime,velocityAtTime;
            var __expression_functions = [];
            if(data.xf) {
                var i, len = data.xf.length;
                for(i = 0; i < len; i += 1) {
                    __expression_functions[i] = eval('(function(){ return ' + data.xf[i] + '}())');
                }
            }

            var scoped_bm_rt;
            var expression_function = eval('[function _expression_function(){' + val+';scoped_bm_rt=$bm_rt}' + ']')[0];
            var numKeys = property.kf ? data.k.length : 0;

            var active = !this.data || this.data.hd !== true;

            var wiggle = function wiggle(freq,amp){
                var i,j, len = this.pv.length ? this.pv.length : 1;
                var addedAmps = createTypedArray('float32', len);
                freq = 5;
                var iterations = Math.floor(time*freq);
                i = 0;
                j = 0;
                while(i<iterations){
                    //var rnd = BMMath.random();
                    for(j=0;j<len;j+=1){
                        addedAmps[j] += -amp + amp*2*BMMath.random();
                        //addedAmps[j] += -amp + amp*2*rnd;
                    }
                    i += 1;
                }
                //var rnd2 = BMMath.random();
                var periods = time*freq;
                var perc = periods - Math.floor(periods);
                var arr = createTypedArray('float32', len);
                if(len>1){
                    for(j=0;j<len;j+=1){
                        arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*BMMath.random())*perc;
                        //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
                        //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
                    }
                    return arr;
                } else {
                    return this.pv + addedAmps[0] + (-amp + amp*2*BMMath.random())*perc;
                }
            }.bind(this);

            if(thisProperty.loopIn) {
                loopIn = thisProperty.loopIn.bind(thisProperty);
            }

            if(thisProperty.loopOut) {
                loopOut = thisProperty.loopOut.bind(thisProperty);
            }

            if(thisProperty.smooth) {
                smooth = thisProperty.smooth.bind(thisProperty);
            }

            if(this.getValueAtTime) {
                valueAtTime = this.getValueAtTime.bind(this);
            }

            if(this.getVelocityAtTime) {
                velocityAtTime = this.getVelocityAtTime.bind(this);
            }

            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

            function seedRandom(seed){
                BMMath.seedrandom(randSeed + seed);
            }

            var time, velocity, value, text, textIndex, textTotal, selectorValue;
            var index = elem.data.ind;
            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            var parent;
            var randSeed = Math.floor(Math.random()*1000000);
            var globalData = elem.globalData;
            function executeExpression(_value) {
                // globalData.pushExpression();
                value = _value;
                if (_needsRandom) {
                    seedRandom(randSeed);
                }
                if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
                    return value;
                }
                if(this.propType === 'textSelector'){
                    textIndex = this.textIndex;
                    textTotal = this.textTotal;
                    selectorValue = this.selectorValue;
                }
                if (!thisLayer) {
                    text = elem.layerInterface.text;
                    thisLayer = elem.layerInterface;
                    thisComp = elem.comp.compInterface;
                    toWorld = thisLayer.toWorld.bind(thisLayer);
                    fromWorld = thisLayer.fromWorld.bind(thisLayer);
                    fromComp = thisLayer.fromComp.bind(thisLayer);
                    toComp = thisLayer.toComp.bind(thisLayer);
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                }
                if (!transform) {
                    transform = elem.layerInterface("ADBE Transform Group");
                    if(transform) {
                        anchorPoint = transform.anchorPoint;
                        /*position = transform.position;
                        rotation = transform.rotation;
                        scale = transform.scale;*/
                    }
                }
                
                if (elemType === 4 && !content) {
                    content = thisLayer("ADBE Root Vectors Group");
                }
                if (!effect) {
                    effect = thisLayer(4);
                }
                hasParent = !!(elem.hierarchy && elem.hierarchy.length);
                if (hasParent && !parent) {
                    parent = elem.hierarchy[0].layerInterface;
                }
                time = this.comp.renderedFrame/this.comp.globalData.frameRate;
                if (needsVelocity) {
                    velocity = velocityAtTime(time);
                }
                expression_function();
                this.frameExpressionId = elem.globalData.frameId;

                //TODO: Check if it's possible to return on ShapeInterface the .v value
                if (scoped_bm_rt.propType === "shape") ;
                // globalData.popExpression();
                return scoped_bm_rt;
            }
            return executeExpression;
        }

        ob.initiateExpression = initiateExpression;
        return ob;
    }());
    var expressionHelpers = (function(){

        function searchExpressions(elem,data,prop){
            if(data.x){
                prop.k = true;
                prop.x = true;
                prop.initiateExpression = ExpressionManager.initiateExpression;
                prop.effectsSequence.push(prop.initiateExpression(elem,data,prop).bind(prop));
            }
        }

        function getValueAtTime(frameNum) {
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if(frameNum !== this._cachingAtTime.lastFrame) {
                this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
                this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
                this._cachingAtTime.lastFrame = frameNum;
            }
            return this._cachingAtTime.value;

        }

        function getSpeedAtTime(frameNum) {
            var delta = -0.01;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var speed = 0;
            if(v1.length){
                var i;
                for(i=0;i<v1.length;i+=1){
                    speed += Math.pow(v2[i] - v1[i], 2);
                }
                speed = Math.sqrt(speed) * 100;
            } else {
                speed = 0;
            }
            return speed;
        }

        function getVelocityAtTime(frameNum) {
            if(this.vel !== undefined){
                return this.vel;
            }
            var delta = -0.001;
            //frameNum += this.elem.data.st;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var velocity;
            if(v1.length){
                velocity = createTypedArray('float32', v1.length);
                var i;
                for(i=0;i<v1.length;i+=1){
                    //removing frameRate
                    //if needed, don't add it here
                    //velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
                    velocity[i] = (v2[i] - v1[i])/delta;
                }
            } else {
                velocity = (v2 - v1)/delta;
            }
            return velocity;
        }

        function getStaticValueAtTime() {
            return this.pv;
        }

        function setGroupProperty(propertyGroup){
            this.propertyGroup = propertyGroup;
        }

    	return {
    		searchExpressions: searchExpressions,
    		getSpeedAtTime: getSpeedAtTime,
    		getVelocityAtTime: getVelocityAtTime,
    		getValueAtTime: getValueAtTime,
    		getStaticValueAtTime: getStaticValueAtTime,
    		setGroupProperty: setGroupProperty,
    	}
    }());
    (function addPropertyDecorator() {

        function loopOut(type,duration,durationFlag){
            if(!this.k || !this.keyframes){
                return this.pv;
            }
            type = type ? type.toLowerCase() : '';
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var lastKeyFrame = keyframes[keyframes.length - 1].t;
            if(currentFrame<=lastKeyFrame){
                return this.pv;
            }else {
                var cycleDuration, firstKeyFrame;
                if(!durationFlag){
                    if(!duration || duration > keyframes.length - 1){
                        duration = keyframes.length - 1;
                    }
                    firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
                    cycleDuration = lastKeyFrame - firstKeyFrame;
                } else {
                    if(!duration){
                        cycleDuration = Math.max(0,lastKeyFrame - this.elem.data.ip);
                    } else {
                        cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate*duration);
                    }
                    firstKeyFrame = lastKeyFrame - cycleDuration;
                }
                var i, len, ret;
                if(type === 'pingpong') {
                    var iterations = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
                    if(iterations % 2 !== 0){
                        return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
                    }
                } else if(type === 'offset'){
                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                    var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                    var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
                    var repeats = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);
                    if(this.pv.length){
                        ret = new Array(initV.length);
                        len = ret.length;
                        for(i=0;i<len;i+=1){
                            ret[i] = (endV[i]-initV[i])*repeats + current[i];
                        }
                        return ret;
                    }
                    return (endV-initV)*repeats + current;
                } else if(type === 'continue'){
                    var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                    var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
                    if(this.pv.length){
                        ret = new Array(lastValue.length);
                        len = ret.length;
                        for(i=0;i<len;i+=1){
                            ret[i] = lastValue[i] + (lastValue[i]-nextLastValue[i])*((currentFrame - lastKeyFrame)/ this.comp.globalData.frameRate)/0.0005;
                        }
                        return ret;
                    }
                    return lastValue + (lastValue-nextLastValue)*(((currentFrame - lastKeyFrame))/0.001);
                }
                return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
            }
        }

        function loopIn(type,duration, durationFlag) {
            if(!this.k){
                return this.pv;
            }
            type = type ? type.toLowerCase() : '';
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var firstKeyFrame = keyframes[0].t;
            if(currentFrame>=firstKeyFrame){
                return this.pv;
            }else {
                var cycleDuration, lastKeyFrame;
                if(!durationFlag){
                    if(!duration || duration > keyframes.length - 1){
                        duration = keyframes.length - 1;
                    }
                    lastKeyFrame = keyframes[duration].t;
                    cycleDuration = lastKeyFrame - firstKeyFrame;
                } else {
                    if(!duration){
                        cycleDuration = Math.max(0,this.elem.data.op - firstKeyFrame);
                    } else {
                        cycleDuration = Math.abs(elem.comp.globalData.frameRate*duration);
                    }
                    lastKeyFrame = firstKeyFrame + cycleDuration;
                }
                var i, len, ret;
                if(type === 'pingpong') {
                    var iterations = Math.floor((firstKeyFrame - currentFrame)/cycleDuration);
                    if(iterations % 2 === 0){
                        return this.getValueAtTime((((firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
                    }
                } else if(type === 'offset'){
                    var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                    var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
                    var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);
                    var repeats = Math.floor((firstKeyFrame - currentFrame)/cycleDuration)+1;
                    if(this.pv.length){
                        ret = new Array(initV.length);
                        len = ret.length;
                        for(i=0;i<len;i+=1){
                            ret[i] = current[i]-(endV[i]-initV[i])*repeats;
                        }
                        return ret;
                    }
                    return current-(endV-initV)*repeats;
                } else if(type === 'continue'){
                    var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
                    var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
                    if(this.pv.length){
                        ret = new Array(firstValue.length);
                        len = ret.length;
                        for(i=0;i<len;i+=1){
                            ret[i] = firstValue[i] + (firstValue[i]-nextFirstValue[i])*(firstKeyFrame - currentFrame)/0.001;
                        }
                        return ret;
                    }
                    return firstValue + (firstValue-nextFirstValue)*(firstKeyFrame - currentFrame)/0.001;
                }
                return this.getValueAtTime(((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);
            }
        }

        function smooth(width, samples) {
            if (!this.k){
                return this.pv;
            }
            width = (width || 0.4) * 0.5;
            samples = Math.floor(samples || 5);
            if (samples <= 1) {
                return this.pv;
            }
            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
            var initFrame = currentTime - width;
            var endFrame = currentTime + width;
            var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
            var i = 0, j = 0;
            var value;
            if (this.pv.length) {
                value = createTypedArray('float32', this.pv.length);
            } else {
                value = 0;
            }
            var sampleValue;
            while (i < samples) {
                sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
                if(this.pv.length) {
                    for (j = 0; j < this.pv.length; j += 1) {
                        value[j] += sampleValue[j];
                    }
                } else {
                    value += sampleValue;
                }
                i += 1;
            }
            if(this.pv.length) {
                for (j = 0; j < this.pv.length; j += 1) {
                    value[j] /= samples;
                }
            } else {
                value /= samples;
            }
            return value;
        }

        function getTransformValueAtTime(time) {
            console.warn('Transform at time not supported');
        }

        function getTransformStaticValueAtTime(time) {

        }

        var getTransformProperty = TransformPropertyFactory.getTransformProperty;
        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {
            var prop = getTransformProperty(elem, data, container);
            if(prop.dynamicProperties.length) {
                prop.getValueAtTime = getTransformValueAtTime.bind(prop);
            } else {
                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            return prop;
        };

        var propertyGetProp = PropertyFactory.getProp;
        PropertyFactory.getProp = function(elem,data,type, mult, container){
            var prop = propertyGetProp(elem,data,type, mult, container);
            //prop.getVelocityAtTime = getVelocityAtTime;
            //prop.loopOut = loopOut;
            //prop.loopIn = loopIn;
            if(prop.kf){
                prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
            } else {
                prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            prop.loopOut = loopOut;
            prop.loopIn = loopIn;
            prop.smooth = smooth;
            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
            prop.numKeys = data.a === 1 ? data.k.length : 0;
            prop.propertyIndex = data.ix;
            var value = 0;
            if(type !== 0) {
                value = createTypedArray('float32', data.a === 1 ?  data.k[0].s.length : data.k.length);
            }
            prop._cachingAtTime = {
                lastFrame: initialDefaultFrame,
                lastIndex: 0,
                value: value
            };
            expressionHelpers.searchExpressions(elem,data,prop);
            if(prop.k){
                container.addDynamicProperty(prop);
            }

            return prop;
        };

        function getShapeValueAtTime(frameNum) {
            //For now this caching object is created only when needed instead of creating it when the shape is initialized.
            if (!this._cachingAtTime) {
                this._cachingAtTime = {
                    shapeValue: shape_pool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                };
            }
            
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if(frameNum !== this._cachingAtTime.lastTime) {
                this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
                this._cachingAtTime.lastTime = frameNum;
                this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
            }
            return this._cachingAtTime.shapeValue;
        }

        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

        function ShapeExpressions(){}
        ShapeExpressions.prototype = {
            vertices: function(prop, time){
                if (this.k) {
                    this.getValue();
                }
                var shapePath = this.v;
                if(time !== undefined) {
                    shapePath = this.getValueAtTime(time, 0);
                }
                var i, len = shapePath._length;
                var vertices = shapePath[prop];
                var points = shapePath.v;
                var arr = createSizedArray(len);
                for(i = 0; i < len; i += 1) {
                    if(prop === 'i' || prop === 'o') {
                        arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
                    } else {
                        arr[i] = [vertices[i][0], vertices[i][1]];
                    }
                    
                }
                return arr;
            },
            points: function(time){
                return this.vertices('v', time);
            },
            inTangents: function(time){
                return this.vertices('i', time);
            },
            outTangents: function(time){
                return this.vertices('o', time);
            },
            isClosed: function(){
                return this.v.c;
            },
            pointOnPath: function(perc, time){
                var shapePath = this.v;
                if(time !== undefined) {
                    shapePath = this.getValueAtTime(time, 0);
                }
                if(!this._segmentsLength) {
                    this._segmentsLength = bez.getSegmentsLength(shapePath);
                }

                var segmentsLength = this._segmentsLength;
                var lengths = segmentsLength.lengths;
                var lengthPos = segmentsLength.totalLength * perc;
                var i = 0, len = lengths.length;
                var accumulatedLength = 0, pt;
                while(i < len) {
                    if(accumulatedLength + lengths[i].addedLength > lengthPos) {
                        var initIndex = i;
                        var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
                        var segmentPerc = (lengthPos - accumulatedLength)/lengths[i].addedLength;
                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                        break;
                    } else {
                        accumulatedLength += lengths[i].addedLength;
                    }
                    i += 1;
                }
                if(!pt){
                    pt = shapePath.c ? [shapePath.v[0][0],shapePath.v[0][1]]:[shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1]];
                }
                return pt;
            },
            vectorOnPath: function(perc, time, vectorType){
                //perc doesn't use triple equality because it can be a Number object as well as a primitive.
                perc = perc == 1 ? this.v.c ? 0 : 0.999 : perc;
                var pt1 = this.pointOnPath(perc, time);
                var pt2 = this.pointOnPath(perc + 0.001, time);
                var xLength = pt2[0] - pt1[0];
                var yLength = pt2[1] - pt1[1];
                var magnitude = Math.sqrt(Math.pow(xLength,2) + Math.pow(yLength,2));
                if (magnitude === 0) {
                    return [0,0];
                }
                var unitVector = vectorType === 'tangent' ? [xLength/magnitude, yLength/magnitude] : [-yLength/magnitude, xLength/magnitude];
                return unitVector;
            },
            tangentOnPath: function(perc, time){
                return this.vectorOnPath(perc, time, 'tangent');
            },
            normalOnPath: function(perc, time){
                return this.vectorOnPath(perc, time, 'normal');
            },
            setGroupProperty: expressionHelpers.setGroupProperty,
            getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
        ShapePropertyFactory.getShapeProp = function(elem,data,type, arr, trims){
            var prop = propertyGetShapeProp(elem,data,type, arr, trims);
            prop.propertyIndex = data.ix;
            prop.lock = false;
            if(type === 3){
                expressionHelpers.searchExpressions(elem,data.pt,prop);
            } else if(type === 4){
                expressionHelpers.searchExpressions(elem,data.ks,prop);
            }
            if(prop.k){
                elem.addDynamicProperty(prop);
            }
            return prop;
        };
    }());
    (function addDecorator() {

        function searchExpressions(){
            if(this.data.d.x){
                this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem,this.data.d,this);
                this.addEffect(this.getExpressionValue.bind(this));
                return true;
            }
        }

        TextProperty.prototype.getExpressionValue = function(currentValue, text) {
            var newValue = this.calculateExpression(text);
            if(currentValue.t !== newValue) {
                var newData = {};
                this.copyData(newData, currentValue);
                newData.t = newValue.toString();
                newData.__complete = false;
                return newData;
            }
            return currentValue;
        };

        TextProperty.prototype.searchProperty = function(){

            var isKeyframed = this.searchKeyframes();
            var hasExpressions = this.searchExpressions();
            this.kf = isKeyframed || hasExpressions;
            return this.kf;
        };

        TextProperty.prototype.searchExpressions = searchExpressions;
        
    }());
    var ShapePathInterface = (

    	function() {

    		return function pathInterfaceFactory(shape,view,propertyGroup){
    		    var prop = view.sh;

    		    function interfaceFunction(val){
    		        if(val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2){
    		            return interfaceFunction.path;
    		        }
    		    }

    		    var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
    		    prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
    		    Object.defineProperties(interfaceFunction, {
    		        'path': {
    		            get: function(){
    		                if(prop.k){
    		                    prop.getValue();
    		                }
    		                return prop;
    		            }
    		        },
    		        'shape': {
    		            get: function(){
    		                if(prop.k){
    		                    prop.getValue();
    		                }
    		                return prop;
    		            }
    		        },
    		        '_name': { value: shape.nm },
    		        'ix': { value: shape.ix },
    		        'propertyIndex': { value: shape.ix },
    		        'mn': { value: shape.mn },
    		        'propertyGroup': {value: propertyGroup},
    		    });
    		    return interfaceFunction;
    		}
    	}()
    );
    var propertyGroupFactory = (function() {
    	return function(interfaceFunction, parentPropertyGroup) {
    		return function(val) {
    			val = val === undefined ? 1 : val;
    			if(val <= 0){
    			    return interfaceFunction;
    			} else {
    			    return parentPropertyGroup(val-1);
    			}
    		}
    	}
    }());
    var PropertyInterface = (function() {
    	return function(propertyName, propertyGroup) {

    		var interfaceFunction = {
    			_name: propertyName
    		};

    		function _propertyGroup(val){
    		    val = val === undefined ? 1 : val;
    		    if(val <= 0){
    		        return interfaceFunction;
    		    } else {
    		        return propertyGroup(--val);
    		    }
    		}

    		return _propertyGroup;
    	}
    }());
    var ShapeExpressionInterface = (function(){

        function iterateElements(shapes,view, propertyGroup){
            var arr = [];
            var i, len = shapes ? shapes.length : 0;
            for(i=0;i<len;i+=1){
                if(shapes[i].ty == 'gr'){
                    arr.push(groupInterfaceFactory(shapes[i],view[i],propertyGroup));
                }else if(shapes[i].ty == 'fl'){
                    arr.push(fillInterfaceFactory(shapes[i],view[i],propertyGroup));
                }else if(shapes[i].ty == 'st'){
                    arr.push(strokeInterfaceFactory(shapes[i],view[i],propertyGroup));
                }else if(shapes[i].ty == 'tm'){
                    arr.push(trimInterfaceFactory(shapes[i],view[i],propertyGroup));
                }else if(shapes[i].ty == 'tr');else if(shapes[i].ty == 'el'){
                    arr.push(ellipseInterfaceFactory(shapes[i],view[i],propertyGroup));
                }else if(shapes[i].ty == 'sr'){
                    arr.push(starInterfaceFactory(shapes[i],view[i],propertyGroup));
                } else if(shapes[i].ty == 'sh'){
                    arr.push(ShapePathInterface(shapes[i],view[i],propertyGroup));
                } else if(shapes[i].ty == 'rc'){
                    arr.push(rectInterfaceFactory(shapes[i],view[i],propertyGroup));
                } else if(shapes[i].ty == 'rd'){
                    arr.push(roundedInterfaceFactory(shapes[i],view[i],propertyGroup));
                } else if(shapes[i].ty == 'rp'){
                    arr.push(repeaterInterfaceFactory(shapes[i],view[i],propertyGroup));
                }
            }
            return arr;
        }

        function contentsInterfaceFactory(shape,view, propertyGroup){
           var interfaces;
           var interfaceFunction = function _interfaceFunction(value){
               var i = 0, len = interfaces.length;
                while(i<len){
                    if(interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value){
                       return interfaces[i];
                    }
                    i+=1;
                }
                if(typeof value === 'number'){
                   return interfaces[value-1];
                }
           };

           interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
           interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
           interfaceFunction.numProperties = interfaces.length;
           var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);
           interfaceFunction.transform = transformInterface;
           interfaceFunction.propertyIndex = shape.cix;
           interfaceFunction._name = shape.nm;

           return interfaceFunction;
       }

        function groupInterfaceFactory(shape,view, propertyGroup){
            var interfaceFunction = function _interfaceFunction(value){
                switch(value){
                    case 'ADBE Vectors Group':
                    case 'Contents':
                    case 2:
                        return interfaceFunction.content;
                    //Not necessary for now. Keeping them here in case a new case appears
                    //case 'ADBE Vector Transform Group':
                    //case 3:
                    default:
                        return interfaceFunction.transform;
                }
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var content = contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);
            interfaceFunction.content = content;
            interfaceFunction.transform = transformInterface;
            Object.defineProperty(interfaceFunction, '_name', {
                get: function(){
                    return shape.nm;
                }
            });
            //interfaceFunction.content = interfaceFunction;
            interfaceFunction.numProperties = shape.np;
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.nm = shape.nm;
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function fillInterfaceFactory(shape,view,propertyGroup){
            function interfaceFunction(val){
                if(val === 'Color' || val === 'color'){
                    return interfaceFunction.color;
                } else if(val === 'Opacity' || val === 'opacity'){
                    return interfaceFunction.opacity;
                }
            }
            Object.defineProperties(interfaceFunction, {
                'color': {
                    get: ExpressionPropertyInterface(view.c)
                },
                'opacity': {
                    get: ExpressionPropertyInterface(view.o)
                },
                '_name': { value: shape.nm },
                'mn': { value: shape.mn }
            });

            view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
            view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
            return interfaceFunction;
        }

        function strokeInterfaceFactory(shape,view,propertyGroup){
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
            function addPropertyToDashOb(i) {
                Object.defineProperty(dashOb, shape.d[i].nm, {
                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                });
            }
            var i, len = shape.d ? shape.d.length : 0;
            var dashOb = {};
            for (i = 0; i < len; i += 1) {
                addPropertyToDashOb(i);
                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
            }

            function interfaceFunction(val){
                if(val === 'Color' || val === 'color'){
                    return interfaceFunction.color;
                } else if(val === 'Opacity' || val === 'opacity'){
                    return interfaceFunction.opacity;
                } else if(val === 'Stroke Width' || val === 'stroke width'){
                    return interfaceFunction.strokeWidth;
                }
            }
            Object.defineProperties(interfaceFunction, {
                'color': {
                    get: ExpressionPropertyInterface(view.c)
                },
                'opacity': {
                    get: ExpressionPropertyInterface(view.o)
                },
                'strokeWidth': {
                    get: ExpressionPropertyInterface(view.w)
                },
                'dash': {
                    get: function() {
                        return dashOb;
                    }
                },
                '_name': { value: shape.nm },
                'mn': { value: shape.mn }
            });

            view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
            view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
            view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
            return interfaceFunction;
        }

        function trimInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(val){
                if(val === shape.e.ix || val === 'End' || val === 'end'){
                    return interfaceFunction.end;
                }
                if(val === shape.s.ix){
                    return interfaceFunction.start;
                }
                if(val === shape.o.ix){
                    return interfaceFunction.offset;
                }
            }

            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;

            view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
            view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
            view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.propertyGroup = propertyGroup;

            Object.defineProperties(interfaceFunction, {
                'start': {
                    get: ExpressionPropertyInterface(view.s)
                },
                'end': {
                    get: ExpressionPropertyInterface(view.e)
                },
                'offset': {
                    get: ExpressionPropertyInterface(view.o)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function transformInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(value){
                if(shape.a.ix === value || value === 'Anchor Point'){
                    return interfaceFunction.anchorPoint;
                }
                if(shape.o.ix === value || value === 'Opacity'){
                    return interfaceFunction.opacity;
                }
                if(shape.p.ix === value || value === 'Position'){
                    return interfaceFunction.position;
                }
                if(shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation'){
                    return interfaceFunction.rotation;
                }
                if(shape.s.ix === value || value === 'Scale'){
                    return interfaceFunction.scale;
                }
                if(shape.sk && shape.sk.ix === value || value === 'Skew'){
                    return interfaceFunction.skew;
                }
                if(shape.sa && shape.sa.ix === value || value === 'Skew Axis'){
                    return interfaceFunction.skewAxis;
                }
            }
            
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
            view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
            view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
            view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
            view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
            if(view.transform.mProps.sk){
                view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
                view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
            }
            view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                'opacity': {
                    get: ExpressionPropertyInterface(view.transform.mProps.o)
                },
                'position': {
                    get: ExpressionPropertyInterface(view.transform.mProps.p)
                },
                'anchorPoint': {
                    get: ExpressionPropertyInterface(view.transform.mProps.a)
                },
                'scale': {
                    get: ExpressionPropertyInterface(view.transform.mProps.s)
                },
                'rotation': {
                    get: ExpressionPropertyInterface(view.transform.mProps.r)
                },
                'skew': {
                    get: ExpressionPropertyInterface(view.transform.mProps.sk)
                },
                'skewAxis': {
                    get: ExpressionPropertyInterface(view.transform.mProps.sa)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.ty = 'tr';
            interfaceFunction.mn = shape.mn;
            interfaceFunction.propertyGroup = propertyGroup;
            return interfaceFunction;
        }

        function ellipseInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(value){
                if(shape.p.ix === value){
                    return interfaceFunction.position;
                }
                if(shape.s.ix === value){
                    return interfaceFunction.size;
                }
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
            prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

            Object.defineProperties(interfaceFunction, {
                'size': {
                    get: ExpressionPropertyInterface(prop.s)
                },
                'position': {
                    get: ExpressionPropertyInterface(prop.p)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function starInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(value){
                if(shape.p.ix === value){
                    return interfaceFunction.position;
                }
                if(shape.r.ix === value){
                    return interfaceFunction.rotation;
                }
                if(shape.pt.ix === value){
                    return interfaceFunction.points;
                }
                if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){
                    return interfaceFunction.outerRadius;
                }
                if(shape.os.ix === value){
                    return interfaceFunction.outerRoundness;
                }
                if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){
                    return interfaceFunction.innerRadius;
                }
                if(shape.is && shape.is.ix === value){
                    return interfaceFunction.innerRoundness;
                }

            }

            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
            prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
            prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
            if(shape.ir){
                prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
                prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
            }

            Object.defineProperties(interfaceFunction, {
                'position': {
                    get: ExpressionPropertyInterface(prop.p)
                },
                'rotation': {
                    get: ExpressionPropertyInterface(prop.r)
                },
                'points': {
                    get: ExpressionPropertyInterface(prop.pt)
                },
                'outerRadius': {
                    get: ExpressionPropertyInterface(prop.or)
                },
                'outerRoundness': {
                    get: ExpressionPropertyInterface(prop.os)
                },
                'innerRadius': {
                    get: ExpressionPropertyInterface(prop.ir)
                },
                'innerRoundness': {
                    get: ExpressionPropertyInterface(prop.is)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function rectInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(value){
                if(shape.p.ix === value){
                    return interfaceFunction.position;
                }
                if(shape.r.ix === value){
                    return interfaceFunction.roundness;
                }
                if(shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size'){
                    return interfaceFunction.size;
                }

            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
            prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

            Object.defineProperties(interfaceFunction, {
                'position': {
                    get: ExpressionPropertyInterface(prop.p)
                },
                'roundness': {
                    get: ExpressionPropertyInterface(prop.r)
                },
                'size': {
                    get: ExpressionPropertyInterface(prop.s)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function roundedInterfaceFactory(shape,view,propertyGroup){
           
            function interfaceFunction(value){
                if(shape.r.ix === value || 'Round Corners 1' === value){
                    return interfaceFunction.radius;
                }
            }

            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

            Object.defineProperties(interfaceFunction, {
                'radius': {
                    get: ExpressionPropertyInterface(prop.rd)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        function repeaterInterfaceFactory(shape,view,propertyGroup){

            function interfaceFunction(value){
                if(shape.c.ix === value || 'Copies' === value){
                    return interfaceFunction.copies;
                } else if(shape.o.ix === value || 'Offset' === value){
                    return interfaceFunction.offset;
                }
            }

            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
            prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
            Object.defineProperties(interfaceFunction, {
                'copies': {
                    get: ExpressionPropertyInterface(prop.c)
                },
                'offset': {
                    get: ExpressionPropertyInterface(prop.o)
                },
                '_name': { value: shape.nm }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
        }

        return function(shapes,view,propertyGroup) {
            var interfaces;
            function _interfaceFunction(value){
                if(typeof value === 'number'){
                    value = value === undefined ? 1 : value;
                    if (value === 0) {
                        return propertyGroup
                    } else {
                        return interfaces[value-1];
                    }
                } else {
                    var i = 0, len = interfaces.length;
                    while(i<len){
                        if(interfaces[i]._name === value){
                            return interfaces[i];
                        }
                        i+=1;
                    }
                }
            }
            _interfaceFunction.propertyGroup = propertyGroup;
            interfaces = iterateElements(shapes, view, _interfaceFunction);
            _interfaceFunction.numProperties = interfaces.length;
            return _interfaceFunction;
        };
    }());

    var TextExpressionInterface = (function(){
    	return function(elem){
            var _prevValue, _sourceText;
            function _thisLayerFunction(){
            }
            Object.defineProperty(_thisLayerFunction, "sourceText", {
                get: function(){
                    elem.textProperty.getValue();
                    var stringValue = elem.textProperty.currentData.t;
                    if(stringValue !== _prevValue) {
                        elem.textProperty.currentData.t = _prevValue;
                        _sourceText = new String(stringValue);
                        //If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
                        _sourceText.value = stringValue ? stringValue : new String(stringValue);
                    }
                    return _sourceText;
                }
            });
            return _thisLayerFunction;
        };
    }());
    var LayerExpressionInterface = (function (){
        function toWorld(arr, time){
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            var transformMat;
            if(time) {
                //Todo implement value at time on transform properties
                //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
                transformMat = this._elem.finalTransform.mProp;
            } else {
                transformMat = this._elem.finalTransform.mProp;
            }
            transformMat.applyToMatrix(toWorldMat);
            if(this._elem.hierarchy && this._elem.hierarchy.length){
                var i, len = this._elem.hierarchy.length;
                for(i=0;i<len;i+=1){
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                }
                return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
            }
            return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);
        }
        function fromWorld(arr, time){
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            var transformMat;
            if(time) {
                //Todo implement value at time on transform properties
                //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);
                transformMat = this._elem.finalTransform.mProp;
            } else {
                transformMat = this._elem.finalTransform.mProp;
            }
            transformMat.applyToMatrix(toWorldMat);
            if(this._elem.hierarchy && this._elem.hierarchy.length){
                var i, len = this._elem.hierarchy.length;
                for(i=0;i<len;i+=1){
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                }
                return toWorldMat.inversePoint(arr);
            }
            return toWorldMat.inversePoint(arr);
        }
        function fromComp(arr){
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
            if(this._elem.hierarchy && this._elem.hierarchy.length){
                var i, len = this._elem.hierarchy.length;
                for(i=0;i<len;i+=1){
                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
                }
                return toWorldMat.inversePoint(arr);
            }
            return toWorldMat.inversePoint(arr);
        }

        function sampleImage() {
            return [1,1,1,1];
        }


        return function(elem){

            var transformInterface;

            function _registerMaskInterface(maskManager){
                _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
            }
            function _registerEffectsInterface(effects){
                _thisLayerFunction.effect = effects;
            }

            function _thisLayerFunction(name){
                switch(name){
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return _thisLayerFunction.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return transformInterface;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return _thisLayerFunction.effect;
                }
            }
            _thisLayerFunction.toWorld = toWorld;
            _thisLayerFunction.fromWorld = fromWorld;
            _thisLayerFunction.toComp = toWorld;
            _thisLayerFunction.fromComp = fromComp;
            _thisLayerFunction.sampleImage = sampleImage;
            _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
            _thisLayerFunction._elem = elem;
            transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
            var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
            Object.defineProperties(_thisLayerFunction,{
                hasParent: {
                    get: function(){
                        return elem.hierarchy.length;
                    }
                },
                parent: {
                    get: function(){
                        return elem.hierarchy[0].layerInterface;
                    }
                },
                rotation: getDescriptor(transformInterface, 'rotation'),
                scale: getDescriptor(transformInterface, 'scale'),
                position: getDescriptor(transformInterface, 'position'),
                opacity: getDescriptor(transformInterface, 'opacity'),
                anchorPoint: anchorPointDescriptor,
                anchor_point: anchorPointDescriptor,
                transform: {
                    get: function () {
                        return transformInterface;
                    }
                },
                active: {
                    get: function(){
                        return elem.isInRange;
                    }
                }
            });

            _thisLayerFunction.startTime = elem.data.st;
            _thisLayerFunction.index = elem.data.ind;
            _thisLayerFunction.source = elem.data.refId;
            _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
            _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
            _thisLayerFunction.inPoint = elem.data.ip/elem.comp.globalData.frameRate;
            _thisLayerFunction.outPoint = elem.data.op/elem.comp.globalData.frameRate;
            _thisLayerFunction._name = elem.data.nm;

            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
            return _thisLayerFunction;
        };
    }());

    var CompExpressionInterface = (function () {
        return function(comp) {
            function _thisLayerFunction(name) {
                var i = 0, len = comp.layers.length;
                while ( i < len) {
                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
                        return comp.elements[i].layerInterface;
                    }
                    i += 1;
                }
                return null;
                //return {active:false};
            }
            Object.defineProperty(_thisLayerFunction, "_name", { value: comp.data.nm });
            _thisLayerFunction.layer = _thisLayerFunction;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
            _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
            _thisLayerFunction.displayStartTime = 0;
            _thisLayerFunction.numLayers = comp.layers.length;
            return _thisLayerFunction;
        };
    }());
    var TransformExpressionInterface = (function (){
        return function(transform){
            function _thisFunction(name){
                switch(name){
                    case "scale":
                    case "Scale":
                    case "ADBE Scale":
                    case 6:
                        return _thisFunction.scale;
                    case "rotation":
                    case "Rotation":
                    case "ADBE Rotation":
                    case "ADBE Rotate Z":
                    case 10:
                        return _thisFunction.rotation;
                    case "ADBE Rotate X":
                        return _thisFunction.xRotation;
                    case "ADBE Rotate Y":
                        return _thisFunction.yRotation;
                    case "position":
                    case "Position":
                    case "ADBE Position":
                    case 2:
                        return _thisFunction.position;
                    case 'ADBE Position_0':
                        return _thisFunction.xPosition;
                    case 'ADBE Position_1':
                        return _thisFunction.yPosition;
                    case 'ADBE Position_2':
                        return _thisFunction.zPosition;
                    case "anchorPoint":
                    case "AnchorPoint":
                    case "Anchor Point":
                    case "ADBE AnchorPoint":
                    case 1:
                        return _thisFunction.anchorPoint;
                    case "opacity":
                    case "Opacity":
                    case 11:
                        return _thisFunction.opacity;
                }
            }

            Object.defineProperty(_thisFunction, "rotation", {
                get: ExpressionPropertyInterface(transform.r || transform.rz)
            });

            Object.defineProperty(_thisFunction, "zRotation", {
                get: ExpressionPropertyInterface(transform.rz || transform.r)
            });

            Object.defineProperty(_thisFunction, "xRotation", {
                get: ExpressionPropertyInterface(transform.rx)
            });

            Object.defineProperty(_thisFunction, "yRotation", {
                get: ExpressionPropertyInterface(transform.ry)
            });
            Object.defineProperty(_thisFunction, "scale", {
                get: ExpressionPropertyInterface(transform.s)
            });

            if(transform.p) {
                var _transformFactory = ExpressionPropertyInterface(transform.p);
            } else {
                var _px = ExpressionPropertyInterface(transform.px);
                var _py = ExpressionPropertyInterface(transform.py);
                var _pz;
                if (transform.pz) {
                    _pz = ExpressionPropertyInterface(transform.pz);
                }
            }
            Object.defineProperty(_thisFunction, "position", {
                get: function () {
                    if(transform.p) {
                        return _transformFactory();
                    } else {
                        return [
                            _px(),
                            _py(),
                            _pz ? _pz() : 0];
                    }
                }
            });

            Object.defineProperty(_thisFunction, "xPosition", {
                get: ExpressionPropertyInterface(transform.px)
            });

            Object.defineProperty(_thisFunction, "yPosition", {
                get: ExpressionPropertyInterface(transform.py)
            });

            Object.defineProperty(_thisFunction, "zPosition", {
                get: ExpressionPropertyInterface(transform.pz)
            });

            Object.defineProperty(_thisFunction, "anchorPoint", {
                get: ExpressionPropertyInterface(transform.a)
            });

            Object.defineProperty(_thisFunction, "opacity", {
                get: ExpressionPropertyInterface(transform.o)
            });

            Object.defineProperty(_thisFunction, "skew", {
                get: ExpressionPropertyInterface(transform.sk)
            });

            Object.defineProperty(_thisFunction, "skewAxis", {
                get: ExpressionPropertyInterface(transform.sa)
            });

            Object.defineProperty(_thisFunction, "orientation", {
                get: ExpressionPropertyInterface(transform.or)
            });

            return _thisFunction;
        };
    }());
    var ProjectInterface = (function (){

        function registerComposition(comp){
            this.compositions.push(comp);
        }

        return function(){
            function _thisProjectFunction(name){
                var i = 0, len = this.compositions.length;
                while(i<len){
                    if(this.compositions[i].data && this.compositions[i].data.nm === name){
                        if(this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                            this.compositions[i].prepareFrame(this.currentFrame);
                        }
                        return this.compositions[i].compInterface;
                    }
                    i+=1;
                }
            }

            _thisProjectFunction.compositions = [];
            _thisProjectFunction.currentFrame = 0;

            _thisProjectFunction.registerComposition = registerComposition;



            return _thisProjectFunction;
        };
    }());
    var EffectsExpressionInterface = (function (){
        var ob = {
            createEffectsInterface: createEffectsInterface
        };

        function createEffectsInterface(elem, propertyGroup){
            if(elem.effectsManager){

                var effectElements = [];
                var effectsData = elem.data.ef;
                var i, len = elem.effectsManager.effectElements.length;
                for(i=0;i<len;i+=1){
                    effectElements.push(createGroupInterface(effectsData[i],elem.effectsManager.effectElements[i],propertyGroup,elem));
                }

                var effects = elem.data.ef || [];
                var groupInterface = function(name){
                    i = 0, len = effects.length;
                    while(i<len) {
                        if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
                            return effectElements[i];
                        }
                        i += 1;
                    }
                };
                Object.defineProperty(groupInterface, 'numProperties', {
                    get: function(){
                        return effects.length;
                    }
                });
                return groupInterface
            }
        }

        function createGroupInterface(data,elements, propertyGroup, elem){

            function groupInterface(name){
                var effects = data.ef, i = 0, len = effects.length;
                while(i<len) {
                    if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){
                        if(effects[i].ty === 5){
                            return effectElements[i];
                        } else {
                            return effectElements[i]();
                        }
                    }
                    i += 1;
                }
                return effectElements[0]();
            }        var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

            var effectElements = [];
            var i, len = data.ef.length;
            for(i=0;i<len;i+=1){
                if(data.ef[i].ty === 5){
                    effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],elements.effectElements[i].propertyGroup, elem));
                } else {
                    effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty, elem, _propertyGroup));
                }
            }

            if(data.mn === 'ADBE Color Control'){
                Object.defineProperty(groupInterface, 'color', {
                    get: function(){
                        return effectElements[0]();
                    }
                });
            }
            Object.defineProperties(groupInterface, {
                numProperties: {
                    get: function(){
                        return data.np;
                    }
                },
                _name: { value: data.nm },
                propertyGroup: {value: _propertyGroup},
            });
            groupInterface.active = groupInterface.enabled = data.en !== 0;
            return groupInterface;
        }

        function createValueInterface(element, type, elem, propertyGroup){
            var expressionProperty = ExpressionPropertyInterface(element.p);
            function interfaceFunction(){
                if(type === 10){
                    return elem.comp.compInterface(element.p.v);
                }
                return expressionProperty();
            }

            if(element.p.setGroupProperty) {
                element.p.setGroupProperty(PropertyInterface('', propertyGroup));
            }

            return interfaceFunction;
        }

        return ob;

    }());
    var MaskManagerInterface = (function(){

    	function MaskInterface(mask, data){
    		this._mask = mask;
    		this._data = data;
    	}
    	Object.defineProperty(MaskInterface.prototype, 'maskPath', {
            get: function(){
                if(this._mask.prop.k){
                    this._mask.prop.getValue();
                }
                return this._mask.prop;
            }
        });
    	Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
            get: function(){
                if(this._mask.op.k){
                    this._mask.op.getValue();
                }
                return this._mask.op.v * 100;
            }
        });

    	var MaskManager = function(maskManager, elem){
    		var _masksInterfaces = createSizedArray(maskManager.viewData.length);
    		var i, len = maskManager.viewData.length;
    		for(i = 0; i < len; i += 1) {
    			_masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
    		}

    		var maskFunction = function(name){
    			i = 0;
    		    while(i<len){
    		        if(maskManager.masksProperties[i].nm === name){
    		            return _masksInterfaces[i];
    		        }
    		        i += 1;
    		    }
    		};
    		return maskFunction;
    	};
    	return MaskManager;
    }());

    var ExpressionPropertyInterface = (function() {

        var defaultUnidimensionalValue = {pv:0, v:0, mult: 1};
        var defaultMultidimensionalValue = {pv:[0,0,0], v:[0,0,0], mult: 1};

        function completeProperty(expressionValue, property, type) {
            Object.defineProperty(expressionValue, 'velocity', {
                get: function(){
                    return property.getVelocityAtTime(property.comp.currentFrame);
                }
            });
            expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
            expressionValue.key = function(pos) {
                if (!expressionValue.numKeys) {
                    return 0;
                } else {
                    var value = '';
                    if ('s' in property.keyframes[pos-1]) {
                        value = property.keyframes[pos-1].s;
                    } else if ('e' in property.keyframes[pos-2]) {
                        value = property.keyframes[pos-2].e;
                    } else {
                        value = property.keyframes[pos-2].s;
                    }
                    var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value);
                    valueProp.time = property.keyframes[pos-1].t / property.elem.comp.globalData.frameRate;
                    return valueProp;
                }
            };
            expressionValue.valueAtTime = property.getValueAtTime;
            expressionValue.speedAtTime = property.getSpeedAtTime;
            expressionValue.velocityAtTime = property.getVelocityAtTime;
            expressionValue.propertyGroup = property.propertyGroup;
        }

        function UnidimensionalPropertyInterface(property) {
            if(!property || !('pv' in property)) {
                property = defaultUnidimensionalValue;
            }
            var mult = 1 / property.mult;
            var val = property.pv * mult;
            var expressionValue = new Number(val);
            expressionValue.value = val;
            completeProperty(expressionValue, property, 'unidimensional');

            return function() {
                if (property.k) {
                    property.getValue();
                }
                val = property.v * mult;
                if(expressionValue.value !== val) {
                    expressionValue = new Number(val);
                    expressionValue.value = val;
                    completeProperty(expressionValue, property, 'unidimensional');
                }
                return expressionValue;
            }
        }

        function MultidimensionalPropertyInterface(property) {
            if(!property || !('pv' in property)) {
                property = defaultMultidimensionalValue;
            }
            var mult = 1 / property.mult;
            var len = property.pv.length;
            var expressionValue = createTypedArray('float32', len);
            var arrValue = createTypedArray('float32', len);
            expressionValue.value = arrValue;
            completeProperty(expressionValue, property, 'multidimensional');

            return function() {
                if (property.k) {
                    property.getValue();
                }
                for (var i = 0; i < len; i += 1) {
                    expressionValue[i] = arrValue[i] = property.v[i] * mult;
                }
                return expressionValue;
            }
        }

        //TODO: try to avoid using this getter
        function defaultGetter() {
            return defaultUnidimensionalValue;
        }
        
        return function(property) {
            if(!property) {
                return defaultGetter;
            } else if (property.propType === 'unidimensional') {
                return UnidimensionalPropertyInterface(property);
            } else {
                return MultidimensionalPropertyInterface(property);
            }
        }
    }());

    (function(){

        var TextExpressionSelectorProp = (function(){

            function getValueProxy(index,total){
                this.textIndex = index+1;
                this.textTotal = total;
                this.v = this.getValue() * this.mult;
                return this.v;
            }

            return function TextExpressionSelectorProp(elem,data){
                this.pv = 1;
                this.comp = elem.comp;
                this.elem = elem;
                this.mult = 0.01;
                this.propType = 'textSelector';
                this.textTotal = data.totalChars;
                this.selectorValue = 100;
                this.lastValue = [1,1,1];
                this.k = true;
                this.x = true;
                this.getValue = ExpressionManager.initiateExpression.bind(this)(elem,data,this);
                this.getMult = getValueProxy;
                this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
                if(this.kf){
                    this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
                } else {
                    this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
                }
                this.setGroupProperty = expressionHelpers.setGroupProperty;
            };
        }());

    	var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
    	TextSelectorProp.getTextSelectorProp = function(elem, data,arr){
    	    if(data.t === 1){
    	        return new TextExpressionSelectorProp(elem, data,arr);
    	    } else {
    	        return propertyGetTextProp(elem,data,arr);
    	    }
    	};
    }());
    function SliderEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
    }
    function AngleEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
    }
    function ColorEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,1,0,container);
    }
    function PointEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,1,0,container);
    }
    function LayerIndexEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
    }
    function MaskIndexEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
    }
    function CheckboxEffect(data,elem, container){
        this.p = PropertyFactory.getProp(elem,data.v,0,0,container);
    }
    function NoValueEffect(){
        this.p = {};
    }
    function EffectsManager(){}
    function EffectsManager(data,element){
        var effects = data.ef || [];
        this.effectElements = [];
        var i,len = effects.length;
        var effectItem;
        for(i=0;i<len;i++) {
            effectItem = new GroupEffect(effects[i],element);
            this.effectElements.push(effectItem);
        }
    }

    function GroupEffect(data,element){
        this.init(data,element);
    }

    extendPrototype([DynamicPropertyContainer], GroupEffect);

    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

    GroupEffect.prototype.init = function(data,element){
        this.data = data;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i, len = this.data.ef.length;
        var eff, effects = this.data.ef;
        for(i=0;i<len;i+=1){
            eff = null;
            switch(effects[i].ty){
                case 0:
                    eff = new SliderEffect(effects[i],element,this);
                    break;
                case 1:
                    eff = new AngleEffect(effects[i],element,this);
                    break;
                case 2:
                    eff = new ColorEffect(effects[i],element,this);
                    break;
                case 3:
                    eff = new PointEffect(effects[i],element,this);
                    break;
                case 4:
                case 7:
                    eff = new CheckboxEffect(effects[i],element,this);
                    break;
                case 10:
                    eff = new LayerIndexEffect(effects[i],element,this);
                    break;
                case 11:
                    eff = new MaskIndexEffect(effects[i],element,this);
                    break;
                case 5:
                    eff = new EffectsManager(effects[i],element,this);
                    break;
                //case 6:
                default:
                    eff = new NoValueEffect(effects[i],element,this);
                    break;
            }
            if(eff) {
                this.effectElements.push(eff);
            }
        }
    };

    var lottie = {};

    function setLocationHref (href) {
        locationHref = href;
    }

    function searchAnimations() {
        {
            animationManager.searchAnimations();
        }
    }

    function setSubframeRendering(flag) {
        subframeEnabled = flag;
    }

    function loadAnimation(params) {
        return animationManager.loadAnimation(params);
    }

    function setQuality(value) {
        if (typeof value === 'string') {
            switch (value) {
                case 'high':
                    defaultCurveSegments = 200;
                    break;
                case 'medium':
                    defaultCurveSegments = 50;
                    break;
                case 'low':
                    defaultCurveSegments = 10;
                    break;
            }
        } else if (!isNaN(value) && value > 1) {
            defaultCurveSegments = value;
        }
    }

    function inBrowser() {
        return typeof navigator !== 'undefined';
    }

    function installPlugin(type, plugin) {
        if (type === 'expressions') {
            expressionsPlugin = plugin;
        }
    }

    function getFactory(name) {
        switch (name) {
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
        }
    }

    lottie.play = animationManager.play;
    lottie.pause = animationManager.pause;
    lottie.setLocationHref = setLocationHref;
    lottie.togglePause = animationManager.togglePause;
    lottie.setSpeed = animationManager.setSpeed;
    lottie.setDirection = animationManager.setDirection;
    lottie.stop = animationManager.stop;
    lottie.searchAnimations = searchAnimations;
    lottie.registerAnimation = animationManager.registerAnimation;
    lottie.loadAnimation = loadAnimation;
    lottie.setSubframeRendering = setSubframeRendering;
    lottie.resize = animationManager.resize;
    //lottie.start = start;
    lottie.goToAndStop = animationManager.goToAndStop;
    lottie.destroy = animationManager.destroy;
    lottie.setQuality = setQuality;
    lottie.inBrowser = inBrowser;
    lottie.installPlugin = installPlugin;
    lottie.freeze = animationManager.freeze;
    lottie.unfreeze = animationManager.unfreeze;
    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
    lottie.__getFactory = getFactory;
    lottie.version = '5.7.1';

    function checkReady() {
        if (document.readyState === "complete") {
            clearInterval(readyStateCheckInterval);
            searchAnimations();
        }
    }

    function getQueryVariable(variable) {
        var vars = queryString.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) == variable) {
                return decodeURIComponent(pair[1]);
            }
        }
    }
    var renderer = '';
    {
        var scripts = document.getElementsByTagName('script');
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
            src: ''
        };
        var queryString = myScript.src.replace(/^[^\?]+\??/, '');
        renderer = getQueryVariable('renderer');
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);

    return lottie;
    }));
    });

    /* src\ui\blocks\Lottie.svelte generated by Svelte v3.24.1 */
    const file$e = "src\\ui\\blocks\\Lottie.svelte";

    function create_fragment$f(ctx) {
    	let component;
    	let container;
    	let container_class_value;

    	const block = {
    		c: function create() {
    			component = element("component");
    			container = element("container");
    			attr_dev(container, "class", container_class_value = "" + (null_to_empty(/*overrideColour*/ ctx[2] ? "override" : "") + " svelte-buakwj"));
    			set_style(container, "--colour-override", CSSUtility.parse(/*overrideColour*/ ctx[2]) + "\r\n\t\t");
    			add_location(container, file$e, 34, 1, 783);
    			set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[0]));
    			set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[1]));
    			attr_dev(component, "class", "svelte-buakwj");
    			add_location(component, file$e, 28, 0, 673);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, container);
    			/*container_binding*/ ctx[8](container);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*overrideColour*/ 4 && container_class_value !== (container_class_value = "" + (null_to_empty(/*overrideColour*/ ctx[2] ? "override" : "") + " svelte-buakwj"))) {
    				attr_dev(container, "class", container_class_value);
    			}

    			if (dirty & /*overrideColour*/ 4) {
    				set_style(container, "--colour-override", CSSUtility.parse(/*overrideColour*/ ctx[2]) + "\r\n\t\t");
    			}

    			if (dirty & /*height*/ 1) {
    				set_style(component, "--height", CSSUtility.parse(/*height*/ ctx[0]));
    			}

    			if (dirty & /*width*/ 2) {
    				set_style(component, "--width", CSSUtility.parse(/*width*/ ctx[1]));
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			/*container_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { src = "" } = $$props;
    	let { animationData = null } = $$props;
    	let { height = "100%" } = $$props;
    	let { width = "100%" } = $$props;
    	let { options = {} } = $$props;
    	let { overrideColour = null } = $$props;
    	let containerDomContent = null;
    	let { animation = null } = $$props;

    	onMount(async () => {
    		const json = animationData || (!src ? {} : await (await fetch(src)).json());

    		$$invalidate(4, animation = lottie.loadAnimation({
    			container: containerDomContent,
    			animationData: json,
    			autoplay: true,
    			loop: true,
    			...options
    		}));
    	});

    	const writable_props = [
    		"src",
    		"animationData",
    		"height",
    		"width",
    		"options",
    		"overrideColour",
    		"animation"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Lottie> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Lottie", $$slots, []);

    	function container_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			containerDomContent = $$value;
    			$$invalidate(3, containerDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("src" in $$props) $$invalidate(5, src = $$props.src);
    		if ("animationData" in $$props) $$invalidate(6, animationData = $$props.animationData);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    		if ("options" in $$props) $$invalidate(7, options = $$props.options);
    		if ("overrideColour" in $$props) $$invalidate(2, overrideColour = $$props.overrideColour);
    		if ("animation" in $$props) $$invalidate(4, animation = $$props.animation);
    	};

    	$$self.$capture_state = () => ({
    		lottie,
    		onMount,
    		CSSUtility,
    		src,
    		animationData,
    		height,
    		width,
    		options,
    		overrideColour,
    		containerDomContent,
    		animation
    	});

    	$$self.$inject_state = $$props => {
    		if ("src" in $$props) $$invalidate(5, src = $$props.src);
    		if ("animationData" in $$props) $$invalidate(6, animationData = $$props.animationData);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    		if ("options" in $$props) $$invalidate(7, options = $$props.options);
    		if ("overrideColour" in $$props) $$invalidate(2, overrideColour = $$props.overrideColour);
    		if ("containerDomContent" in $$props) $$invalidate(3, containerDomContent = $$props.containerDomContent);
    		if ("animation" in $$props) $$invalidate(4, animation = $$props.animation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		height,
    		width,
    		overrideColour,
    		containerDomContent,
    		animation,
    		src,
    		animationData,
    		options,
    		container_binding
    	];
    }

    class Lottie extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			src: 5,
    			animationData: 6,
    			height: 0,
    			width: 1,
    			options: 7,
    			overrideColour: 2,
    			animation: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lottie",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get src() {
    		return this.$$.ctx[5];
    	}

    	set src(src) {
    		this.$set({ src });
    		flush();
    	}

    	get animationData() {
    		return this.$$.ctx[6];
    	}

    	set animationData(animationData) {
    		this.$set({ animationData });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[0];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[1];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get options() {
    		return this.$$.ctx[7];
    	}

    	set options(options) {
    		this.$set({ options });
    		flush();
    	}

    	get overrideColour() {
    		return this.$$.ctx[2];
    	}

    	set overrideColour(overrideColour) {
    		this.$set({ overrideColour });
    		flush();
    	}

    	get animation() {
    		return this.$$.ctx[4];
    	}

    	set animation(animation) {
    		this.$set({ animation });
    		flush();
    	}
    }

    /* src\ui\blocks\buttons\LottieToggleButton.svelte generated by Svelte v3.24.1 */
    const file$f = "src\\ui\\blocks\\buttons\\LottieToggleButton.svelte";

    // (26:1) <Button    {...$$restProps}    {height}    {width}    {backgroundColour}    {hoverColour}    isText={false}    padding='16px 16px'    roundness='50px'    on:click={() => {     isActiveWritable.update((isActive) => !isActive);       dispatch('click');    }}   >
    function create_default_slot$6(ctx) {
    	let lottie;
    	let updating_animation;
    	let current;

    	function lottie_animation_binding(value) {
    		/*lottie_animation_binding*/ ctx[11].call(null, value);
    	}

    	let lottie_props = {
    		src: /*src*/ ctx[1],
    		animationData: /*animationData*/ ctx[2],
    		overrideColour: /*overrideColour*/ ctx[7],
    		options: { autoplay: false, loop: false }
    	};

    	if (/*animation*/ ctx[8] !== void 0) {
    		lottie_props.animation = /*animation*/ ctx[8];
    	}

    	lottie = new Lottie({ props: lottie_props, $$inline: true });
    	binding_callbacks.push(() => bind(lottie, "animation", lottie_animation_binding));

    	const block = {
    		c: function create() {
    			create_component(lottie.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lottie, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lottie_changes = {};
    			if (dirty & /*src*/ 2) lottie_changes.src = /*src*/ ctx[1];
    			if (dirty & /*animationData*/ 4) lottie_changes.animationData = /*animationData*/ ctx[2];
    			if (dirty & /*overrideColour*/ 128) lottie_changes.overrideColour = /*overrideColour*/ ctx[7];

    			if (!updating_animation && dirty & /*animation*/ 256) {
    				updating_animation = true;
    				lottie_changes.animation = /*animation*/ ctx[8];
    				add_flush_callback(() => updating_animation = false);
    			}

    			lottie.$set(lottie_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lottie.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lottie.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lottie, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(26:1) <Button    {...$$restProps}    {height}    {width}    {backgroundColour}    {hoverColour}    isText={false}    padding='16px 16px'    roundness='50px'    on:click={() => {     isActiveWritable.update((isActive) => !isActive);       dispatch('click');    }}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let component;
    	let button;
    	let current;

    	const button_spread_levels = [
    		/*$$restProps*/ ctx[10],
    		{ height: /*height*/ ctx[5] },
    		{ width: /*width*/ ctx[6] },
    		{
    			backgroundColour: /*backgroundColour*/ ctx[4]
    		},
    		{ hoverColour: /*hoverColour*/ ctx[3] },
    		{ isText: false },
    		{ padding: "16px 16px" },
    		{ roundness: "50px" }
    	];

    	let button_props = {
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < button_spread_levels.length; i += 1) {
    		button_props = assign(button_props, button_spread_levels[i]);
    	}

    	button = new Button({ props: button_props, $$inline: true });
    	button.$on("click", /*click_handler*/ ctx[12]);

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(button.$$.fragment);
    			add_location(component, file$f, 24, 0, 687);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(button, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = (dirty & /*$$restProps, height, width, backgroundColour, hoverColour*/ 1144)
    			? get_spread_update(button_spread_levels, [
    					dirty & /*$$restProps*/ 1024 && get_spread_object(/*$$restProps*/ ctx[10]),
    					dirty & /*height*/ 32 && { height: /*height*/ ctx[5] },
    					dirty & /*width*/ 64 && { width: /*width*/ ctx[6] },
    					dirty & /*backgroundColour*/ 16 && {
    						backgroundColour: /*backgroundColour*/ ctx[4]
    					},
    					dirty & /*hoverColour*/ 8 && { hoverColour: /*hoverColour*/ ctx[3] },
    					button_spread_levels[5],
    					button_spread_levels[6],
    					button_spread_levels[7]
    				])
    			: {};

    			if (dirty & /*$$scope, src, animationData, overrideColour, animation*/ 16774) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"isActiveWritable","src","animationData","hoverColour","backgroundColour","height","width","overrideColour"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);

    	let $isActiveWritable,
    		$$unsubscribe_isActiveWritable = noop,
    		$$subscribe_isActiveWritable = () => ($$unsubscribe_isActiveWritable(), $$unsubscribe_isActiveWritable = subscribe(isActiveWritable, $$value => $$invalidate(13, $isActiveWritable = $$value)), isActiveWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveWritable());
    	const isActiveWritable = writable(false);
    	validate_store(isActiveWritable, "isActiveWritable");
    	$$subscribe_isActiveWritable();
    	let { src = "" } = $$props;
    	let { animationData = null } = $$props;
    	let { hoverColour = "#0000" } = $$props;
    	let { backgroundColour = "#0000" } = $$props;
    	let { height = "100%" } = $$props;
    	let { width = "100%" } = $$props;
    	let { overrideColour = null } = $$props;
    	let animation = null;
    	const dispatch = createEventDispatcher();
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LottieToggleButton", $$slots, []);

    	function lottie_animation_binding(value) {
    		animation = value;
    		$$invalidate(8, animation);
    	}

    	const click_handler = () => {
    		isActiveWritable.update(isActive => !isActive);
    		dispatch("click");
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("src" in $$new_props) $$invalidate(1, src = $$new_props.src);
    		if ("animationData" in $$new_props) $$invalidate(2, animationData = $$new_props.animationData);
    		if ("hoverColour" in $$new_props) $$invalidate(3, hoverColour = $$new_props.hoverColour);
    		if ("backgroundColour" in $$new_props) $$invalidate(4, backgroundColour = $$new_props.backgroundColour);
    		if ("height" in $$new_props) $$invalidate(5, height = $$new_props.height);
    		if ("width" in $$new_props) $$invalidate(6, width = $$new_props.width);
    		if ("overrideColour" in $$new_props) $$invalidate(7, overrideColour = $$new_props.overrideColour);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		createEventDispatcher,
    		Button,
    		Lottie,
    		isActiveWritable,
    		src,
    		animationData,
    		hoverColour,
    		backgroundColour,
    		height,
    		width,
    		overrideColour,
    		animation,
    		dispatch,
    		$isActiveWritable
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("src" in $$props) $$invalidate(1, src = $$new_props.src);
    		if ("animationData" in $$props) $$invalidate(2, animationData = $$new_props.animationData);
    		if ("hoverColour" in $$props) $$invalidate(3, hoverColour = $$new_props.hoverColour);
    		if ("backgroundColour" in $$props) $$invalidate(4, backgroundColour = $$new_props.backgroundColour);
    		if ("height" in $$props) $$invalidate(5, height = $$new_props.height);
    		if ("width" in $$props) $$invalidate(6, width = $$new_props.width);
    		if ("overrideColour" in $$props) $$invalidate(7, overrideColour = $$new_props.overrideColour);
    		if ("animation" in $$props) $$invalidate(8, animation = $$new_props.animation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animation*/ 256) {
    			 isActiveWritable.set(animation?.direction > 0);
    		}

    		if ($$self.$$.dirty & /*animation, $isActiveWritable*/ 8448) {
    			 (animation?.setDirection($isActiveWritable ? 1 : -1), animation?.play());
    		}
    	};

    	return [
    		isActiveWritable,
    		src,
    		animationData,
    		hoverColour,
    		backgroundColour,
    		height,
    		width,
    		overrideColour,
    		animation,
    		dispatch,
    		$$restProps,
    		lottie_animation_binding,
    		click_handler
    	];
    }

    class LottieToggleButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			isActiveWritable: 0,
    			src: 1,
    			animationData: 2,
    			hoverColour: 3,
    			backgroundColour: 4,
    			height: 5,
    			width: 6,
    			overrideColour: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LottieToggleButton",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[0];
    	}

    	set isActiveWritable(value) {
    		throw new Error("<LottieToggleButton>: Cannot set read-only property 'isActiveWritable'");
    	}

    	get src() {
    		return this.$$.ctx[1];
    	}

    	set src(src) {
    		this.$set({ src });
    		flush();
    	}

    	get animationData() {
    		return this.$$.ctx[2];
    	}

    	set animationData(animationData) {
    		this.$set({ animationData });
    		flush();
    	}

    	get hoverColour() {
    		return this.$$.ctx[3];
    	}

    	set hoverColour(hoverColour) {
    		this.$set({ hoverColour });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[4];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[5];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[6];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get overrideColour() {
    		return this.$$.ctx[7];
    	}

    	set overrideColour(overrideColour) {
    		this.$set({ overrideColour });
    		flush();
    	}
    }

    const v = "5.6.3";
    const fr = 120;
    const ip = 0;
    const op = 90;
    const w = 412;
    const h = 312;
    const nm = "Comp 1";
    const ddd = 0;
    const assets = [
    	{
    		id: "comp_0",
    		layers: [
    			{
    				ddd: 0,
    				ind: 1,
    				ty: 4,
    				nm: "Shape Layer 3",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 10,
    								s: [
    									300,
    									200,
    									0
    								],
    								to: [
    									0,
    									16.667,
    									0
    								],
    								ti: [
    									0,
    									-16.667,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 0.27
    								},
    								o: {
    									x: 0.73,
    									y: 0.73
    								},
    								t: 30,
    								s: [
    									300,
    									300,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 50,
    								s: [
    									300,
    									300,
    									0
    								],
    								to: [
    									-16.667,
    									0,
    									0
    								],
    								ti: [
    									16.667,
    									0,
    									0
    								]
    							},
    							{
    								t: 70,
    								s: [
    									200,
    									300,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 42,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 42,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 10,
    				bm: 0
    			},
    			{
    				ddd: 0,
    				ind: 2,
    				ty: 4,
    				nm: "Shape Layer 4",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 8,
    								s: [
    									100,
    									200,
    									0
    								],
    								to: [
    									16.667,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 28,
    								s: [
    									200,
    									200,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 0.27
    								},
    								o: {
    									x: 0.73,
    									y: 0.73
    								},
    								t: 48,
    								s: [
    									300,
    									200,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 68,
    								s: [
    									300,
    									200,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								t: 88,
    								s: [
    									300,
    									300,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 34,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 34,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 8,
    				bm: 0
    			},
    			{
    				ddd: 0,
    				ind: 3,
    				ty: 4,
    				nm: "Shape Layer 6",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 26,
    								s: [
    									400,
    									300,
    									0
    								],
    								to: [
    									0,
    									-16.667,
    									0
    								],
    								ti: [
    									0,
    									16.667,
    									0
    								]
    							},
    							{
    								t: 46,
    								s: [
    									400,
    									200,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 26,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 26,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 6,
    				bm: 0
    			},
    			{
    				ddd: 0,
    				ind: 4,
    				ty: 4,
    				nm: "Shape Layer 5",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 4,
    								s: [
    									200,
    									300,
    									0
    								],
    								to: [
    									-16.667,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 24,
    								s: [
    									100,
    									300,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								t: 44,
    								s: [
    									100,
    									200,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 18,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 18,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 4,
    				bm: 0
    			},
    			{
    				ddd: 0,
    				ind: 5,
    				ty: 4,
    				nm: "Shape Layer 2",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 0.27
    								},
    								o: {
    									x: 0.73,
    									y: 0.73
    								},
    								t: 2,
    								s: [
    									300,
    									400,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 22,
    								s: [
    									300,
    									400,
    									0
    								],
    								to: [
    									16.667,
    									0,
    									0
    								],
    								ti: [
    									-16.667,
    									0,
    									0
    								]
    							},
    							{
    								t: 42,
    								s: [
    									400,
    									400,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 10,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 10,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 2,
    				bm: 0
    			},
    			{
    				ddd: 0,
    				ind: 6,
    				ty: 4,
    				nm: "Shape Layer 1",
    				sr: 1,
    				ks: {
    					p: {
    						a: 1,
    						k: [
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 0,
    								s: [
    									100,
    									400,
    									0
    								],
    								to: [
    									16.667,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 20,
    								s: [
    									200,
    									400,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 40,
    								s: [
    									200,
    									300,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									0,
    									0
    								]
    							},
    							{
    								i: {
    									x: 0.27,
    									y: 1
    								},
    								o: {
    									x: 0.73,
    									y: 0
    								},
    								t: 60,
    								s: [
    									100,
    									300,
    									0
    								],
    								to: [
    									0,
    									0,
    									0
    								],
    								ti: [
    									0,
    									-16.667,
    									0
    								]
    							},
    							{
    								t: 80,
    								s: [
    									100,
    									400,
    									0
    								]
    							}
    						]
    					}
    				},
    				ao: 0,
    				shapes: [
    					{
    						ty: "gr",
    						it: [
    							{
    								ty: "rc",
    								d: 1,
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								nm: "Rectangle Path 1",
    								hd: false
    							},
    							{
    								ty: "st",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								w: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												12
    											],
    											h: 1
    										},
    										{
    											t: 2,
    											s: [
    												0
    											],
    											h: 1
    										}
    									]
    								},
    								lc: 1,
    								lj: 1,
    								ml: 4,
    								bm: 0,
    								nm: "Stroke 1",
    								hd: false
    							},
    							{
    								ty: "fl",
    								c: {
    									a: 0,
    									k: [
    										1,
    										1,
    										1,
    										1
    									]
    								},
    								o: {
    									a: 1,
    									k: [
    										{
    											t: 0,
    											s: [
    												0
    											],
    											h: 1
    										},
    										{
    											t: 2,
    											s: [
    												100
    											],
    											h: 1
    										}
    									]
    								},
    								r: 1,
    								bm: 0,
    								nm: "Fill 1",
    								hd: false
    							},
    							{
    								ty: "tr",
    								p: {
    									a: 0,
    									k: [
    										0,
    										0
    									]
    								},
    								a: {
    									a: 0,
    									k: [
    										-50,
    										-50
    									]
    								},
    								s: {
    									a: 0,
    									k: [
    										100,
    										100
    									]
    								},
    								r: {
    									a: 0,
    									k: 0
    								},
    								o: {
    									a: 0,
    									k: 100
    								},
    								sk: {
    									a: 0,
    									k: 0
    								},
    								sa: {
    									a: 0,
    									k: 0
    								},
    								nm: "Transform"
    							}
    						],
    						nm: "Rectangle 1",
    						bm: 0,
    						hd: false
    					}
    				],
    				ip: 0,
    				op: 90,
    				st: 0,
    				bm: 0
    			}
    		]
    	}
    ];
    const layers = [
    	{
    		ddd: 0,
    		ind: 1,
    		ty: 0,
    		nm: "Pre-comp 1",
    		refId: "comp_0",
    		sr: 1,
    		ks: {
    			p: {
    				a: 0,
    				k: [
    					206,
    					106,
    					0
    				]
    			},
    			a: {
    				a: 0,
    				k: [
    					300,
    					300,
    					0
    				]
    			}
    		},
    		ao: 0,
    		w: 600,
    		h: 600,
    		ip: 0,
    		op: 90,
    		st: 0,
    		bm: 0
    	}
    ];
    const markers = [
    ];
    var hamburger = {
    	v: v,
    	fr: fr,
    	ip: ip,
    	op: op,
    	w: w,
    	h: h,
    	nm: nm,
    	ddd: ddd,
    	assets: assets,
    	layers: layers,
    	markers: markers
    };

    /* src\ui\blocks\Hamburger.svelte generated by Svelte v3.24.1 */

    const { Object: Object_1$1 } = globals;
    const file$g = "src\\ui\\blocks\\Hamburger.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (23:0) {#if toppings}
    function create_if_block$5(ctx) {
    	let component;
    	let container0;
    	let lottietogglebutton;
    	let updating_isActiveWritable;
    	let container0_class_value;
    	let t0;
    	let t1;
    	let container2;
    	let container1;
    	let container2_class_value;
    	let current;

    	function lottietogglebutton_isActiveWritable_binding(value) {
    		/*lottietogglebutton_isActiveWritable_binding*/ ctx[11].call(null, value);
    	}

    	let lottietogglebutton_props = {
    		animationData: hamburger,
    		overrideColour: "--colour-text-primary"
    	};

    	if (/*isActiveWritable*/ ctx[0] !== void 0) {
    		lottietogglebutton_props.isActiveWritable = /*isActiveWritable*/ ctx[0];
    	}

    	lottietogglebutton = new LottieToggleButton({
    			props: lottietogglebutton_props,
    			$$inline: true
    		});

    	/*lottietogglebutton_binding*/ ctx[10](lottietogglebutton);
    	binding_callbacks.push(() => bind(lottietogglebutton, "isActiveWritable", lottietogglebutton_isActiveWritable_binding));
    	let if_block = /*$isActiveWritable*/ ctx[8] && create_if_block_1$1(ctx);
    	let each_value = Object.keys(/*toppings*/ ctx[1]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			component = element("component");
    			container0 = element("container");
    			create_component(lottietogglebutton.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			container2 = element("container");
    			container1 = element("container");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(container0, "class", container0_class_value = "button " + (/*$isActiveWritable*/ ctx[8] ? "boosted" : "") + " svelte-ltvtmb");
    			set_style(container0, "--button-size", CSSUtility.parse(/*buttonSize*/ ctx[2]));
    			add_location(container0, file$g, 29, 2, 929);
    			attr_dev(container1, "class", "content svelte-ltvtmb");
    			add_location(container1, file$g, 56, 3, 1531);
    			attr_dev(container2, "class", container2_class_value = "menu " + (/*$isActiveWritable*/ ctx[8] ? "" : "inactive") + " svelte-ltvtmb");
    			set_style(container2, "--width", CSSUtility.parse(/*menuWidth*/ ctx[4]));
    			add_location(container2, file$g, 50, 2, 1393);
    			set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[3]));
    			set_style(component, "--menu-top-offset", CSSUtility.parse(/*$menuTopOffsetWritable*/ ctx[7]) + "\r\n\t\t");
    			attr_dev(component, "class", "svelte-ltvtmb");
    			add_location(component, file$g, 23, 1, 766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			append_dev(component, container0);
    			mount_component(lottietogglebutton, container0, null);
    			append_dev(component, t0);
    			if (if_block) if_block.m(component, null);
    			append_dev(component, t1);
    			append_dev(component, container2);
    			append_dev(container2, container1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(container1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lottietogglebutton_changes = {};

    			if (!updating_isActiveWritable && dirty & /*isActiveWritable*/ 1) {
    				updating_isActiveWritable = true;
    				lottietogglebutton_changes.isActiveWritable = /*isActiveWritable*/ ctx[0];
    				add_flush_callback(() => updating_isActiveWritable = false);
    			}

    			lottietogglebutton.$set(lottietogglebutton_changes);

    			if (!current || dirty & /*$isActiveWritable*/ 256 && container0_class_value !== (container0_class_value = "button " + (/*$isActiveWritable*/ ctx[8] ? "boosted" : "") + " svelte-ltvtmb")) {
    				attr_dev(container0, "class", container0_class_value);
    			}

    			if (!current || dirty & /*buttonSize*/ 4) {
    				set_style(container0, "--button-size", CSSUtility.parse(/*buttonSize*/ ctx[2]));
    			}

    			if (/*$isActiveWritable*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isActiveWritable*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(component, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*isActiveWritable, toppings, Object*/ 3) {
    				each_value = Object.keys(/*toppings*/ ctx[1]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(container1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*$isActiveWritable*/ 256 && container2_class_value !== (container2_class_value = "menu " + (/*$isActiveWritable*/ ctx[8] ? "" : "inactive") + " svelte-ltvtmb")) {
    				attr_dev(container2, "class", container2_class_value);
    			}

    			if (!current || dirty & /*menuWidth*/ 16) {
    				set_style(container2, "--width", CSSUtility.parse(/*menuWidth*/ ctx[4]));
    			}

    			if (!current || dirty & /*backgroundColour*/ 8) {
    				set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[3]));
    			}

    			if (!current || dirty & /*$menuTopOffsetWritable*/ 128) {
    				set_style(component, "--menu-top-offset", CSSUtility.parse(/*$menuTopOffsetWritable*/ ctx[7]) + "\r\n\t\t");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lottietogglebutton.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lottietogglebutton.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			/*lottietogglebutton_binding*/ ctx[10](null);
    			destroy_component(lottietogglebutton);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(23:0) {#if toppings}",
    		ctx
    	});

    	return block;
    }

    // (44:2) {#if $isActiveWritable}
    function create_if_block_1$1(ctx) {
    	let overlay;
    	let overlay_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			overlay = element("overlay");
    			attr_dev(overlay, "class", "svelte-ltvtmb");
    			add_location(overlay, file$g, 44, 3, 1289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, overlay, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(overlay, "click", /*click_handler*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!overlay_transition) overlay_transition = create_bidirectional_transition(overlay, fade, {}, true);
    				overlay_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!overlay_transition) overlay_transition = create_bidirectional_transition(overlay, fade, {}, false);
    			overlay_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(overlay);
    			if (detaching && overlay_transition) overlay_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(44:2) {#if $isActiveWritable}",
    		ctx
    	});

    	return block;
    }

    // (64:6) <Button         on:click={() => {          isActiveWritable.set(false);            toppings[toppingKey]();         }}         icon='arrow_forward'         backgroundColour='--colour-background-primary'         textColour='--colour-accent-primary'         hoverColour='--colour-background-secondary'         rippleColour='--colour-accent-primary'         width='100%'         height='100%'         roundness='0'        >
    function create_default_slot$7(ctx) {
    	let t_value = /*toppingKey*/ ctx[14] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*toppings*/ 2 && t_value !== (t_value = /*toppingKey*/ ctx[14] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(64:6) <Button         on:click={() => {          isActiveWritable.set(false);            toppings[toppingKey]();         }}         icon='arrow_forward'         backgroundColour='--colour-background-primary'         textColour='--colour-accent-primary'         hoverColour='--colour-background-secondary'         rippleColour='--colour-accent-primary'         width='100%'         height='100%'         roundness='0'        >",
    		ctx
    	});

    	return block;
    }

    // (60:4) {#each Object.keys(toppings) as toppingKey}
    function create_each_block$1(ctx) {
    	let container;
    	let button;
    	let t;
    	let current;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[13](/*toppingKey*/ ctx[14], ...args);
    	}

    	button = new Button({
    			props: {
    				icon: "arrow_forward",
    				backgroundColour: "--colour-background-primary",
    				textColour: "--colour-accent-primary",
    				hoverColour: "--colour-background-secondary",
    				rippleColour: "--colour-accent-primary",
    				width: "100%",
    				height: "100%",
    				roundness: "0",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler_1);

    	const block = {
    		c: function create() {
    			container = element("container");
    			create_component(button.$$.fragment);
    			t = space();
    			attr_dev(container, "class", "topping svelte-ltvtmb");
    			add_location(container, file$g, 60, 5, 1624);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			mount_component(button, container, null);
    			append_dev(container, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};

    			if (dirty & /*$$scope, toppings*/ 131074) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(60:4) {#each Object.keys(toppings) as toppingKey}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*toppings*/ ctx[1] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*toppings*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*toppings*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $menuTopOffsetWritable,
    		$$unsubscribe_menuTopOffsetWritable = noop,
    		$$subscribe_menuTopOffsetWritable = () => ($$unsubscribe_menuTopOffsetWritable(), $$unsubscribe_menuTopOffsetWritable = subscribe(menuTopOffsetWritable, $$value => $$invalidate(7, $menuTopOffsetWritable = $$value)), menuTopOffsetWritable);

    	let $isActiveWritable,
    		$$unsubscribe_isActiveWritable = noop,
    		$$subscribe_isActiveWritable = () => ($$unsubscribe_isActiveWritable(), $$unsubscribe_isActiveWritable = subscribe(isActiveWritable, $$value => $$invalidate(8, $isActiveWritable = $$value)), isActiveWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_menuTopOffsetWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_isActiveWritable());
    	let { isActiveWritable = writable(false) } = $$props;
    	validate_store(isActiveWritable, "isActiveWritable");
    	$$subscribe_isActiveWritable();
    	let { toppings = null } = $$props;
    	let { buttonSize = "2rem" } = $$props;
    	let { backgroundColour = "--colour-background-primary" } = $$props;
    	let { menuWidth = 420 } = $$props;
    	let { menuTopOffset = "--padding" } = $$props;
    	let { menuTopOffsetWritable = writable(menuTopOffset) } = $$props;
    	validate_store(menuTopOffsetWritable, "menuTopOffsetWritable");
    	$$subscribe_menuTopOffsetWritable();
    	let lottieToggleButton = null;

    	const writable_props = [
    		"isActiveWritable",
    		"toppings",
    		"buttonSize",
    		"backgroundColour",
    		"menuWidth",
    		"menuTopOffset",
    		"menuTopOffsetWritable"
    	];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Hamburger> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Hamburger", $$slots, []);

    	function lottietogglebutton_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			lottieToggleButton = $$value;
    			$$invalidate(6, lottieToggleButton);
    		});
    	}

    	function lottietogglebutton_isActiveWritable_binding(value) {
    		isActiveWritable = value;
    		$$subscribe_isActiveWritable($$invalidate(0, isActiveWritable));
    	}

    	const click_handler = () => isActiveWritable.set(false);

    	const click_handler_1 = toppingKey => {
    		isActiveWritable.set(false);
    		toppings[toppingKey]();
    	};

    	$$self.$$set = $$props => {
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(0, isActiveWritable = $$props.isActiveWritable));
    		if ("toppings" in $$props) $$invalidate(1, toppings = $$props.toppings);
    		if ("buttonSize" in $$props) $$invalidate(2, buttonSize = $$props.buttonSize);
    		if ("backgroundColour" in $$props) $$invalidate(3, backgroundColour = $$props.backgroundColour);
    		if ("menuWidth" in $$props) $$invalidate(4, menuWidth = $$props.menuWidth);
    		if ("menuTopOffset" in $$props) $$invalidate(9, menuTopOffset = $$props.menuTopOffset);
    		if ("menuTopOffsetWritable" in $$props) $$subscribe_menuTopOffsetWritable($$invalidate(5, menuTopOffsetWritable = $$props.menuTopOffsetWritable));
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		fade,
    		LottieToggleButton,
    		hamburger,
    		CSSUtility,
    		Button,
    		isActiveWritable,
    		toppings,
    		buttonSize,
    		backgroundColour,
    		menuWidth,
    		menuTopOffset,
    		menuTopOffsetWritable,
    		lottieToggleButton,
    		$menuTopOffsetWritable,
    		$isActiveWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActiveWritable" in $$props) $$subscribe_isActiveWritable($$invalidate(0, isActiveWritable = $$props.isActiveWritable));
    		if ("toppings" in $$props) $$invalidate(1, toppings = $$props.toppings);
    		if ("buttonSize" in $$props) $$invalidate(2, buttonSize = $$props.buttonSize);
    		if ("backgroundColour" in $$props) $$invalidate(3, backgroundColour = $$props.backgroundColour);
    		if ("menuWidth" in $$props) $$invalidate(4, menuWidth = $$props.menuWidth);
    		if ("menuTopOffset" in $$props) $$invalidate(9, menuTopOffset = $$props.menuTopOffset);
    		if ("menuTopOffsetWritable" in $$props) $$subscribe_menuTopOffsetWritable($$invalidate(5, menuTopOffsetWritable = $$props.menuTopOffsetWritable));
    		if ("lottieToggleButton" in $$props) $$invalidate(6, lottieToggleButton = $$props.lottieToggleButton);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isActiveWritable,
    		toppings,
    		buttonSize,
    		backgroundColour,
    		menuWidth,
    		menuTopOffsetWritable,
    		lottieToggleButton,
    		$menuTopOffsetWritable,
    		$isActiveWritable,
    		menuTopOffset,
    		lottietogglebutton_binding,
    		lottietogglebutton_isActiveWritable_binding,
    		click_handler,
    		click_handler_1
    	];
    }

    class Hamburger extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			isActiveWritable: 0,
    			toppings: 1,
    			buttonSize: 2,
    			backgroundColour: 3,
    			menuWidth: 4,
    			menuTopOffset: 9,
    			menuTopOffsetWritable: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Hamburger",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[0];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}

    	get toppings() {
    		return this.$$.ctx[1];
    	}

    	set toppings(toppings) {
    		this.$set({ toppings });
    		flush();
    	}

    	get buttonSize() {
    		return this.$$.ctx[2];
    	}

    	set buttonSize(buttonSize) {
    		this.$set({ buttonSize });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[3];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get menuWidth() {
    		return this.$$.ctx[4];
    	}

    	set menuWidth(menuWidth) {
    		this.$set({ menuWidth });
    		flush();
    	}

    	get menuTopOffset() {
    		return this.$$.ctx[9];
    	}

    	set menuTopOffset(menuTopOffset) {
    		this.$set({ menuTopOffset });
    		flush();
    	}

    	get menuTopOffsetWritable() {
    		return this.$$.ctx[5];
    	}

    	set menuTopOffsetWritable(menuTopOffsetWritable) {
    		this.$set({ menuTopOffsetWritable });
    		flush();
    	}
    }

    /* src\ui\blocks\appBars\ScrollableAppBar.svelte generated by Svelte v3.24.1 */
    const file$h = "src\\ui\\blocks\\appBars\\ScrollableAppBar.svelte";

    // (49:1) <AppBar    contentPadding='{CSSUtility.parse(mininumPadding)} 0'    bind:this={appBar}    {appBarPaddingWritable}    {...$$restProps}   >
    function create_default_slot$8(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(49:1) <AppBar    contentPadding='{CSSUtility.parse(mininumPadding)} 0'    bind:this={appBar}    {appBarPaddingWritable}    {...$$restProps}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let component;
    	let appbar;
    	let current;

    	const appbar_spread_levels = [
    		{
    			contentPadding: "" + (CSSUtility.parse(/*mininumPadding*/ ctx[1]) + " 0")
    		},
    		{
    			appBarPaddingWritable: /*appBarPaddingWritable*/ ctx[5]
    		},
    		/*$$restProps*/ ctx[7]
    	];

    	let appbar_props = {
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < appbar_spread_levels.length; i += 1) {
    		appbar_props = assign(appbar_props, appbar_spread_levels[i]);
    	}

    	appbar = new AppBar({ props: appbar_props, $$inline: true });
    	/*appbar_binding*/ ctx[10](appbar);

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(appbar.$$.fragment);
    			add_location(component, file$h, 45, 0, 1173);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(appbar, component, null);
    			/*component_binding*/ ctx[11](component);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const appbar_changes = (dirty & /*CSSUtility, mininumPadding, appBarPaddingWritable, $$restProps*/ 162)
    			? get_spread_update(appbar_spread_levels, [
    					dirty & /*CSSUtility, mininumPadding*/ 2 && {
    						contentPadding: "" + (CSSUtility.parse(/*mininumPadding*/ ctx[1]) + " 0")
    					},
    					dirty & /*appBarPaddingWritable*/ 32 && {
    						appBarPaddingWritable: /*appBarPaddingWritable*/ ctx[5]
    					},
    					dirty & /*$$restProps*/ 128 && get_spread_object(/*$$restProps*/ ctx[7])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 4096) {
    				appbar_changes.$$scope = { dirty, ctx };
    			}

    			appbar.$set(appbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(appbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(appbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			/*appbar_binding*/ ctx[10](null);
    			destroy_component(appbar);
    			/*component_binding*/ ctx[11](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	const omit_props_names = ["baseHeightWritable","scrolledHeightWritable","mininumPadding"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);

    	let $computedPaddingWritable,
    		$$unsubscribe_computedPaddingWritable = noop,
    		$$subscribe_computedPaddingWritable = () => ($$unsubscribe_computedPaddingWritable(), $$unsubscribe_computedPaddingWritable = subscribe(computedPaddingWritable, $$value => $$invalidate(13, $computedPaddingWritable = $$value)), computedPaddingWritable);

    	let $baseHeightWritable,
    		$$unsubscribe_baseHeightWritable = noop,
    		$$subscribe_baseHeightWritable = () => ($$unsubscribe_baseHeightWritable(), $$unsubscribe_baseHeightWritable = subscribe(baseHeightWritable, $$value => $$invalidate(14, $baseHeightWritable = $$value)), baseHeightWritable);

    	let $scrollYWritable;
    	$$self.$$.on_destroy.push(() => $$unsubscribe_computedPaddingWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_baseHeightWritable());
    	let { baseHeightWritable = writable(0) } = $$props;
    	validate_store(baseHeightWritable, "baseHeightWritable");
    	$$subscribe_baseHeightWritable();
    	let { scrolledHeightWritable = writable(0) } = $$props;
    	let { mininumPadding = 8 } = $$props;
    	let componentDomContent = null;
    	let computedPaddingWritable = null;
    	validate_store(computedPaddingWritable, "computedPaddingWritable");
    	$$subscribe_computedPaddingWritable();
    	let appBar = null;
    	const appBarPaddingWritable = writable(0);
    	const scrollYWritable = writable(0);
    	validate_store(scrollYWritable, "scrollYWritable");
    	component_subscribe($$self, scrollYWritable, value => $$invalidate(15, $scrollYWritable = value));

    	window.addEventListener(
    		"scroll",
    		() => {
    			scrollYWritable.set((() => {
    				if ($computedPaddingWritable === null) {
    					return window.scrollY;
    				}

    				if ($computedPaddingWritable * 2 - window.scrollY < 0) {
    					return $computedPaddingWritable * 2;
    				}

    				return window.scrollY;
    			})());
    		},
    		{ passive: true }
    	);

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ScrollableAppBar", $$slots, ['default']);

    	function appbar_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			appBar = $$value;
    			$$invalidate(4, appBar);
    		});
    	}

    	function component_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			componentDomContent = $$value;
    			$$invalidate(2, componentDomContent);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("baseHeightWritable" in $$new_props) $$subscribe_baseHeightWritable($$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable));
    		if ("scrolledHeightWritable" in $$new_props) $$invalidate(8, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("mininumPadding" in $$new_props) $$invalidate(1, mininumPadding = $$new_props.mininumPadding);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		AppBar,
    		CSSUtility,
    		baseHeightWritable,
    		scrolledHeightWritable,
    		mininumPadding,
    		componentDomContent,
    		computedPaddingWritable,
    		appBar,
    		appBarPaddingWritable,
    		scrollYWritable,
    		$computedPaddingWritable,
    		$baseHeightWritable,
    		$scrollYWritable
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("baseHeightWritable" in $$props) $$subscribe_baseHeightWritable($$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable));
    		if ("scrolledHeightWritable" in $$props) $$invalidate(8, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("mininumPadding" in $$props) $$invalidate(1, mininumPadding = $$new_props.mininumPadding);
    		if ("componentDomContent" in $$props) $$invalidate(2, componentDomContent = $$new_props.componentDomContent);
    		if ("computedPaddingWritable" in $$props) $$subscribe_computedPaddingWritable($$invalidate(3, computedPaddingWritable = $$new_props.computedPaddingWritable));
    		if ("appBar" in $$props) $$invalidate(4, appBar = $$new_props.appBar);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*appBar*/ 16) {
    			 $$subscribe_computedPaddingWritable($$invalidate(3, computedPaddingWritable = appBar?.computedPaddingWritable));
    		}

    		if ($$self.$$.dirty & /*appBar*/ 16) {
    			 $$subscribe_baseHeightWritable($$invalidate(0, baseHeightWritable = appBar?.baseHeightWritable));
    		}

    		if ($$self.$$.dirty & /*scrolledHeightWritable, $baseHeightWritable, $scrollYWritable*/ 49408) {
    			 scrolledHeightWritable.set($baseHeightWritable - $scrollYWritable);
    		}

    		if ($$self.$$.dirty & /*$scrollYWritable*/ 32768) {
    			 appBarPaddingWritable.set(`calc(var(--padding) - (${$scrollYWritable}px / 2)) var(--padding)`);
    		}
    	};

    	return [
    		baseHeightWritable,
    		mininumPadding,
    		componentDomContent,
    		computedPaddingWritable,
    		appBar,
    		appBarPaddingWritable,
    		scrollYWritable,
    		$$restProps,
    		scrolledHeightWritable,
    		$$slots,
    		appbar_binding,
    		component_binding,
    		$$scope
    	];
    }

    class ScrollableAppBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			baseHeightWritable: 0,
    			scrolledHeightWritable: 8,
    			mininumPadding: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ScrollableAppBar",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get baseHeightWritable() {
    		return this.$$.ctx[0];
    	}

    	set baseHeightWritable(baseHeightWritable) {
    		this.$set({ baseHeightWritable });
    		flush();
    	}

    	get scrolledHeightWritable() {
    		return this.$$.ctx[8];
    	}

    	set scrolledHeightWritable(scrolledHeightWritable) {
    		this.$set({ scrolledHeightWritable });
    		flush();
    	}

    	get mininumPadding() {
    		return this.$$.ctx[1];
    	}

    	set mininumPadding(mininumPadding) {
    		this.$set({ mininumPadding });
    		flush();
    	}
    }

    /* src\ui\blocks\appBars\HamburgerAppBar.svelte generated by Svelte v3.24.1 */
    const file$i = "src\\ui\\blocks\\appBars\\HamburgerAppBar.svelte";

    // (13:0) <ScrollableAppBar   bind:baseHeightWritable   bind:scrolledHeightWritable   {...$$restProps}  >
    function create_default_slot$9(ctx) {
    	let container;
    	let hamburger;
    	let current;

    	hamburger = new Hamburger({
    			props: {
    				toppings: /*toppings*/ ctx[2],
    				buttonSize: "calc(2rem + 32px)",
    				menuTopOffsetWritable: /*scrolledHeightWritable*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			container = element("container");
    			create_component(hamburger.$$.fragment);
    			attr_dev(container, "class", "svelte-nfnx3w");
    			add_location(container, file$i, 17, 1, 416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			mount_component(hamburger, container, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hamburger_changes = {};
    			if (dirty & /*toppings*/ 4) hamburger_changes.toppings = /*toppings*/ ctx[2];
    			if (dirty & /*scrolledHeightWritable*/ 2) hamburger_changes.menuTopOffsetWritable = /*scrolledHeightWritable*/ ctx[1];
    			hamburger.$set(hamburger_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hamburger.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hamburger.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			destroy_component(hamburger);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(13:0) <ScrollableAppBar   bind:baseHeightWritable   bind:scrolledHeightWritable   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let scrollableappbar;
    	let updating_baseHeightWritable;
    	let updating_scrolledHeightWritable;
    	let current;
    	const scrollableappbar_spread_levels = [/*$$restProps*/ ctx[3]];

    	function scrollableappbar_baseHeightWritable_binding(value) {
    		/*scrollableappbar_baseHeightWritable_binding*/ ctx[4].call(null, value);
    	}

    	function scrollableappbar_scrolledHeightWritable_binding(value) {
    		/*scrollableappbar_scrolledHeightWritable_binding*/ ctx[5].call(null, value);
    	}

    	let scrollableappbar_props = {
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < scrollableappbar_spread_levels.length; i += 1) {
    		scrollableappbar_props = assign(scrollableappbar_props, scrollableappbar_spread_levels[i]);
    	}

    	if (/*baseHeightWritable*/ ctx[0] !== void 0) {
    		scrollableappbar_props.baseHeightWritable = /*baseHeightWritable*/ ctx[0];
    	}

    	if (/*scrolledHeightWritable*/ ctx[1] !== void 0) {
    		scrollableappbar_props.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    	}

    	scrollableappbar = new ScrollableAppBar({
    			props: scrollableappbar_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(scrollableappbar, "baseHeightWritable", scrollableappbar_baseHeightWritable_binding));
    	binding_callbacks.push(() => bind(scrollableappbar, "scrolledHeightWritable", scrollableappbar_scrolledHeightWritable_binding));

    	const block = {
    		c: function create() {
    			create_component(scrollableappbar.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrollableappbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scrollableappbar_changes = (dirty & /*$$restProps*/ 8)
    			? get_spread_update(scrollableappbar_spread_levels, [get_spread_object(/*$$restProps*/ ctx[3])])
    			: {};

    			if (dirty & /*$$scope, toppings, scrolledHeightWritable*/ 70) {
    				scrollableappbar_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_baseHeightWritable && dirty & /*baseHeightWritable*/ 1) {
    				updating_baseHeightWritable = true;
    				scrollableappbar_changes.baseHeightWritable = /*baseHeightWritable*/ ctx[0];
    				add_flush_callback(() => updating_baseHeightWritable = false);
    			}

    			if (!updating_scrolledHeightWritable && dirty & /*scrolledHeightWritable*/ 2) {
    				updating_scrolledHeightWritable = true;
    				scrollableappbar_changes.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    				add_flush_callback(() => updating_scrolledHeightWritable = false);
    			}

    			scrollableappbar.$set(scrollableappbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrollableappbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrollableappbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrollableappbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	const omit_props_names = ["baseHeightWritable","scrolledHeightWritable","toppings"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { baseHeightWritable = writable(0) } = $$props;
    	let { scrolledHeightWritable = writable(0) } = $$props;
    	let { toppings = null } = $$props;
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HamburgerAppBar", $$slots, []);

    	function scrollableappbar_baseHeightWritable_binding(value) {
    		baseHeightWritable = value;
    		$$invalidate(0, baseHeightWritable);
    	}

    	function scrollableappbar_scrolledHeightWritable_binding(value) {
    		scrolledHeightWritable = value;
    		$$invalidate(1, scrolledHeightWritable);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("baseHeightWritable" in $$new_props) $$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable);
    		if ("scrolledHeightWritable" in $$new_props) $$invalidate(1, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("toppings" in $$new_props) $$invalidate(2, toppings = $$new_props.toppings);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		Hamburger,
    		ScrollableAppBar,
    		baseHeightWritable,
    		scrolledHeightWritable,
    		toppings
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("baseHeightWritable" in $$props) $$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable);
    		if ("scrolledHeightWritable" in $$props) $$invalidate(1, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("toppings" in $$props) $$invalidate(2, toppings = $$new_props.toppings);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		baseHeightWritable,
    		scrolledHeightWritable,
    		toppings,
    		$$restProps,
    		scrollableappbar_baseHeightWritable_binding,
    		scrollableappbar_scrolledHeightWritable_binding
    	];
    }

    class HamburgerAppBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			baseHeightWritable: 0,
    			scrolledHeightWritable: 1,
    			toppings: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HamburgerAppBar",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get baseHeightWritable() {
    		return this.$$.ctx[0];
    	}

    	set baseHeightWritable(baseHeightWritable) {
    		this.$set({ baseHeightWritable });
    		flush();
    	}

    	get scrolledHeightWritable() {
    		return this.$$.ctx[1];
    	}

    	set scrolledHeightWritable(scrolledHeightWritable) {
    		this.$set({ scrolledHeightWritable });
    		flush();
    	}

    	get toppings() {
    		return this.$$.ctx[2];
    	}

    	set toppings(toppings) {
    		this.$set({ toppings });
    		flush();
    	}
    }

    class SMSItem extends Item {
        constructor() {
            super(...arguments);
            this.from = null;
            this.to = null;
            this.content = null;
        }
    }
    class SMSItemFactory extends Factory {
        static from(result) {
            return new SMSItem().combine(result);
        }
    }

    class SMSContact {
        constructor(name) {
            this.name = name;
            this.id = (SMSContact.registeredContactsLength++).toString();
        }
    }
    SMSContact.registeredContactsLength = 0;

    class IncompatibleError extends ClientError {
        constructor(options) {
            const { message } = options;
            super({
                message: `${strings.common.errors.INCOMPATIBLE}${message ? `: ${message}` : ''}`,
            });
        }
    }

    class SMS {
        constructor(contact) {
            this.contact = contact;
            this.contactIndex = NaN;
            if (contact === undefined) {
                throw new IncorrectUsageError({
                    message: 'contact === undefined',
                });
            }
            if (SMS.contacts.indexOf(this.contact) !== -1) {
                this.contactIndex = SMS.contacts.indexOf(this.contact);
                return;
            }
            SMS.contacts.push(contact);
            SMS.messageGroups.push([]);
            this.contactIndex = SMS.contacts.indexOf(this.contact);
        }
        sendBroadcast(content) {
            this.send(SMS.BROADCAST_CONTACT, content);
        }
        receiveBroadcast(from, callback = undefined) {
            let realFrom = from;
            let realCallback = callback;
            if (typeof from === 'function'
                && callback === undefined) {
                realFrom = null;
                realCallback = from;
            }
            SMS.callbackGroups[SMS.BROADCAST_INDEX]
                .push(realCallback);
            SMS.dispatchBroadcast(realFrom);
        }
        send(to, content) {
            if (SMS.messageGroups[this.contactIndex] == null) {
                SMS.messageGroups[this.contactIndex] = [];
            }
            SMS.messageGroups[this.contactIndex]
                .push(SMSItemFactory.from({
                to,
                from: this.contact,
                content,
            }));
            SMS.dispatch(this.contact);
        }
        fetch(from) {
            const result = [];
            SMS.messageGroups
                ?.forEach((messageGroup) => {
                const resolvedMessageIndexes = [];
                messageGroup
                    ?.forEach((message, i) => {
                    if (message.from !== from) {
                        return;
                    }
                    result.push(message);
                    resolvedMessageIndexes.push(i);
                });
                resolvedMessageIndexes.forEach((unneededIndex) => delete messageGroup[unneededIndex]);
                SMS.trimArray(messageGroup);
            });
            return result;
        }
        receive(from, callback) {
            if (from === SMS.BROADCAST_CONTACT) {
                return this.receiveBroadcast(callback);
            }
            if (SMS.callbackGroups[this.contactIndex] == null) {
                SMS.callbackGroups[this.contactIndex] = [];
            }
            SMS.callbackGroups[this.contactIndex]
                .push(callback);
            SMS.dispatch(from);
        }
        static dispatch(from) {
            SMS.messageGroups
                ?.forEach((messageGroup) => {
                const resolvedMessageIndexes = [];
                messageGroup
                    ?.forEach((message, valueIndex) => {
                    if (message.from !== from) {
                        return;
                    }
                    const { to, } = message;
                    const targetContactIndex = SMS.contacts.indexOf(to);
                    SMS.callbackGroups[targetContactIndex]
                        ?.forEach((callback) => {
                        callback(message);
                        resolvedMessageIndexes.push(valueIndex);
                    });
                });
                resolvedMessageIndexes.forEach((unneededIndex) => delete messageGroup[unneededIndex]);
                SMS.trimArray(messageGroup);
            });
        }
        static dispatchBroadcast(from) {
            SMS.messageGroups
                ?.forEach((messageGroup) => {
                const resolvedMessageIndexes = [];
                messageGroup
                    ?.forEach((message, valueIndex) => {
                    if (from != null
                        && message.from !== from) {
                        return;
                    }
                    if (message.to !== SMS.BROADCAST_CONTACT) {
                        return;
                    }
                    SMS.callbackGroups[SMS.BROADCAST_INDEX]
                        ?.forEach((callback) => {
                        callback(message);
                        resolvedMessageIndexes.push(valueIndex);
                    });
                });
                resolvedMessageIndexes.forEach((unneededIndex) => delete messageGroup[unneededIndex]);
                SMS.trimArray(messageGroup);
            });
        }
        static trimArray(array) {
            const referenceArray = [...array];
            // go from top to bottom of array
            // stop whenever it's not undefined anymore
            let i = 0;
            while (i < referenceArray.length
                && referenceArray[i] === undefined) {
                array.shift();
                ++i;
            }
            // go from bottom to top of array
            // stop whenever it's not undefined anymore
            let ii = array.length - 1;
            while (ii >= 0
                && referenceArray[ii] === undefined) {
                array.pop();
                --ii;
            }
        }
    }
    SMS.BROADCAST_CONTACT = new SMSContact('BROADCAST');
    SMS.BROADCAST_INDEX = 0;
    SMS.contacts = [
        SMS.BROADCAST_CONTACT,
    ];
    SMS.messageGroups = [
        [],
    ];
    SMS.callbackGroups = [
        [],
    ];

    var contacts = {
        RenderScene: new SMSContact(),
        DebugScene: new SMSContact(),
    };

    /* src\ui\blocks\Navigator.svelte generated by Svelte v3.24.1 */

    const { Object: Object_1$2 } = globals;
    const file$j = "src\\ui\\blocks\\Navigator.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (56:1) {:else}
    function create_else_block$4(ctx) {
    	let container1;
    	let container0;
    	let current;
    	let each_value = /*routeKeys*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			container1 = element("container");
    			container0 = element("container");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(container0, "class", "content svelte-130r1ee");
    			add_location(container0, file$j, 63, 3, 1524);
    			attr_dev(container1, "class", "bar svelte-130r1ee");
    			set_style(container1, "--width", "calc(" + CSSUtility.parse(/*barToppingWidth*/ ctx[2]) + " * " + /*routeKeys*/ ctx[8].length + ")");
    			set_style(container1, "--height", CSSUtility.parse(/*barToppingHeight*/ ctx[3]));
    			add_location(container1, file$j, 56, 2, 1339);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container1, anchor);
    			append_dev(container1, container0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(container0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*routeKeys, $location, href, routes*/ 1345) {
    				each_value = /*routeKeys*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(container0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*barToppingWidth*/ 4) {
    				set_style(container1, "--width", "calc(" + CSSUtility.parse(/*barToppingWidth*/ ctx[2]) + " * " + /*routeKeys*/ ctx[8].length + ")");
    			}

    			if (!current || dirty & /*barToppingHeight*/ 8) {
    				set_style(container1, "--height", CSSUtility.parse(/*barToppingHeight*/ ctx[3]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(56:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:1) {#if !isSalad}
    function create_if_block$6(ctx) {
    	let hamburger;
    	let current;
    	const hamburger_spread_levels = [{ toppings: /*toppings*/ ctx[9] }, /*hamburgerProps*/ ctx[4]];
    	let hamburger_props = {};

    	for (let i = 0; i < hamburger_spread_levels.length; i += 1) {
    		hamburger_props = assign(hamburger_props, hamburger_spread_levels[i]);
    	}

    	hamburger = new Hamburger({ props: hamburger_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(hamburger.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hamburger, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hamburger_changes = (dirty & /*toppings, hamburgerProps*/ 528)
    			? get_spread_update(hamburger_spread_levels, [
    					dirty & /*toppings*/ 512 && { toppings: /*toppings*/ ctx[9] },
    					dirty & /*hamburgerProps*/ 16 && get_spread_object(/*hamburgerProps*/ ctx[4])
    				])
    			: {};

    			hamburger.$set(hamburger_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hamburger.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hamburger.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hamburger, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(51:1) {#if !isSalad}",
    		ctx
    	});

    	return block;
    }

    // (68:5) <Button        on:click={() => href(routeKey)}        icon=''        backgroundColour='{         routeKey === $location          ? '--colour-background-primary'          : '#0000'        }'        textColour='--colour-text-primary'        hoverColour='--colour-background-secondary'        rippleColour='--colour-text-secondary'        width='100%'               >
    function create_default_slot$a(ctx) {
    	let t0_value = /*routes*/ ctx[0][/*routeKey*/ ctx[14]] + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			t1 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*routes*/ 1 && t0_value !== (t0_value = /*routes*/ ctx[0][/*routeKey*/ ctx[14]] + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(68:5) <Button        on:click={() => href(routeKey)}        icon=''        backgroundColour='{         routeKey === $location          ? '--colour-background-primary'          : '#0000'        }'        textColour='--colour-text-primary'        hoverColour='--colour-background-secondary'        rippleColour='--colour-text-secondary'        width='100%'               >",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#each routeKeys as routeKey}
    function create_each_block$2(ctx) {
    	let button;
    	let current;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[12](/*routeKey*/ ctx[14], ...args);
    	}

    	button = new Button({
    			props: {
    				icon: "",
    				backgroundColour: /*routeKey*/ ctx[14] === /*$location*/ ctx[6]
    				? "--colour-background-primary"
    				: "#0000",
    				textColour: "--colour-text-primary",
    				hoverColour: "--colour-background-secondary",
    				rippleColour: "--colour-text-secondary",
    				width: "100%",
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};

    			if (dirty & /*$location*/ 64) button_changes.backgroundColour = /*routeKey*/ ctx[14] === /*$location*/ ctx[6]
    			? "--colour-background-primary"
    			: "#0000";

    			if (dirty & /*$$scope, routes*/ 131073) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(67:4) {#each routeKeys as routeKey}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let component;
    	let current_block_type_index;
    	let if_block;
    	let component_class_value;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*isSalad*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			component = element("component");
    			if_block.c();
    			attr_dev(component, "class", component_class_value = "" + (null_to_empty(!/*isSalad*/ ctx[5] ? "hamburger" : "salad") + " svelte-130r1ee"));
    			set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[1]));
    			add_location(component, file$j, 44, 0, 1115);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			if_blocks[current_block_type_index].m(component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(component, null);
    			}

    			if (!current || dirty & /*isSalad*/ 32 && component_class_value !== (component_class_value = "" + (null_to_empty(!/*isSalad*/ ctx[5] ? "hamburger" : "salad") + " svelte-130r1ee"))) {
    				attr_dev(component, "class", component_class_value);
    			}

    			if (!current || dirty & /*backgroundColour*/ 2) {
    				set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $currentBreakpointWritable;
    	let $location;
    	validate_store(location, "location");
    	component_subscribe($$self, location, $$value => $$invalidate(6, $location = $$value));
    	let { isActiveWritable = writable(false) } = $$props;
    	let { routes = {} } = $$props;
    	let { backgroundColour = "--colour-background-primary" } = $$props;
    	let { barToppingWidth = 120 } = $$props;
    	let { barToppingHeight = "100%" } = $$props;
    	let { hamburgerProps = {} } = $$props;
    	const { currentBreakpointWritable } = ResponsiveUtility;
    	validate_store(currentBreakpointWritable, "currentBreakpointWritable");
    	component_subscribe($$self, currentBreakpointWritable, value => $$invalidate(13, $currentBreakpointWritable = value));
    	const routeKeys = Object.keys(routes);

    	const toppings = (() => {
    		const result = {};

    		routeKeys.forEach(route => {
    			result[routes[route]] = () => href(route);
    		});

    		return result;
    	})();

    	function href(destination) {
    		push(destination);
    		isActiveWritable.set(false);
    		window.scrollTo({ top: 0, left: 0, behavior: "smooth" });
    	}

    	const writable_props = [
    		"isActiveWritable",
    		"routes",
    		"backgroundColour",
    		"barToppingWidth",
    		"barToppingHeight",
    		"hamburgerProps"
    	];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navigator> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Navigator", $$slots, []);
    	const click_handler = routeKey => href(routeKey);

    	$$self.$$set = $$props => {
    		if ("isActiveWritable" in $$props) $$invalidate(11, isActiveWritable = $$props.isActiveWritable);
    		if ("routes" in $$props) $$invalidate(0, routes = $$props.routes);
    		if ("backgroundColour" in $$props) $$invalidate(1, backgroundColour = $$props.backgroundColour);
    		if ("barToppingWidth" in $$props) $$invalidate(2, barToppingWidth = $$props.barToppingWidth);
    		if ("barToppingHeight" in $$props) $$invalidate(3, barToppingHeight = $$props.barToppingHeight);
    		if ("hamburgerProps" in $$props) $$invalidate(4, hamburgerProps = $$props.hamburgerProps);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		push,
    		location,
    		ResponsiveUtility,
    		CSSUtility,
    		Button,
    		Hamburger,
    		isActiveWritable,
    		routes,
    		backgroundColour,
    		barToppingWidth,
    		barToppingHeight,
    		hamburgerProps,
    		currentBreakpointWritable,
    		routeKeys,
    		toppings,
    		href,
    		isSalad,
    		$currentBreakpointWritable,
    		$location
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActiveWritable" in $$props) $$invalidate(11, isActiveWritable = $$props.isActiveWritable);
    		if ("routes" in $$props) $$invalidate(0, routes = $$props.routes);
    		if ("backgroundColour" in $$props) $$invalidate(1, backgroundColour = $$props.backgroundColour);
    		if ("barToppingWidth" in $$props) $$invalidate(2, barToppingWidth = $$props.barToppingWidth);
    		if ("barToppingHeight" in $$props) $$invalidate(3, barToppingHeight = $$props.barToppingHeight);
    		if ("hamburgerProps" in $$props) $$invalidate(4, hamburgerProps = $$props.hamburgerProps);
    		if ("isSalad" in $$props) $$invalidate(5, isSalad = $$props.isSalad);
    	};

    	let isSalad;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$currentBreakpointWritable*/ 8192) {
    			 $$invalidate(5, isSalad = !($currentBreakpointWritable < ResponsiveUtility.Breakpoints.TABLET));
    		}
    	};

    	return [
    		routes,
    		backgroundColour,
    		barToppingWidth,
    		barToppingHeight,
    		hamburgerProps,
    		isSalad,
    		$location,
    		currentBreakpointWritable,
    		routeKeys,
    		toppings,
    		href,
    		isActiveWritable,
    		click_handler
    	];
    }

    class Navigator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			isActiveWritable: 11,
    			routes: 0,
    			backgroundColour: 1,
    			barToppingWidth: 2,
    			barToppingHeight: 3,
    			hamburgerProps: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigator",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get isActiveWritable() {
    		return this.$$.ctx[11];
    	}

    	set isActiveWritable(isActiveWritable) {
    		this.$set({ isActiveWritable });
    		flush();
    	}

    	get routes() {
    		return this.$$.ctx[0];
    	}

    	set routes(routes) {
    		this.$set({ routes });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[1];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get barToppingWidth() {
    		return this.$$.ctx[2];
    	}

    	set barToppingWidth(barToppingWidth) {
    		this.$set({ barToppingWidth });
    		flush();
    	}

    	get barToppingHeight() {
    		return this.$$.ctx[3];
    	}

    	set barToppingHeight(barToppingHeight) {
    		this.$set({ barToppingHeight });
    		flush();
    	}

    	get hamburgerProps() {
    		return this.$$.ctx[4];
    	}

    	set hamburgerProps(hamburgerProps) {
    		this.$set({ hamburgerProps });
    		flush();
    	}
    }

    /* src\ui\blocks\appBars\NavigatorAppBar.svelte generated by Svelte v3.24.1 */
    const file$k = "src\\ui\\blocks\\appBars\\NavigatorAppBar.svelte";

    // (13:0) <ScrollableAppBar   bind:baseHeightWritable   bind:scrolledHeightWritable   {...$$restProps}  >
    function create_default_slot$b(ctx) {
    	let container;
    	let navigator;
    	let current;

    	navigator = new Navigator({
    			props: {
    				routes: /*routes*/ ctx[2],
    				hamburgerProps: {
    					buttonSize: "calc(2rem + 32px)",
    					menuTopOffsetWritable: /*scrolledHeightWritable*/ ctx[1]
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			container = element("container");
    			create_component(navigator.$$.fragment);
    			attr_dev(container, "class", "svelte-nfnx3w");
    			add_location(container, file$k, 17, 1, 414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			mount_component(navigator, container, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navigator_changes = {};
    			if (dirty & /*routes*/ 4) navigator_changes.routes = /*routes*/ ctx[2];

    			if (dirty & /*scrolledHeightWritable*/ 2) navigator_changes.hamburgerProps = {
    				buttonSize: "calc(2rem + 32px)",
    				menuTopOffsetWritable: /*scrolledHeightWritable*/ ctx[1]
    			};

    			navigator.$set(navigator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navigator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navigator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			destroy_component(navigator);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(13:0) <ScrollableAppBar   bind:baseHeightWritable   bind:scrolledHeightWritable   {...$$restProps}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let scrollableappbar;
    	let updating_baseHeightWritable;
    	let updating_scrolledHeightWritable;
    	let current;
    	const scrollableappbar_spread_levels = [/*$$restProps*/ ctx[3]];

    	function scrollableappbar_baseHeightWritable_binding(value) {
    		/*scrollableappbar_baseHeightWritable_binding*/ ctx[4].call(null, value);
    	}

    	function scrollableappbar_scrolledHeightWritable_binding(value) {
    		/*scrollableappbar_scrolledHeightWritable_binding*/ ctx[5].call(null, value);
    	}

    	let scrollableappbar_props = {
    		$$slots: { default: [create_default_slot$b] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < scrollableappbar_spread_levels.length; i += 1) {
    		scrollableappbar_props = assign(scrollableappbar_props, scrollableappbar_spread_levels[i]);
    	}

    	if (/*baseHeightWritable*/ ctx[0] !== void 0) {
    		scrollableappbar_props.baseHeightWritable = /*baseHeightWritable*/ ctx[0];
    	}

    	if (/*scrolledHeightWritable*/ ctx[1] !== void 0) {
    		scrollableappbar_props.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    	}

    	scrollableappbar = new ScrollableAppBar({
    			props: scrollableappbar_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(scrollableappbar, "baseHeightWritable", scrollableappbar_baseHeightWritable_binding));
    	binding_callbacks.push(() => bind(scrollableappbar, "scrolledHeightWritable", scrollableappbar_scrolledHeightWritable_binding));

    	const block = {
    		c: function create() {
    			create_component(scrollableappbar.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrollableappbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scrollableappbar_changes = (dirty & /*$$restProps*/ 8)
    			? get_spread_update(scrollableappbar_spread_levels, [get_spread_object(/*$$restProps*/ ctx[3])])
    			: {};

    			if (dirty & /*$$scope, routes, scrolledHeightWritable*/ 70) {
    				scrollableappbar_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_baseHeightWritable && dirty & /*baseHeightWritable*/ 1) {
    				updating_baseHeightWritable = true;
    				scrollableappbar_changes.baseHeightWritable = /*baseHeightWritable*/ ctx[0];
    				add_flush_callback(() => updating_baseHeightWritable = false);
    			}

    			if (!updating_scrolledHeightWritable && dirty & /*scrolledHeightWritable*/ 2) {
    				updating_scrolledHeightWritable = true;
    				scrollableappbar_changes.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    				add_flush_callback(() => updating_scrolledHeightWritable = false);
    			}

    			scrollableappbar.$set(scrollableappbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrollableappbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrollableappbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrollableappbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	const omit_props_names = ["baseHeightWritable","scrolledHeightWritable","routes"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { baseHeightWritable = writable(0) } = $$props;
    	let { scrolledHeightWritable = writable(0) } = $$props;
    	let { routes = null } = $$props;
    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("NavigatorAppBar", $$slots, []);

    	function scrollableappbar_baseHeightWritable_binding(value) {
    		baseHeightWritable = value;
    		$$invalidate(0, baseHeightWritable);
    	}

    	function scrollableappbar_scrolledHeightWritable_binding(value) {
    		scrolledHeightWritable = value;
    		$$invalidate(1, scrolledHeightWritable);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("baseHeightWritable" in $$new_props) $$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable);
    		if ("scrolledHeightWritable" in $$new_props) $$invalidate(1, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("routes" in $$new_props) $$invalidate(2, routes = $$new_props.routes);
    	};

    	$$self.$capture_state = () => ({
    		writable,
    		ScrollableAppBar,
    		Navigator,
    		baseHeightWritable,
    		scrolledHeightWritable,
    		routes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("baseHeightWritable" in $$props) $$invalidate(0, baseHeightWritable = $$new_props.baseHeightWritable);
    		if ("scrolledHeightWritable" in $$props) $$invalidate(1, scrolledHeightWritable = $$new_props.scrolledHeightWritable);
    		if ("routes" in $$props) $$invalidate(2, routes = $$new_props.routes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		baseHeightWritable,
    		scrolledHeightWritable,
    		routes,
    		$$restProps,
    		scrollableappbar_baseHeightWritable_binding,
    		scrollableappbar_scrolledHeightWritable_binding
    	];
    }

    class NavigatorAppBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			baseHeightWritable: 0,
    			scrolledHeightWritable: 1,
    			routes: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavigatorAppBar",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get baseHeightWritable() {
    		return this.$$.ctx[0];
    	}

    	set baseHeightWritable(baseHeightWritable) {
    		this.$set({ baseHeightWritable });
    		flush();
    	}

    	get scrolledHeightWritable() {
    		return this.$$.ctx[1];
    	}

    	set scrolledHeightWritable(scrolledHeightWritable) {
    		this.$set({ scrolledHeightWritable });
    		flush();
    	}

    	get routes() {
    		return this.$$.ctx[2];
    	}

    	set routes(routes) {
    		this.$set({ routes });
    		flush();
    	}
    }

    /* src\ui\blocks\Card.svelte generated by Svelte v3.24.1 */
    const file$l = "src\\ui\\blocks\\Card.svelte";

    // (41:1) <Scene    backgroundColour='transparent'    height='100%'    width='100%'    {...$$restProps}   >
    function create_default_slot$c(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32768) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(41:1) <Scene    backgroundColour='transparent'    height='100%'    width='100%'    {...$$restProps}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let component;
    	let scene;
    	let current;

    	const scene_spread_levels = [
    		{ backgroundColour: "transparent" },
    		{ height: "100%" },
    		{ width: "100%" },
    		/*$$restProps*/ ctx[9]
    	];

    	let scene_props = {
    		$$slots: { default: [create_default_slot$c] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < scene_spread_levels.length; i += 1) {
    		scene_props = assign(scene_props, scene_spread_levels[i]);
    	}

    	scene = new Scene({ props: scene_props, $$inline: true });

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(scene.$$.fragment);
    			set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[0]));
    			set_style(component, "--colour-hover", CSSUtility.parse(/*hoverColour*/ ctx[1]));
    			set_style(component, "--height", CSSUtility.parse(/*$heightWritable*/ ctx[7]));
    			set_style(component, "--width", CSSUtility.parse(/*$widthWritable*/ ctx[8]));

    			set_style(component, "--box-shadow", /*isFloatingInverted*/ ctx[3]
    			? "var(--shadow)"
    			: "var(--shadow-inactive)");

    			set_style(component, "--active-box-shadow", /*isFloatingInverted*/ ctx[3]
    			? "var(--shadow-inactive)"
    			: "var(--shadow)");

    			set_style(component, "--card-roundness", CSSUtility.parse(/*roundness*/ ctx[2]));
    			attr_dev(component, "class", "svelte-8idjyq");
    			add_location(component, file$l, 28, 0, 739);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(scene, component, null);
    			/*component_binding*/ ctx[14](component);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scene_changes = (dirty & /*$$restProps*/ 512)
    			? get_spread_update(scene_spread_levels, [
    					scene_spread_levels[0],
    					scene_spread_levels[1],
    					scene_spread_levels[2],
    					get_spread_object(/*$$restProps*/ ctx[9])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 32768) {
    				scene_changes.$$scope = { dirty, ctx };
    			}

    			scene.$set(scene_changes);

    			if (!current || dirty & /*backgroundColour*/ 1) {
    				set_style(component, "--colour-background", CSSUtility.parse(/*backgroundColour*/ ctx[0]));
    			}

    			if (!current || dirty & /*hoverColour*/ 2) {
    				set_style(component, "--colour-hover", CSSUtility.parse(/*hoverColour*/ ctx[1]));
    			}

    			if (!current || dirty & /*$heightWritable*/ 128) {
    				set_style(component, "--height", CSSUtility.parse(/*$heightWritable*/ ctx[7]));
    			}

    			if (!current || dirty & /*$widthWritable*/ 256) {
    				set_style(component, "--width", CSSUtility.parse(/*$widthWritable*/ ctx[8]));
    			}

    			if (!current || dirty & /*isFloatingInverted*/ 8) {
    				set_style(component, "--box-shadow", /*isFloatingInverted*/ ctx[3]
    				? "var(--shadow)"
    				: "var(--shadow-inactive)");
    			}

    			if (!current || dirty & /*isFloatingInverted*/ 8) {
    				set_style(component, "--active-box-shadow", /*isFloatingInverted*/ ctx[3]
    				? "var(--shadow-inactive)"
    				: "var(--shadow)");
    			}

    			if (!current || dirty & /*roundness*/ 4) {
    				set_style(component, "--card-roundness", CSSUtility.parse(/*roundness*/ ctx[2]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scene.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scene.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_component(scene);
    			/*component_binding*/ ctx[14](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"depth","backgroundColour","hoverColour","roundness","isFloatingInverted","height","width","heightWritable","widthWritable"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);

    	let $heightWritable,
    		$$unsubscribe_heightWritable = noop,
    		$$subscribe_heightWritable = () => ($$unsubscribe_heightWritable(), $$unsubscribe_heightWritable = subscribe(heightWritable, $$value => $$invalidate(7, $heightWritable = $$value)), heightWritable);

    	let $widthWritable,
    		$$unsubscribe_widthWritable = noop,
    		$$subscribe_widthWritable = () => ($$unsubscribe_widthWritable(), $$unsubscribe_widthWritable = subscribe(widthWritable, $$value => $$invalidate(8, $widthWritable = $$value)), widthWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_heightWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_widthWritable());
    	let { depth = 3 } = $$props;
    	let { backgroundColour = "--colour-background-secondary" } = $$props;
    	let { hoverColour = "--colour-accent-primary" } = $$props;
    	let { roundness = "--roundness" } = $$props;
    	let { isFloatingInverted = false } = $$props;
    	let { height = "auto" } = $$props;
    	let { width = "auto" } = $$props;
    	let { heightWritable = writable(height) } = $$props;
    	validate_store(heightWritable, "heightWritable");
    	$$subscribe_heightWritable();
    	let { widthWritable = writable(width) } = $$props;
    	validate_store(widthWritable, "widthWritable");
    	$$subscribe_widthWritable();
    	let componentDomContent = null;

    	onMount(() => {
    		Shadow.apply(depth, componentDomContent);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Card", $$slots, ['default']);

    	function component_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			componentDomContent = $$value;
    			$$invalidate(6, componentDomContent);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("depth" in $$new_props) $$invalidate(10, depth = $$new_props.depth);
    		if ("backgroundColour" in $$new_props) $$invalidate(0, backgroundColour = $$new_props.backgroundColour);
    		if ("hoverColour" in $$new_props) $$invalidate(1, hoverColour = $$new_props.hoverColour);
    		if ("roundness" in $$new_props) $$invalidate(2, roundness = $$new_props.roundness);
    		if ("isFloatingInverted" in $$new_props) $$invalidate(3, isFloatingInverted = $$new_props.isFloatingInverted);
    		if ("height" in $$new_props) $$invalidate(11, height = $$new_props.height);
    		if ("width" in $$new_props) $$invalidate(12, width = $$new_props.width);
    		if ("heightWritable" in $$new_props) $$subscribe_heightWritable($$invalidate(4, heightWritable = $$new_props.heightWritable));
    		if ("widthWritable" in $$new_props) $$subscribe_widthWritable($$invalidate(5, widthWritable = $$new_props.widthWritable));
    		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		writable,
    		Shadow,
    		CSSUtility,
    		Scene,
    		depth,
    		backgroundColour,
    		hoverColour,
    		roundness,
    		isFloatingInverted,
    		height,
    		width,
    		heightWritable,
    		widthWritable,
    		componentDomContent,
    		$heightWritable,
    		$widthWritable
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("depth" in $$props) $$invalidate(10, depth = $$new_props.depth);
    		if ("backgroundColour" in $$props) $$invalidate(0, backgroundColour = $$new_props.backgroundColour);
    		if ("hoverColour" in $$props) $$invalidate(1, hoverColour = $$new_props.hoverColour);
    		if ("roundness" in $$props) $$invalidate(2, roundness = $$new_props.roundness);
    		if ("isFloatingInverted" in $$props) $$invalidate(3, isFloatingInverted = $$new_props.isFloatingInverted);
    		if ("height" in $$props) $$invalidate(11, height = $$new_props.height);
    		if ("width" in $$props) $$invalidate(12, width = $$new_props.width);
    		if ("heightWritable" in $$props) $$subscribe_heightWritable($$invalidate(4, heightWritable = $$new_props.heightWritable));
    		if ("widthWritable" in $$props) $$subscribe_widthWritable($$invalidate(5, widthWritable = $$new_props.widthWritable));
    		if ("componentDomContent" in $$props) $$invalidate(6, componentDomContent = $$new_props.componentDomContent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		backgroundColour,
    		hoverColour,
    		roundness,
    		isFloatingInverted,
    		heightWritable,
    		widthWritable,
    		componentDomContent,
    		$heightWritable,
    		$widthWritable,
    		$$restProps,
    		depth,
    		height,
    		width,
    		$$slots,
    		component_binding,
    		$$scope
    	];
    }

    class Card extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			depth: 10,
    			backgroundColour: 0,
    			hoverColour: 1,
    			roundness: 2,
    			isFloatingInverted: 3,
    			height: 11,
    			width: 12,
    			heightWritable: 4,
    			widthWritable: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Card",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get depth() {
    		return this.$$.ctx[10];
    	}

    	set depth(depth) {
    		this.$set({ depth });
    		flush();
    	}

    	get backgroundColour() {
    		return this.$$.ctx[0];
    	}

    	set backgroundColour(backgroundColour) {
    		this.$set({ backgroundColour });
    		flush();
    	}

    	get hoverColour() {
    		return this.$$.ctx[1];
    	}

    	set hoverColour(hoverColour) {
    		this.$set({ hoverColour });
    		flush();
    	}

    	get roundness() {
    		return this.$$.ctx[2];
    	}

    	set roundness(roundness) {
    		this.$set({ roundness });
    		flush();
    	}

    	get isFloatingInverted() {
    		return this.$$.ctx[3];
    	}

    	set isFloatingInverted(isFloatingInverted) {
    		this.$set({ isFloatingInverted });
    		flush();
    	}

    	get height() {
    		return this.$$.ctx[11];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[12];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get heightWritable() {
    		return this.$$.ctx[4];
    	}

    	set heightWritable(heightWritable) {
    		this.$set({ heightWritable });
    		flush();
    	}

    	get widthWritable() {
    		return this.$$.ctx[5];
    	}

    	set widthWritable(widthWritable) {
    		this.$set({ widthWritable });
    		flush();
    	}
    }

    /* src\ui\components\Terminal.svelte generated by Svelte v3.24.1 */
    const file$m = "src\\ui\\components\\Terminal.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i].string;
    	child_ctx[24] = list[i].tag;
    	child_ctx[25] = list[i].colour;
    	return child_ctx;
    }

    // (234:5) {#each outputLines as { string, tag, colour }}
    function create_each_block$3(ctx) {
    	let string;

    	let t0_value = (/*tag*/ ctx[24] == null
    	? /*string*/ ctx[23]
    	: `${/*tag*/ ctx[24]}: ${/*string*/ ctx[23]}`) + "";

    	let t0;
    	let t1;
    	let string_style_value;

    	const block = {
    		c: function create() {
    			string = element("string");
    			t0 = text(t0_value);
    			t1 = space();

    			attr_dev(string, "style", string_style_value = /*colour*/ ctx[25]
    			? `color: var(${/*colour*/ ctx[25]})`
    			: "");

    			attr_dev(string, "class", "svelte-qd3a47");
    			add_location(string, file$m, 234, 6, 5970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, string, anchor);
    			append_dev(string, t0);
    			append_dev(string, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*outputLines*/ 8 && t0_value !== (t0_value = (/*tag*/ ctx[24] == null
    			? /*string*/ ctx[23]
    			: `${/*tag*/ ctx[24]}: ${/*string*/ ctx[23]}`) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*outputLines*/ 8 && string_style_value !== (string_style_value = /*colour*/ ctx[25]
    			? `color: var(${/*colour*/ ctx[25]})`
    			: "")) {
    				attr_dev(string, "style", string_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(string);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(234:5) {#each outputLines as { string, tag, colour }}",
    		ctx
    	});

    	return block;
    }

    // (253:5) <container        slot='button'        style='         flex-shrink: 0;         flex-grow: 0;        '       >
    function create_button_slot(ctx) {
    	let container;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				height: "100%",
    				width: "100%",
    				roundness: "0",
    				icon: "arrow_forward"
    			},
    			$$inline: true
    		});

    	button.$on("click", function () {
    		if (is_function(/*submit*/ ctx[22])) /*submit*/ ctx[22].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			container = element("container");
    			create_component(button.$$.fragment);
    			attr_dev(container, "slot", "button");
    			set_style(container, "flex-shrink", "0");
    			set_style(container, "flex-grow", "0");
    			add_location(container, file$m, 252, 5, 6504);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container, anchor);
    			mount_component(button, container, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 268435456) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_button_slot.name,
    		type: "slot",
    		source: "(253:5) <container        slot='button'        style='         flex-shrink: 0;         flex-grow: 0;        '       >",
    		ctx
    	});

    	return block;
    }

    // (188:1) <Card    isPadded={false}    isInAnimated={false}    isOutAnimated={false}    isFloatingInverted={true}    backgroundColour='transparent'    hoverColour='transparent'    width='100%'    height='100%'    roundness='0'   >
    function create_default_slot$d(ctx) {
    	let container3;
    	let container1;
    	let container0;
    	let t;
    	let container2;
    	let input;
    	let current;
    	let each_value = /*outputLines*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	input = new Input({
    			props: {
    				label: ">>>",
    				backgroundColour: "--colour-text-secondary",
    				activeBackgroundColour: "--colour-text-primary",
    				textColour: "--colour-background-primary",
    				labelColour: "--colour-background-secondary",
    				floatingLabelIndent: "--indent",
    				roundness: "0",
    				$$slots: {
    					button: [
    						create_button_slot,
    						({ submit }) => ({ 22: submit }),
    						({ submit }) => submit ? 4194304 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	input.$on("submit", /*onSubmit*/ ctx[6]);

    	const block = {
    		c: function create() {
    			container3 = element("container");
    			container1 = element("container");
    			container0 = element("container");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			container2 = element("container");
    			create_component(input.$$.fragment);
    			attr_dev(container0, "class", "output svelte-qd3a47");
    			add_location(container0, file$m, 229, 4, 5836);
    			attr_dev(container1, "class", "window");
    			add_location(container1, file$m, 226, 3, 5794);
    			add_location(container2, file$m, 240, 3, 6148);
    			attr_dev(container3, "class", "content svelte-qd3a47");
    			set_style(container3, "--height", CSSUtility.parse(/*$heightWritable*/ ctx[5]) + "\r\n\t\t\t");
    			add_location(container3, file$m, 198, 2, 5261);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, container3, anchor);
    			append_dev(container3, container1);
    			append_dev(container1, container0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(container0, null);
    			}

    			/*container0_binding*/ ctx[9](container0);
    			append_dev(container3, t);
    			append_dev(container3, container2);
    			mount_component(input, container2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*outputLines*/ 8) {
    				each_value = /*outputLines*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(container0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const input_changes = {};

    			if (dirty & /*$$scope, submit*/ 272629760) {
    				input_changes.$$scope = { dirty, ctx };
    			}

    			input.$set(input_changes);

    			if (!current || dirty & /*$heightWritable*/ 32) {
    				set_style(container3, "--height", CSSUtility.parse(/*$heightWritable*/ ctx[5]) + "\r\n\t\t\t");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(container3);
    			destroy_each(each_blocks, detaching);
    			/*container0_binding*/ ctx[9](null);
    			destroy_component(input);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(188:1) <Card    isPadded={false}    isInAnimated={false}    isOutAnimated={false}    isFloatingInverted={true}    backgroundColour='transparent'    hoverColour='transparent'    width='100%'    height='100%'    roundness='0'   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let component;
    	let card;
    	let current;

    	card = new Card({
    			props: {
    				isPadded: false,
    				isInAnimated: false,
    				isOutAnimated: false,
    				isFloatingInverted: true,
    				backgroundColour: "transparent",
    				hoverColour: "transparent",
    				width: "100%",
    				height: "100%",
    				roundness: "0",
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			component = element("component");
    			create_component(card.$$.fragment);
    			set_style(component, "--width", CSSUtility.parse(/*$widthWritable*/ ctx[4]) + "\r\n\t");
    			attr_dev(component, "class", "svelte-qd3a47");
    			add_location(component, file$m, 182, 0, 4960);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);
    			mount_component(card, component, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const card_changes = {};

    			if (dirty & /*$$scope, $heightWritable, outputDomContent, outputLines*/ 268435500) {
    				card_changes.$$scope = { dirty, ctx };
    			}

    			card.$set(card_changes);

    			if (!current || dirty & /*$widthWritable*/ 16) {
    				set_style(component, "--width", CSSUtility.parse(/*$widthWritable*/ ctx[4]) + "\r\n\t");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(card.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(card.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_component(card);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function die() {
    	// // exit page if there's history
    	// for (let i = 0, l = window.history.length; i < l; ++i) {
    	// 	window.history.back();
    	// }
    	// for (let i = 0, l = window.history.length; i < l; ++i) {
    	// 	window.history.forward();
    	// }
    	// clear page instead if there's no history
    	document.documentElement.innerHTML = "<body style=\"margin:0; height: 100%; width: 100%; display: flex; align-items: center; justify-content: center; user-select: none; cursor: crosshair\"><h1 onclick=\"window.location.reload()\">💀</h1></body>";

    	document.documentElement.style = "height: 100%";
    	document.title = "??";
    }

    function encodeString(string) {
    	let result = "";
    	let charCode = 0;
    	const PREFIX = String.fromCharCode(string.length + 1000);
    	const SHIFT_NUMBER = 20;

    	for (let i = 0, l = string.length; i < l; ++i) {
    		charCode = string[i].charCodeAt() + SHIFT_NUMBER;
    		result += String.fromCharCode(charCode);
    	}

    	return PREFIX + result;
    }

    function decodeString(string) {
    	if (string.charCodeAt(0) !== string.length - 1 + 1000) {
    		return string;
    	}

    	const unprefixedString = string.substr(1);
    	let result = "";
    	let charCode = 0;
    	const SHIFT_NUMBER = 20;

    	for (let i = 0, l = unprefixedString.length; i < l; ++i) {
    		charCode = unprefixedString[i].charCodeAt() - SHIFT_NUMBER;
    		result += String.fromCharCode(charCode);
    	}

    	return result;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $widthWritable,
    		$$unsubscribe_widthWritable = noop,
    		$$subscribe_widthWritable = () => ($$unsubscribe_widthWritable(), $$unsubscribe_widthWritable = subscribe(widthWritable, $$value => $$invalidate(4, $widthWritable = $$value)), widthWritable);

    	let $heightWritable,
    		$$unsubscribe_heightWritable = noop,
    		$$subscribe_heightWritable = () => ($$unsubscribe_heightWritable(), $$unsubscribe_heightWritable = subscribe(heightWritable, $$value => $$invalidate(5, $heightWritable = $$value)), heightWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_widthWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_heightWritable());
    	let { height = "auto" } = $$props;
    	let { width = "100%" } = $$props;
    	let { heightWritable = writable(height) } = $$props;
    	validate_store(heightWritable, "heightWritable");
    	$$subscribe_heightWritable();
    	let { widthWritable = writable(width) } = $$props;
    	validate_store(widthWritable, "widthWritable");
    	$$subscribe_widthWritable();

    	/** @type HTMLElement */
    	let outputDomContent = null;

    	const user = navigator.userAgent.substring(navigator.userAgent.indexOf("(") + 1, navigator.userAgent.indexOf(";")).replace(/ /g, "-").toLowerCase();
    	const tld = window.location.href.substring(window.location.href.indexOf("//") + 2, window.location.href.replace("//", "__").indexOf("/"));
    	const windowTitle = `${user}@${tld}`;
    	const initModuleName = `${tld.replace(/[.:]/g, "-")}-core`;
    	const { info, warn, error } = strings.ui.components.terminal;

    	/** @type {{ string: string, colour: string, tag: string }[]} */
    	let outputLines = [];

    	function pushDefault(string) {
    		$$invalidate(3, outputLines = [...outputLines, { tag: null, string, colour: null }]);
    	}

    	function pushLoad(string) {
    		$$invalidate(3, outputLines = [
    			...outputLines,
    			{
    				tag: info.prefix.LOAD,
    				string,
    				colour: "--colour-ok-primary"
    			}
    		]);
    	}

    	function pushError(string) {
    		$$invalidate(3, outputLines = [
    			...outputLines,
    			{
    				tag: info.prefix.ERROR,
    				string,
    				colour: "--colour-error-primary"
    			}
    		]);
    	}

    	onMount(async () => {
    		await new Promise(resolve => setTimeout(resolve, 300));
    		output("init");
    	});

    	async function onSubmit({ detail: valueWritable }) {
    		/** @type string */
    		const value = get_store_value(valueWritable);

    		const decodedString = decodeString(value);
    		const encodedString = encodeString(decodedString);
    		valueWritable.set(encodedString);
    		output(decodedString, value);
    		await new Promise(resolve => setTimeout(resolve, 100));
    		valueWritable.set("");
    	}

    	function getOutputResponse(command) {
    		const args = command.split(" ");
    		const [program, ...parameters] = args;

    		switch (program) {
    			case "hello":
    				return ["🙃"];
    			case "die":
    				return ["💔", 500, "🔪", 200, die];
    			case "init":
    				return [200, () => pushLoad(initModuleName), 500];
    			case "echo":
    				return [parameters.join(" ")];
    			case "exit":
    				return [warn.COMMAND_NOT_RECOGNIZED.replace("%1", "escape")];
    			case "cls":
    				return [
    					() => {
    						$$invalidate(2, outputDomContent.textContent = "", outputDomContent); // () => pushError(error.FAKE.replace('%1', initModuleName))
    					}
    				];
    			case "":
    				return [""];
    			default:
    				return [warn.COMMAND_NOT_RECOGNIZED.replace("%1", program)];
    		}
    	}

    	async function output(command, rawValue = command) {
    		if (typeof command !== "string") {
    			return;
    		}

    		const prefix = windowTitle;
    		const response = getOutputResponse(command);

    		// response.push('\n');
    		pushDefault(`${prefix}:~$ ${rawValue}`);

    		// eslint-disable-next-line no-restricted-syntax
    		for (const item of response) {
    			switch (typeof item) {
    				case "string":
    					if (item.length === 0) {
    						break;
    					}
    					pushDefault(item);
    					break;
    				case "function":
    					output(item());
    					continue;
    				case "number":
    					await new Promise(resolve => setTimeout(resolve, item));
    					continue;
    			}
    		}
    	}

    	const writable_props = ["height", "width", "heightWritable", "widthWritable"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Terminal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Terminal", $$slots, []);

    	function container0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			outputDomContent = $$value;
    			$$invalidate(2, outputDomContent);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("height" in $$props) $$invalidate(7, height = $$props.height);
    		if ("width" in $$props) $$invalidate(8, width = $$props.width);
    		if ("heightWritable" in $$props) $$subscribe_heightWritable($$invalidate(0, heightWritable = $$props.heightWritable));
    		if ("widthWritable" in $$props) $$subscribe_widthWritable($$invalidate(1, widthWritable = $$props.widthWritable));
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		writable,
    		getWritableValue: get_store_value,
    		strings,
    		CSSUtility,
    		Button,
    		Card,
    		Input,
    		height,
    		width,
    		heightWritable,
    		widthWritable,
    		outputDomContent,
    		user,
    		tld,
    		windowTitle,
    		initModuleName,
    		info,
    		warn,
    		error,
    		outputLines,
    		pushDefault,
    		pushLoad,
    		pushError,
    		onSubmit,
    		die,
    		getOutputResponse,
    		output,
    		encodeString,
    		decodeString,
    		$widthWritable,
    		$heightWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(7, height = $$props.height);
    		if ("width" in $$props) $$invalidate(8, width = $$props.width);
    		if ("heightWritable" in $$props) $$subscribe_heightWritable($$invalidate(0, heightWritable = $$props.heightWritable));
    		if ("widthWritable" in $$props) $$subscribe_widthWritable($$invalidate(1, widthWritable = $$props.widthWritable));
    		if ("outputDomContent" in $$props) $$invalidate(2, outputDomContent = $$props.outputDomContent);
    		if ("outputLines" in $$props) $$invalidate(3, outputLines = $$props.outputLines);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		heightWritable,
    		widthWritable,
    		outputDomContent,
    		outputLines,
    		$widthWritable,
    		$heightWritable,
    		onSubmit,
    		height,
    		width,
    		container0_binding
    	];
    }

    class Terminal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			height: 7,
    			width: 8,
    			heightWritable: 0,
    			widthWritable: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Terminal",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get height() {
    		return this.$$.ctx[7];
    	}

    	set height(height) {
    		this.$set({ height });
    		flush();
    	}

    	get width() {
    		return this.$$.ctx[8];
    	}

    	set width(width) {
    		this.$set({ width });
    		flush();
    	}

    	get heightWritable() {
    		return this.$$.ctx[0];
    	}

    	set heightWritable(heightWritable) {
    		this.$set({ heightWritable });
    		flush();
    	}

    	get widthWritable() {
    		return this.$$.ctx[1];
    	}

    	set widthWritable(widthWritable) {
    		this.$set({ widthWritable });
    		flush();
    	}
    }

    function ccw(x1, y1, x2, y2, x3, y3) {           
        const cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));
        return cw > 0 ? true : cw < 0 ? false : true; // colinear
    }

    function intersect(seg1, seg2) {
      const x1 = seg1[0][0], y1 = seg1[0][1],
          x2 = seg1[1][0], y2 = seg1[1][1],
          x3 = seg2[0][0], y3 = seg2[0][1],
          x4 = seg2[1][0], y4 = seg2[1][1];

        return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);
    }

    var intersect_1 = intersect;

    function Grid(points, cellSize) {
        this._cells = [];
        this._cellSize = cellSize;
        this._reverseCellSize = 1 / cellSize;

        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            const x = this.coordToCellNum(point[0]);
            const y = this.coordToCellNum(point[1]);
            if (!this._cells[x]) {
                const array = [];
                array[y] = [point];
                this._cells[x] = array;
            } else if (!this._cells[x][y]) {
                this._cells[x][y] = [point];
            } else {
                this._cells[x][y].push(point);
            }
        }
    }

    Grid.prototype = {
        cellPoints: function(x, y) { // (Number, Number) -> Array
            return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];
        },

        rangePoints: function(bbox) { // (Array) -> Array
            const tlCellX = this.coordToCellNum(bbox[0]);
            const tlCellY = this.coordToCellNum(bbox[1]);
            const brCellX = this.coordToCellNum(bbox[2]);
            const brCellY = this.coordToCellNum(bbox[3]);
            const points = [];

            for (let x = tlCellX; x <= brCellX; x++) {
                for (let y = tlCellY; y <= brCellY; y++) {
                    // replaced Array.prototype.push.apply to avoid hitting stack size limit on larger arrays.
                    for (let i = 0; i < this.cellPoints(x, y).length; i++) {
                        points.push(this.cellPoints(x, y)[i]);
                    }
                }
            }

            return points;
        },

        removePoint: function(point) { // (Array) -> Array
            const cellX = this.coordToCellNum(point[0]);
            const cellY = this.coordToCellNum(point[1]);
            const cell = this._cells[cellX][cellY];
            let pointIdxInCell;

            for (let i = 0; i < cell.length; i++) {
                if (cell[i][0] === point[0] && cell[i][1] === point[1]) {
                    pointIdxInCell = i;
                    break;
                }
            }

            cell.splice(pointIdxInCell, 1);

            return cell;
        },

        trunc: Math.trunc || function(val) { // (number) -> number
            return val - val % 1;
        },

        coordToCellNum: function(x) { // (number) -> number
            return this.trunc(x * this._reverseCellSize);
        },

        extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array
            return [
                bbox[0] - (scaleFactor * this._cellSize),
                bbox[1] - (scaleFactor * this._cellSize),
                bbox[2] + (scaleFactor * this._cellSize),
                bbox[3] + (scaleFactor * this._cellSize)
            ];
        }
    };

    function grid(points, cellSize) {
        return new Grid(points, cellSize);
    }

    var grid_1 = grid;

    var format = {

        toXy: function(pointset, format) {
            if (format === undefined) {
                return pointset.slice();
            }
            return pointset.map(function(pt) {
                /*jslint evil: true */
                const _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');
                return _getXY(pt);
            });
        },

        fromXy: function(pointset, format) {
            if (format === undefined) {
                return pointset.slice();
            }
            return pointset.map(function(pt) {
                /*jslint evil: true */
                const _getObj = new Function('pt', 'const o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');
                return _getObj(pt);
            });
        }

    };

    function _cross(o, a, b) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }

    function _upperTangent(pointset) {
        const lower = [];
        for (let l = 0; l < pointset.length; l++) {
            while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {
                lower.pop();
            }
            lower.push(pointset[l]);
        }
        lower.pop();
        return lower;
    }

    function _lowerTangent(pointset) {
        const reversed = pointset.reverse(),
            upper = [];
        for (let u = 0; u < reversed.length; u++) {
            while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {
                upper.pop();
            }
            upper.push(reversed[u]);
        }
        upper.pop();
        return upper;
    }

    // pointset has to be sorted by X
    function convex(pointset) {
        const upper = _upperTangent(pointset),
              lower = _lowerTangent(pointset);
        const convex = lower.concat(upper);
        convex.push(pointset[0]);  
        return convex;  
    }

    var convex_1 = convex;

    function _filterDuplicates(pointset) {
        const unique = [pointset[0]];
        let lastPoint = pointset[0];
        for (let i = 1; i < pointset.length; i++) {
            const currentPoint = pointset[i];
            if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
                unique.push(currentPoint);
            }
            lastPoint = currentPoint;
        }
        return unique;
    }

    function _sortByX(pointset) {
        return pointset.sort(function(a, b) {
            return (a[0] - b[0]) || (a[1] - b[1]);
        });
    }

    function _sqLength(a, b) {
        return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);
    }

    function _cos(o, a, b) {
        const aShifted = [a[0] - o[0], a[1] - o[1]],
            bShifted = [b[0] - o[0], b[1] - o[1]],
            sqALen = _sqLength(o, a),
            sqBLen = _sqLength(o, b),
            dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];

        return dot / Math.sqrt(sqALen * sqBLen);
    }

    function _intersect(segment, pointset) {
        for (let i = 0; i < pointset.length - 1; i++) {
            const seg = [pointset[i], pointset[i + 1]];
            if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||
                segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
                continue;
            }
            if (intersect_1(segment, seg)) {
                return true;
            }
        }
        return false;
    }

    function _occupiedArea(pointset) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = pointset.length - 1; i >= 0; i--) {
            if (pointset[i][0] < minX) {
                minX = pointset[i][0];
            }
            if (pointset[i][1] < minY) {
                minY = pointset[i][1];
            }
            if (pointset[i][0] > maxX) {
                maxX = pointset[i][0];
            }
            if (pointset[i][1] > maxY) {
                maxY = pointset[i][1];
            }
        }

        return [
            maxX - minX, // width
            maxY - minY  // height
        ];
    }

    function _bBoxAround(edge) {
        return [
            Math.min(edge[0][0], edge[1][0]), // left
            Math.min(edge[0][1], edge[1][1]), // top
            Math.max(edge[0][0], edge[1][0]), // right
            Math.max(edge[0][1], edge[1][1])  // bottom
        ];
    }

    function _midPoint(edge, innerPoints, convex) {
        let point = null,
            angle1Cos = MAX_CONCAVE_ANGLE_COS,
            angle2Cos = MAX_CONCAVE_ANGLE_COS,
            a1Cos, a2Cos;

        for (let i = 0; i < innerPoints.length; i++) {
            a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
            a2Cos = _cos(edge[1], edge[0], innerPoints[i]);

            if (a1Cos > angle1Cos && a2Cos > angle2Cos &&
                !_intersect([edge[0], innerPoints[i]], convex) &&
                !_intersect([edge[1], innerPoints[i]], convex)) {

                angle1Cos = a1Cos;
                angle2Cos = a2Cos;
                point = innerPoints[i];
            }
        }

        return point;
    }

    function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {
        let midPointInserted = false;

        for (let i = 0; i < convex.length - 1; i++) {
            const edge = [convex[i], convex[i + 1]];
            // generate a key in the format X0,Y0,X1,Y1
            const keyInSkipList = edge[0][0] + ',' + edge[0][1] + ',' + edge[1][0] + ',' + edge[1][1];

            if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||
                edgeSkipList.has(keyInSkipList)) { continue; }

            let scaleFactor = 0;
            let bBoxAround = _bBoxAround(edge);
            let bBoxWidth;
            let bBoxHeight;
            let midPoint;
            do {
                bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);
                bBoxWidth = bBoxAround[2] - bBoxAround[0];
                bBoxHeight = bBoxAround[3] - bBoxAround[1];

                midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);
                scaleFactor++;
            }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));

            if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
                edgeSkipList.add(keyInSkipList);
            }

            if (midPoint !== null) {
                convex.splice(i + 1, 0, midPoint);
                grid.removePoint(midPoint);
                midPointInserted = true;
            }
        }

        if (midPointInserted) {
            return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);
        }

        return convex;
    }

    function hull(pointset, concavity, format$1) {
        let maxEdgeLen = concavity || 20;

        const points = _filterDuplicates(_sortByX(format.toXy(pointset, format$1)));

        if (points.length < 4) {
            return points.concat([points[0]]);
        }

        const occupiedArea = _occupiedArea(points);
        const maxSearchArea = [
            occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
            occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
        ];

        const convex = convex_1(points);
        const innerPoints = points.filter(function(pt) {
            return convex.indexOf(pt) < 0;
        });

        const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));

        const concave = _concave(
            convex, Math.pow(maxEdgeLen, 2),
            maxSearchArea, grid_1(innerPoints, cellSize), new Set());

        if (format$1) {
            return format.fromXy(concave, format$1);
        } else {
            return concave;
        }
    }

    const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg
    const MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;

    var hull_1 = hull;

    /* src\ui\components\Collage.svelte generated by Svelte v3.24.1 */

    const { Error: Error_1$1, console: console_1$1 } = globals;
    const file$n = "src\\ui\\components\\Collage.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (346:1) {#each gridCSS as gridCSSPart, i}
    function create_each_block$4(ctx) {
    	let div;
    	let div_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "style", div_style_value = "" + (/*zIndexCSS*/ ctx[2][/*i*/ ctx[12]] + ";" + /*gridCSSPart*/ ctx[10] + ";" + /*clipPathCSS*/ ctx[1][/*i*/ ctx[12]] + ";background: #" + (/*i*/ ctx[12] * 3).toString().padStart(3, "0")));
    			add_location(div, file$n, 346, 2, 8864);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*zIndexCSS, gridCSS, clipPathCSS*/ 7 && div_style_value !== (div_style_value = "" + (/*zIndexCSS*/ ctx[2][/*i*/ ctx[12]] + ";" + /*gridCSSPart*/ ctx[10] + ";" + /*clipPathCSS*/ ctx[1][/*i*/ ctx[12]] + ";background: #" + (/*i*/ ctx[12] * 3).toString().padStart(3, "0")))) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(346:1) {#each gridCSS as gridCSSPart, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let component;
    	let each_value = /*gridCSS*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			component = element("component");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(component, "class", "svelte-1nj8s3d");
    			add_location(component, file$n, 344, 0, 8813);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, component, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(component, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*zIndexCSS, gridCSS, clipPathCSS*/ 7) {
    				each_value = /*gridCSS*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(component, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(component);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getRandomCoordinateMatrix(matrixColumnsNumber, matrixRowsNumber) {
    	const matrix = [];
    	const matrixIndexes = [];

    	if (!matrixColumnsNumber || !matrixRowsNumber) {
    		return { matrix: null, matrixIndexes: null };
    	}

    	let blockIndex = 0;

    	for (let yIndex = 0, yLength = matrixRowsNumber; yIndex < yLength; ++yIndex) {
    		for (let xIndex = 0, xLength = matrixColumnsNumber; xIndex < xLength; ++xIndex) {
    			if (matrix[yIndex] === undefined) {
    				matrix[yIndex] = [];
    			} else if (matrix[yIndex][xIndex] !== undefined) {
    				continue;
    			}

    			// get index and then increment
    			const currentBlockIndex = blockIndex++;

    			// make the first move on the current block
    			matrix[yIndex][xIndex] = currentBlockIndex;

    			matrixIndexes[currentBlockIndex] = [[xIndex, yIndex]];
    			let yIndexMove = yIndex;
    			let xIndexMove = xIndex;

    			const move = () => {
    				const isGoingToMove = Math.random() > 0.1;

    				if (!isGoingToMove) {
    					return;
    				}

    				const direction = Math.floor(Math.random() * 4);

    				switch (direction) {
    					case 0:
    						--xIndexMove;
    						break;
    					case 1:
    						++yIndexMove;
    						break;
    					case 2:
    						++xIndexMove;
    						break;
    					case 3:
    						--yIndexMove;
    						break;
    				}

    				if (xIndexMove < 0 || xIndexMove >= xLength || yIndexMove < 0 || yIndexMove >= yLength) {
    					return;
    				}

    				if (matrix[yIndexMove] === undefined) {
    					matrix[yIndexMove] = [];
    				}

    				const target = matrix[yIndexMove][xIndexMove];

    				if (target !== undefined) {
    					return;
    				}

    				matrix[yIndexMove][xIndexMove] = currentBlockIndex;
    				matrixIndexes[currentBlockIndex].push([xIndexMove, yIndexMove]);
    				move();
    			};

    			move();
    		}
    	}

    	return { matrix, matrixIndexes };
    }

    /**
     * @param {coordinate[]} coordinates
     * */
    function getMaximumAndMinimumCoordinate(coordinates) {
    	const result = {
    		x: { maximum: null, minimum: null },
    		y: { maximum: null, minimum: null }
    	};

    	coordinates.forEach(([x, y]) => {
    		if (result.x.maximum == null || x > result.x.maximum) {
    			result.x.maximum = x;
    		}

    		if (result.x.minimum == null || x < result.x.minimum) {
    			result.x.minimum = x;
    		}

    		if (result.y.maximum == null || y > result.y.maximum) {
    			result.y.maximum = y;
    		}

    		if (result.y.minimum == null || y < result.y.minimum) {
    			result.y.minimum = y;
    		}
    	});

    	return result;
    }

    /** @param {number} number */
    function fromDecimalToPercent(number) {
    	return `${number * 100}%`;
    }

    /** @param {string} string */
    function fromPercentToDecimal(string) {
    	return Number(string.substr(0, string.length - 1)) / 100;
    }

    function getOffsetsFromDirection(direction) {
    	const offsets = { x: 0, y: 0 };

    	switch (direction) {
    		case 0:
    			offsets.y = -1;
    			break;
    		case 1:
    			offsets.x = 1;
    			break;
    		case 2:
    			offsets.y = 1;
    			break;
    		case 3:
    			offsets.x = -1;
    			break;
    		default:
    			throw new Error(`Unrecognized direction to get offsets from — ${direction}`);
    	}

    	return offsets;
    }

    function getInvertedDirection(direction) {
    	switch (direction) {
    		case 0:
    			return 2;
    		case 1:
    			return 3;
    		case 2:
    			return 0;
    		case 3:
    			return 1;
    		default:
    			throw new Error(`Unrecognized direction to invert — ${direction}`);
    	}
    }

    /** @param {[number, number][]} polygonVerticies */
    function getNearestVertexInDirection(direction, startingVertex, polygonVerticies) {
    	const offsets = getOffsetsFromDirection(direction);
    	const xOrY = Math.abs(offsets.y);
    	const isNextInsteadOfBefore = xOrY === 0 ? offsets.x > 0 : offsets.y > 0;

    	const validVerticies = polygonVerticies.filter(vertex => vertex[Number(!xOrY)] === startingVertex[Number(!xOrY)] && (isNextInsteadOfBefore
    	? vertex[xOrY] > startingVertex[xOrY]
    	: vertex[xOrY] < startingVertex[xOrY]));

    	const sortedVerticies = validVerticies.sort((a, b) => a[xOrY] - b[xOrY]);
    	return sortedVerticies[isNextInsteadOfBefore ? 0 : sortedVerticies.length - 1] ?? null;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $innerWritable;
    	const { innerWritable } = WindowUtility;
    	validate_store(innerWritable, "innerWritable");
    	component_subscribe($$self, innerWritable, value => $$invalidate(8, $innerWritable = value));
    	window.addEventListener("resize", render);
    	let columnsNumber = null;
    	let rowsNumber = null;

    	/** @typedef {[number, number]} coordinate */
    	/** @type coordinate */
    	let randomCoordinateMatrix = null;

    	/** @type coordinate[][] */
    	let randomCoordinateMatrixIndexes = null;

    	/** @type string[] */
    	const gridCSS = [];

    	/** @type string[] */
    	const clipPathCSS = [];

    	/** @type string[] */
    	const zIndexCSS = [];

    	render();

    	function render() {
    		columnsNumber = Math.floor($innerWritable.width / 100);
    		rowsNumber = Math.floor($innerWritable.height / 100);

    		if (!columnsNumber || !rowsNumber) {
    			return;
    		}

    		const { matrix, matrixIndexes } = getRandomCoordinateMatrix(columnsNumber, rowsNumber);
    		randomCoordinateMatrix = matrix;
    		randomCoordinateMatrixIndexes = matrixIndexes;

    		randomCoordinateMatrixIndexes.forEach((randomCoordinateMatrixIndex, i) => {
    			const maximumAndMinimumCoordinate = getMaximumAndMinimumCoordinate(randomCoordinateMatrixIndex);

    			const grid = {
    				column: `${maximumAndMinimumCoordinate.x.minimum + 1} / span ${maximumAndMinimumCoordinate.x.maximum - maximumAndMinimumCoordinate.x.minimum + 1}`,
    				row: `${maximumAndMinimumCoordinate.y.minimum + 1} / span ${maximumAndMinimumCoordinate.y.maximum - maximumAndMinimumCoordinate.y.minimum + 1}`
    			};

    			/** @typedef {[number, number]} vertex */
    			/** @type {Set<vertex>} */
    			const rawPolygon = [];

    			const totalWidth = maximumAndMinimumCoordinate.x.maximum - maximumAndMinimumCoordinate.x.minimum + 1;
    			const totalHeight = maximumAndMinimumCoordinate.y.maximum - maximumAndMinimumCoordinate.y.minimum + 1;
    			const unitWidth = 1;
    			const unitHeight = 1;

    			randomCoordinateMatrixIndex.forEach(([x, y]) => {
    				const xRelative = x - maximumAndMinimumCoordinate.x.minimum;
    				const yRelative = y - maximumAndMinimumCoordinate.y.minimum;
    				rawPolygon.push(`${fromDecimalToPercent(xRelative / totalWidth)} ${fromDecimalToPercent(yRelative / totalHeight)}`);
    				rawPolygon.push(`${fromDecimalToPercent(xRelative / totalWidth)} ${fromDecimalToPercent((yRelative + unitHeight) / totalHeight)}`);
    				rawPolygon.push(`${fromDecimalToPercent((xRelative + unitWidth) / totalWidth)} ${fromDecimalToPercent((yRelative + unitHeight) / totalHeight)}`);
    				rawPolygon.push(`${fromDecimalToPercent((xRelative + unitWidth) / totalWidth)} ${fromDecimalToPercent(yRelative / totalHeight)}`);
    			});

    			const filteredPolygon = (() => {
    				const seen = {};
    				const out = [];
    				let iii = 0;

    				for (let ii = 0, l = rawPolygon.length; ii < l; ii++) {
    					const item = rawPolygon[ii];
    					console.log(seen[item]);

    					if (seen[item] === undefined) {
    						seen[item] = 1;
    						out[iii++] = item;
    						continue;
    					}

    					seen[item] += 1;

    					if (seen[item] >= 4) {
    						console.log(out.splice(out.indexOf(item), 1));
    						--iii;
    					}
    				}

    				return out;
    			})();

    			const polygonVerticiesString = Array.from(filteredPolygon);

    			/** @type vertex[] */
    			const polygonVerticies = polygonVerticiesString.map(vertex => vertex?.split(" ").map(vertexPart => fromPercentToDecimal(vertexPart)));

    			const arrangedPolygonVerticies = hull_1(polygonVerticies, 0.7);
    			const arrangedPolygonVerticiesString = arrangedPolygonVerticies.map(vertex => vertex.map(vertexPart => fromDecimalToPercent(vertexPart)).join(" "));
    			$$invalidate(0, gridCSS[i] = `grid-column: ${grid.column}; grid-row: ${grid.row}`, gridCSS);
    			$$invalidate(1, clipPathCSS[i] = `clip-path: polygon(${arrangedPolygonVerticiesString})`, clipPathCSS);
    			$$invalidate(2, zIndexCSS[i] = `z-index: ${Math.floor((maximumAndMinimumCoordinate.x.minimum - maximumAndMinimumCoordinate.x.maximum + maximumAndMinimumCoordinate.y.minimum - maximumAndMinimumCoordinate.y.maximum) * 2) + 20}`, zIndexCSS);
    		});

    		console.log(gridCSS, clipPathCSS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Collage> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Collage", $$slots, []);

    	$$self.$capture_state = () => ({
    		hull: hull_1,
    		WindowUtility,
    		innerWritable,
    		columnsNumber,
    		rowsNumber,
    		randomCoordinateMatrix,
    		randomCoordinateMatrixIndexes,
    		gridCSS,
    		clipPathCSS,
    		zIndexCSS,
    		getRandomCoordinateMatrix,
    		getMaximumAndMinimumCoordinate,
    		fromDecimalToPercent,
    		fromPercentToDecimal,
    		getOffsetsFromDirection,
    		getInvertedDirection,
    		getNearestVertexInDirection,
    		render,
    		$innerWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("columnsNumber" in $$props) columnsNumber = $$props.columnsNumber;
    		if ("rowsNumber" in $$props) rowsNumber = $$props.rowsNumber;
    		if ("randomCoordinateMatrix" in $$props) randomCoordinateMatrix = $$props.randomCoordinateMatrix;
    		if ("randomCoordinateMatrixIndexes" in $$props) randomCoordinateMatrixIndexes = $$props.randomCoordinateMatrixIndexes;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [gridCSS, clipPathCSS, zIndexCSS, innerWritable];
    }

    class Collage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Collage",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\ui\scenes\LandingScene.svelte generated by Svelte v3.24.1 */

    // (63:0) <Scene   isPadded={false}   isInAnimated={true}   isOutAnimated={true}  >
    function create_default_slot$e(ctx) {
    	let terminal;
    	let t;
    	let collage;
    	let current;

    	terminal = new Terminal({
    			props: {
    				heightWritable: /*terminalHeightWritable*/ ctx[1]
    			},
    			$$inline: true
    		});

    	collage = new Collage({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(terminal.$$.fragment);
    			t = space();
    			create_component(collage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(terminal, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(collage, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(terminal.$$.fragment, local);
    			transition_in(collage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(terminal.$$.fragment, local);
    			transition_out(collage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(terminal, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(collage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(63:0) <Scene   isPadded={false}   isInAnimated={true}   isOutAnimated={true}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let scene;
    	let current;

    	scene = new Scene({
    			props: {
    				isPadded: false,
    				isInAnimated: true,
    				isOutAnimated: true,
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(scene.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(scene, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scene_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				scene_changes.$$scope = { dirty, ctx };
    			}

    			scene.$set(scene_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scene.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scene.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scene, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $innerWritable;
    	let $navigatorAppBarBaseHeight;
    	validate_store(navigatorAppBarBaseHeight, "navigatorAppBarBaseHeight");
    	component_subscribe($$self, navigatorAppBarBaseHeight, $$value => $$invalidate(4, $navigatorAppBarBaseHeight = $$value));
    	const { innerWritable } = WindowUtility;
    	validate_store(innerWritable, "innerWritable");
    	component_subscribe($$self, innerWritable, value => $$invalidate(3, $innerWritable = value));
    	const sms = new SMS(contacts.DebugScene);
    	sms.send(contacts.RenderScene, "hello!");

    	// const nameInput = null;
    	// const strs = [
    	// 	'Hello',
    	// 	'Warn!',
    	// 	'SOMETHING TELAH FUCKED',
    	// 	'ok nvm',
    	// 	'ok nvm',
    	// ];
    	// const hintStr = writable(strs[0]);
    	// const hintLvl = writable(0);
    	// const confirmDialogActive = writable(false);
    	// const inputDialogActive = writable(false);
    	// const okDialogActive = writable(false);
    	// let submitResult = null;
    	// let i = 0;
    	// setInterval(() => {
    	// 	hintStr.set(strs[i]);
    	// 	hintLvl.set(i);
    	// 	if (i >= 3) {
    	// 		i = 0;
    	// 		return;
    	// 	}
    	// 	++i;
    	// }, 500);
    	const terminalHeightWritable = writable(0);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LandingScene> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LandingScene", $$slots, []);

    	$$self.$capture_state = () => ({
    		push,
    		location,
    		writable,
    		Input,
    		Button,
    		ConfirmDialog,
    		InputDialog,
    		OkDialog,
    		AppBarScene,
    		HamburgerAppBar,
    		Scene,
    		SMS,
    		contacts,
    		NavigatorAppBar,
    		Terminal,
    		WindowUtility,
    		navigatorAppBarBaseHeight,
    		Collage,
    		innerWritable,
    		sms,
    		terminalHeightWritable,
    		inner,
    		$innerWritable,
    		$navigatorAppBarBaseHeight
    	});

    	$$self.$inject_state = $$props => {
    		if ("inner" in $$props) $$invalidate(2, inner = $$props.inner);
    	};

    	let inner;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$innerWritable*/ 8) {
    			 $$invalidate(2, inner = $innerWritable);
    		}

    		if ($$self.$$.dirty & /*inner, $navigatorAppBarBaseHeight*/ 20) {
    			 terminalHeightWritable.set(inner.height - $navigatorAppBarBaseHeight);
    		}
    	};

    	return [innerWritable, terminalHeightWritable];
    }

    class LandingScene extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LandingScene",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    class CompatiblerResultItem extends Item {
        constructor() {
            super(...arguments);
            this.common = {
                BaseSupportVersion: false,
            };
            this.rendering = {
                MediaRecorder: false,
                MediaStream: false,
            };
        }
    }
    class CompatiblerResultItemFactory extends Factory {
        static from(result) {
            return new CompatiblerResultItem().combine(result);
        }
    }

    // eslint-disable-next-line import/named
    class Compatibler {
        static test() {
            return CompatiblerResultItemFactory.from({
                // use functions to calculate final result
                // because getters aren't enumerable
                common: {
                    BaseSupportVersion: 'noModule' in document.createElement('script'),
                },
                rendering: {
                    MediaRecorder: (() => {
                        try {
                            // @ts-expect-error
                            new MediaRecorder(new MediaStream(), {
                                mimeType: 'video/webm; codecs=vp9',
                            });
                            return true;
                        }
                        catch (err) {
                            return false;
                        }
                    })(),
                    MediaStream: typeof MediaStream !== 'undefined',
                },
            });
        }
        static throw(result) {
            const reason = Object.keys(result)
                .map((categoryKey) => {
                const categoryValue = result[categoryKey];
                const prefix = `[${categoryKey}]: `;
                const unsupportedItems = Object.keys(categoryValue)
                    .map((categoryValueKey) => (!categoryValue[categoryValueKey]
                    ? categoryValueKey
                    : null));
                if (unsupportedItems.join('') === '') {
                    return '';
                }
                const unsupportedItemsResult = [];
                unsupportedItems.forEach((unsupportedItem) => (unsupportedItem != null
                    && unsupportedItemsResult.push(`${prefix}${unsupportedItem}\n`)));
                return unsupportedItemsResult.join('');
            })
                .join('\n');
            if (reason.trim().length === 0) {
                return;
            }
            throw new IncompatibleError({
                message: reason,
            });
        }
    }

    /* src\ui\scenes\RenderScene.svelte generated by Svelte v3.24.1 */
    const file$o = "src\\ui\\scenes\\RenderScene.svelte";

    // (15:0) <Scene   isInAnimated={true}   isOutAnimated={true}  >
    function create_default_slot$f(ctx) {
    	let heading;

    	const block = {
    		c: function create() {
    			heading = element("heading");
    			heading.textContent = `${/*context*/ ctx[0]}`;
    			add_location(heading, file$o, 18, 1, 444);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, heading, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(heading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(15:0) <Scene   isInAnimated={true}   isOutAnimated={true}  >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let scene;
    	let current;

    	scene = new Scene({
    			props: {
    				isInAnimated: true,
    				isOutAnimated: true,
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(scene.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(scene, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const scene_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				scene_changes.$$scope = { dirty, ctx };
    			}

    			scene.$set(scene_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scene.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scene.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scene, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	const sms = new SMS(contacts.RenderScene);
    	const context = sms.fetch(contacts.DebugScene).map(({ content }) => content)[0] ?? "";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RenderScene> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("RenderScene", $$slots, []);
    	$$self.$capture_state = () => ({ push, Scene, SMS, contacts, sms, context });
    	return [context];
    }

    class RenderScene extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RenderScene",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.24.1 */
    const file$p = "src\\App.svelte";

    function create_fragment$r(ctx) {
    	let main;
    	let navigatorappbar;
    	let updating_scrolledHeightWritable;
    	let updating_baseHeightWritable;
    	let t;
    	let router;
    	let current;

    	function navigatorappbar_scrolledHeightWritable_binding(value) {
    		/*navigatorappbar_scrolledHeightWritable_binding*/ ctx[5].call(null, value);
    	}

    	function navigatorappbar_baseHeightWritable_binding(value) {
    		/*navigatorappbar_baseHeightWritable_binding*/ ctx[6].call(null, value);
    	}

    	let navigatorappbar_props = { routes: /*RouteNames*/ ctx[4] };

    	if (/*scrolledHeightWritable*/ ctx[1] !== void 0) {
    		navigatorappbar_props.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    	}

    	if (/*baseHeightWritable*/ ctx[2] !== void 0) {
    		navigatorappbar_props.baseHeightWritable = /*baseHeightWritable*/ ctx[2];
    	}

    	navigatorappbar = new NavigatorAppBar({
    			props: navigatorappbar_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(navigatorappbar, "scrolledHeightWritable", navigatorappbar_scrolledHeightWritable_binding));
    	binding_callbacks.push(() => bind(navigatorappbar, "baseHeightWritable", navigatorappbar_baseHeightWritable_binding));

    	router = new Router({
    			props: { routes: /*Routes*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(navigatorappbar.$$.fragment);
    			t = space();
    			create_component(router.$$.fragment);
    			attr_dev(main, "class", "svelte-6h06oz");
    			add_location(main, file$p, 66, 0, 1882);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(navigatorappbar, main, null);
    			append_dev(main, t);
    			mount_component(router, main, null);
    			/*main_binding*/ ctx[7](main);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navigatorappbar_changes = {};

    			if (!updating_scrolledHeightWritable && dirty & /*scrolledHeightWritable*/ 2) {
    				updating_scrolledHeightWritable = true;
    				navigatorappbar_changes.scrolledHeightWritable = /*scrolledHeightWritable*/ ctx[1];
    				add_flush_callback(() => updating_scrolledHeightWritable = false);
    			}

    			if (!updating_baseHeightWritable && dirty & /*baseHeightWritable*/ 4) {
    				updating_baseHeightWritable = true;
    				navigatorappbar_changes.baseHeightWritable = /*baseHeightWritable*/ ctx[2];
    				add_flush_callback(() => updating_baseHeightWritable = false);
    			}

    			navigatorappbar.$set(navigatorappbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navigatorappbar.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navigatorappbar.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(navigatorappbar);
    			destroy_component(router);
    			/*main_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $scrolledHeightWritable,
    		$$unsubscribe_scrolledHeightWritable = noop,
    		$$subscribe_scrolledHeightWritable = () => ($$unsubscribe_scrolledHeightWritable(), $$unsubscribe_scrolledHeightWritable = subscribe(scrolledHeightWritable, $$value => $$invalidate(9, $scrolledHeightWritable = $$value)), scrolledHeightWritable);

    	let $baseHeightWritable,
    		$$unsubscribe_baseHeightWritable = noop,
    		$$subscribe_baseHeightWritable = () => ($$unsubscribe_baseHeightWritable(), $$unsubscribe_baseHeightWritable = subscribe(baseHeightWritable, $$value => $$invalidate(10, $baseHeightWritable = $$value)), baseHeightWritable);

    	$$self.$$.on_destroy.push(() => $$unsubscribe_scrolledHeightWritable());
    	$$self.$$.on_destroy.push(() => $$unsubscribe_baseHeightWritable());
    	Compatibler.throw(Compatibler.test());
    	let mainDomContent = null;
    	let scrolledHeightWritable = writable(0);
    	validate_store(scrolledHeightWritable, "scrolledHeightWritable");
    	$$subscribe_scrolledHeightWritable();
    	let baseHeightWritable = writable(0);
    	validate_store(baseHeightWritable, "baseHeightWritable");
    	$$subscribe_baseHeightWritable();

    	// const GlobalProps = {
    	// 	appBarScrolledHeightWritable,
    	// 	appBarBaseHeightWritable,
    	// };
    	const Paths = ["/", "/about", "/contact", "/portfolio"];

    	const Routes = {
    		[Paths[0]]: LandingScene,
    		[Paths[1]]: RenderScene,
    		[Paths[2]]: RenderScene,
    		[Paths[3]]: RenderScene
    	};

    	window.RouteNames = {
    		[Paths[0]]: strings.common.routes.info.HOME,
    		[Paths[1]]: strings.common.routes.info.ABOUT,
    		[Paths[2]]: strings.common.routes.info.CONTACT,
    		[Paths[3]]: strings.common.routes.info.PORTFOLIO
    	};

    	const { RouteNames } = window;

    	onMount(() => {
    		ScrollUtility.target = mainDomContent;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);

    	function navigatorappbar_scrolledHeightWritable_binding(value) {
    		scrolledHeightWritable = value;
    		$$subscribe_scrolledHeightWritable($$invalidate(1, scrolledHeightWritable));
    	}

    	function navigatorappbar_baseHeightWritable_binding(value) {
    		baseHeightWritable = value;
    		$$subscribe_baseHeightWritable($$invalidate(2, baseHeightWritable));
    	}

    	function main_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			mainDomContent = $$value;
    			$$invalidate(0, mainDomContent);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		writable,
    		Router,
    		wrap,
    		navigatorAppBarScrolledHeight,
    		navigatorAppBarBaseHeight,
    		LandingScene,
    		strings,
    		Compatibler,
    		RenderScene,
    		ScrollUtility,
    		NavigatorAppBar,
    		mainDomContent,
    		scrolledHeightWritable,
    		baseHeightWritable,
    		Paths,
    		Routes,
    		RouteNames,
    		$scrolledHeightWritable,
    		$baseHeightWritable
    	});

    	$$self.$inject_state = $$props => {
    		if ("mainDomContent" in $$props) $$invalidate(0, mainDomContent = $$props.mainDomContent);
    		if ("scrolledHeightWritable" in $$props) $$subscribe_scrolledHeightWritable($$invalidate(1, scrolledHeightWritable = $$props.scrolledHeightWritable));
    		if ("baseHeightWritable" in $$props) $$subscribe_baseHeightWritable($$invalidate(2, baseHeightWritable = $$props.baseHeightWritable));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$scrolledHeightWritable*/ 512) {
    			 navigatorAppBarScrolledHeight.set($scrolledHeightWritable);
    		}

    		if ($$self.$$.dirty & /*$baseHeightWritable*/ 1024) {
    			 navigatorAppBarBaseHeight.set($baseHeightWritable);
    		}
    	};

    	return [
    		mainDomContent,
    		scrolledHeightWritable,
    		baseHeightWritable,
    		Routes,
    		RouteNames,
    		navigatorappbar_scrolledHeightWritable_binding,
    		navigatorappbar_baseHeightWritable_binding,
    		main_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z = "\r\n\r\n@import url('https://fonts.googleapis.com/icon?family=Material+Icons');\r\n@import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');\r\nstring {\r\n\tdisplay: block;\r\n\r\n\tfont-family: var(--font-family-2);\r\n\tfont-weight: 400;\r\n\tfont-variation-settings: var(--font-variation-regular);\r\n\ttext-indent: 0;\r\n\tfont-size: 1rem;\r\n\tline-height: 0.9rem;\r\n\tletter-spacing: -0.08em;\r\n\tcolor: var(--colour-text-secondary);\r\n\r\n\tmargin-block-start: 1em;\r\n    margin-block-end: 1em;\r\n    margin-inline-start: 0px;\r\n\tmargin-inline-end: 0px;\r\n\t\r\n\tword-break: break-word;\r\n}\r\nheading {\r\n\tdisplay: block;\r\n\r\n\tfont-family: var(--font-family-1);\r\n\tfont-weight: 700;\r\n\tfont-variation-settings: var(--font-variation-bold);\r\n\tletter-spacing: -0.08em;\r\n\ttext-indent: 0;\r\n\tfont-size: 3rem;\r\n\tline-height: 3rem;\r\n\tcolor: var(--colour-text-primary);\r\n\r\n\t/* margin-block-start: 0.67em;\r\n    margin-block-end: 0.67em;\r\n    margin-inline-start: 0px;\r\n    margin-inline-end: 0px; */\r\n}\r\ncontainer {\r\n\tdisplay: block;\r\n}\r\nicon {\r\n\tdisplay: inline;\r\n\r\n\tfont-family: var(--font-family-ic);\r\n\tfont-variation-settings: var(--font-variation-regular);\r\n\ttext-indent: 0;\r\n\tfont-size: 1rem;\r\n\tline-height: 1rem;\r\n\tcolor: var(--colour-text-secondary);\r\n\r\n\tuser-select: none;\r\n}\r\nplaceholder {\r\n\tdisplay: none;\r\n}\r\ncomponent {\r\n\tdisplay: block;\r\n}\r\noverlay {\r\n\tposition: fixed;\r\n\theight: 100%;\r\n\twidth: 100%;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\r\n\topacity: 0.2;\r\n\tbackground: var(--colour-overlay);\r\n\r\n\tz-index: 1;\r\n}\r\n@charset 'utf-8';\r\n/* @font-face {\r\n\tfont-family: Uniform;\r\n\tfont-weight: 700;\r\n\tfont-style: normal;\r\n\tsrc: url(../raw/fonts/Uniform-Bold.eot);\r\n\tsrc: url(../raw/fonts/Uniform-Bold.otf) format(\"otf\");\r\n\tsrc: url(../raw/fonts/Uniform-Bold.ttf) format(\"ttf\");\r\n\tsrc: url(../raw/fonts/Uniform-Bold.woff) format(\"woff\");\r\n} */\r\n:root {\r\n\t--colour-accent-primary: #f78fb3;\r\n\t--colour-accent-secondary: #f8a5c2;\r\n\t--colour-warn-primary: #ff9f43;\r\n\t--colour-warn-secondary: #feca57;\r\n\t--colour-error-primary: #ee5253;\r\n\t--colour-error-secondary: #ff6b6b;\r\n\t--colour-ok-primary: #2ed573;\r\n\t--colour-ok-secondary: #7bed9f;\r\n\t--colour-overlay: black;\r\n}\r\n:root.theme\\:light {\r\n\t--colour-text-primary: #272829;\r\n\t--colour-text-secondary: #5a5c5e;\r\n\t--colour-background-primary: #ebf0f7;\r\n\t--colour-background-secondary: #e1e6ed;\r\n}\r\n:root.theme\\:dark {\r\n\t--colour-text-primary: #ebf0f7;\r\n\t--colour-text-secondary: #e1e6ed;\r\n\t--colour-background-primary: #272829;\r\n\t--colour-background-secondary: #161718;\r\n}\r\n:root {\r\n\t--ease-fast-slow: cubic-bezier(0.22, 1, 0.36, 1);\r\n\t--ease-slow-slow: cubic-bezier(0.77, 0, 0.175, 1);\r\n\t--ease-slow-fast: cubic-bezier(0.5, 0, 0.75, 0);\r\n\r\n\t/* @compat */\r\n\t--padding: calc(32px + 8%);\r\n\t--padding: min(12%, 140px);\r\n\t--roundness: 28px;\r\n\r\n\t--font-family-1: 'Space Mono', sans-serif;\r\n\t--font-family-2: 'Space Mono', sans-serif;\r\n\t--font-family-ic: 'Material Icons';\r\n\t--font-variation-thin: 'wght' 100;\r\n\t--font-variation-light-extra: 'wght' 200;\r\n\t--font-variation-light: 'wght' 300;\r\n\t--font-variation-regular: 'wght' 400;\r\n\t--font-variation-medium: 'wght' 500;\r\n\t--font-variation-bold-semi: 'wght' 600;\r\n\t--font-variation-bold: 'wght' 700;\r\n\t--font-variation-bold-extra: 'wght' 800;\r\n\t--font-variation-black: 'wght' 900;\r\n\r\n\t--box-shadow-drop: \r\n\t\t20px 20px 60px rgba(0, 0, 0, 0.5), \r\n\t\t-20px -20px 60px rgba(255, 255, 255, 0.5);\r\n\t--box-shadow-drop-inactive:\r\n\t\t0 0 0 rgba(0, 0, 0, 0.5),\r\n\t\t0 0 0 rgba(255, 255, 255, 0.5);\r\n\t--box-shadow-inner:\r\n\t\tinset 5px 5px 15px rgba(0, 0, 0, 0.3), \r\n\t\tinset -5px -5px 15px rgba(255, 255, 255, 0.3);\r\n\t--box-shadow-inner-inactive:\r\n\t\tinset 0 0 0 rgba(0, 0, 0, 0.3), \r\n\t\tinset 0 0 0 rgba(255, 255, 255, 0.3);\r\n}\r\nbody {\r\n\theight: 100vh;\r\n\tmargin: 0;\r\n}";
    styleInject(css_248z);

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    const app = new App({
        target: document.body,
        props: {},
    });

    return app;

}());
//# sourceMappingURL=svelte.bootstrap.js.map
